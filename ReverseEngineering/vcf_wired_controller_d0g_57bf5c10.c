/**
 * All captured data from simulation vcf_wired_controller_d0g_57bf5c10.bin using
 *  pinkySim.
 *
 * MIT License
 *
 * Copyright (c) 2017 Gregory Gluszek
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*******************************************************************************
  MEM LAYOUT: This section is set aside to track and define different 
   memory sections and how they are being used.

  EEPROM:

	0x000 (uint16_t) - Magic Number to indicate EEPROM has valid data
	0x002 (uint16_t) - Continuation of Magic Number? (Only checked in init phase 2 for hw version > 0)

	0x004 (uint32_t) - Board/HW Revision Number

	0x074 (uint8_t) - Power-on Jingle Index
	0x075 (uint8_t) - Power-off Jingle Index

	0x500 (uint32_t) - Think this might affect use of watchdog somehow, but not 100% sure


  init (phase1):

	0x10000254 (uint32_t) - Start of 0x8 bytes of EEPROM data from EEPROM offset 0
	0x10000258 (uint32_t) - Start of 0x8 bytes of EEPROM data from EEPROM offset 0


  init phase2 hw version not 0:

	USB_HID0 HID Report Descriptor (len 0x41):
	0x0000eeaa - 0x0000eeea
		 HID_UsagePage(HID_USAGE_PAGE_GENERIC)
		 HID_Usage(HID_USAGE_GENERIC_KEYBOARD)
		 HID_ReportCount(1)
		 HID_Collection(HID_Application)
		 HID_UsagePage(HID_USAGE_PAGE_KEYBOARD)
		 HID_UsageMin(224)
		 HID_UsageMax(231)
		 HID_LogicalMin(0)
		 HID_LogicalMax(1)
		 HID_ReportSize(1)
		 HID_ReportCount(8)
		 HID_Input(HID_Variable) // 0x02
		 HID_ReportCount(1)
		 HID_ReportSize(8)
		 HID_Input(HID_Constant) // 0x01
		 HID_ReportCount(5)
		 HID_ReportSize(1)
		 HID_UsagePage(HID_USAGE_PAGE_LED)
		 HID_UsageMin(1)
		 HID_UsageMax(5)
		 HID_Output(HID_Variable)
		 HID_ReportCount(1)
		 HID_ReportSize(3)
		 HID_Output(HID_Constant)
		 HID_ReportCount(6)
		 HID_ReportSize(8)
		 HID_LogicalMin(0)
		 HID_LogicalMax(101)
		 HID_UsagePage(HID_USAGE_PAGE_KEYBOARD)
		 HID_UsageMin(0)
		 HID_UsageMax(101)
		 HID_Input(HID_Data) // 0x00
		 HID_EndCollection
	
	USB_HID1 HID Report Descriptor (len 0x34):
	0x0000ee74 - 0x0000eea7
		HID_UsagePage(HID_USAGE_PAGE_GENERIC)
		HID_Usage(HID_USAGE_GENERIC_MOUSE)
		HID_Collection(HID_Application)
		HID_Usage(HID_USAGE_GENERIC_POINTER)
		HID_Collection(HID_Physical)
		HID_UsagePage(HID_USAGE_PAGE_BUTTON)
		HID_UsageMin(1)
		HID_UsageMax(5)
		HID_LogicalMin(0)
		HID_LogicalMax(1)
		HID_ReportCount(5)
		HID_ReportSize(1)
		HID_Input(HID_Variable) // 0x02
		HID_ReportCount(1)
		HID_ReportSize(3)
		HID_Input(HID_Constant) // 0x01
		HID_UsagePage(HID_USAGE_PAGE_GENERIC)
		HID_Usage(HID_USAGE_GENERIC_X)
		HID_Usage(HID_USAGE_GENERIC_Y)
		HID_Usage(HID_USAGE_GENERIC_WHEEL)
		HID_LogicalMin(-127)
		HID_LogicalMax(127)
		HID_ReportSize(8)
		HID_ReportCount(3)
		HID_Input(HID_Relative | HID_Variable) // 0x06
		HID_EndCollection

	USB_HID2 HID Report Descriptor (len 0x21):
	0x0000eeee - 0x0000ef0e
		HID_UsagePageVendor(HID_USAGE_PAGE_UNDEFINED)
		HID_Usage(HID_USAGE_GENERIC_POINTER)
		HID_Collection(HID_Application)
		HID_LogicalMin(0)
		HID_LogicalMaxS(255)
		HID_ReportSize(8)
		HID_ReportCount(64)
		HID_Usage(HID_USAGE_GENERIC_POINTER)
		HID_Input(HID_Variable) // 0x02
		HID_ReportCount(64)
		HID_Usage(HID_USAGE_GENERIC_POINTER)
		HID_Output(HID_Variable) // 0x02
		HID_ReportSize(64)
		HID_Output(HID_Constant) // 0x01
		HID_Feature(HID_Variable) // 0x02
		HID_EndCollection


	0x10000000 (uint8_t)  - Checked if is 0 in init if USB_VBUS detected and set to 1 shortly after.
	0x10000001 (uint8_t)  - Flag for CT16B0 IRQ generated by match on channel 0.
	0x10000002 (uint8_t)  - 
	0x10000003 (uint8_t)  - 
	0x10000004 (uint8_t)  - 
	0x10000005 (uint8_t)  - 

	0x10000010 (uint8_t)  - Marks that desired number of ADC conversions have occurred via interrupt.
	0x10000011 (uint8_t)  - Checked in ADC ISR. Related to whether USB cable is connected maybe (as it is set to 1 after checking for USB cable present in init...)? Or maybe whether AD samples have been accumulated?
	0x10000012 (uint8_t)  - Set bits indicate which AD is active (i.e. bit 6 for AD6)

	0x10000014 (uint32_t) - ADC ISR delay counter. Counts number of times ADC interrupt has been fired. When value reaches 0x0000012d ADC values actually start getting read.
	0x10000018 (uint32_t) - ADC ISR sample counter. Counts number of times ADCs are sampled. Counts up to 8 before ADC is disabled and 0x10000010 is set to indicate samples have been taken.

	0x10000045 (uint8_t)  - Defines which PWM is to be enabled for counter (i.e. CT16B1)

	0x10000047 (uint8_t)  - Related to MR0 value calculation
	0x10000048 (uint16_t) - 

	0x1000004a (uint16_t) - 
	0x1000004c (uint16_t) - 
	0x1000004e (uint16_t) - 

	0x10000050 (uint32_t) - Set to value 0x40010000 (Base register offset of to CT16B1). Determines which counter/timer is being used for Steam Button LED?
	0x10000054 (uint32_t) - 

	0x1000005C (uint32_t) - 

	0x10000080 (uint16_t) - USB_HID0 USB_HID_REPORT_T->len
	0x10000082 (uint8_t)  - USB_HID0 USB_HID_REPORT_T->idle_time 
	0x10000083 (uint8_t)  - USB_HID0 USB_HID_REPORT_T->__pad
	0x10000084 (uint32_t) - USB_HID0 USB_HID_REPORT_T->desc (of type uint8_t*)
	0x10000088 (uint32_t) - USB_HID0 related??
	0x1000008C (uint32_t) - USB_HID0 related??

	0x10000094 (uint32_t) - Hardware/Board Revision (copy of value read from EEPROM) (though only lowest 8 bits is used for compare...)

	0x100000a4 (uint32_t) - System Clock Frequency (CCLK) in MHz. (48000000 is calcualted and stored here).
	0x100000a8 (uint32_t) - I2C control register base address

	0x100000b0 (uint32_t) - Related to I2C IRQ. Function pointer.

	0x100000b8 (uint32_t) - Related to I2C IRQ. Pointer to some I2C_XFER_T for current transfer.
	0x100000bc (uint32_t) - Related to I2C IRQ? 
	0x100000c0 (uint32_t) - Related to I2C IRQ? 

	0x10000200 (uint8_t)  - ?? Check for possible branching path...
	0x10000201 (uint8_t)  - Defines which GPIO is being configured
	0x10000202 (uint8_t)  - ?? Checked in function called in PINT1. 0x10000340 lock/semaphore incremented around access.
	0x10000203 (uint8_t)  - Defines which GPIO is being configured (PIO1_12)

	0x10000205 (uint8_t)  - Defines which GPIO is being configured (PIO1_12)

	0x10000234 (uint8_t)  - Checked after SPI init (value initialized from SRAM1 value...). Number of haptics to init possibly?

	0x10000236 (uint8_t)  - Related to SSP0 clock enable (bit number for SYSAHBCLKCTRL)

	0x1000023a (uint8_t)  - Used to select GPIO base in relatedion to PIO1_15 (defines CS/SS for Right Haptic)
	0x1000023b (uint8_t)  - Used to select GPIO base in relatedion to PIO1_6 (defines CS/SS for Left Haptic)
	0x1000023c (uint8_t)  - Used to select GPIO number in relation PIO1_15 (defines CS/SS for Right Haptic)
	0x1000023d (uint8_t)  - Used to select GPIO number in relation PIO1_6 (defines CS/SS for Left Haptic)
	0x1000023e (uint8_t)  - Used to select GPIO base in relation to PIO0_23 (defines DR for Right Haptic)
	0x1000023f (uint8_t)  - Used to select GPIO base in relation to PIO1_16 (defines DR for Left Haptic)
	0x10000240 (uint8_t)  - Used to select GPIO number in relation to PIO0_23 (defines DR for Right Haptic)
	0x10000241 (uint8_t)  - Used to select GPIO number in relation to PIO1_16 (defines DR for Left Haptic)

	0x10000254 (uint32_t) - SSP0 control register base address

	0x100002ac (uint8_t)  - Used for calculating which GPIO to control in init (GPIO P1_10)
	0x100002ad (uint8_t)  - Used for calculating which GPIO to control in init (GPIO P1_10)
	0x100002ae (uint8_t)  - Used for calculating which GPIO to control in init (GPIO P1_10)
	0x100002af (uint8_t)  - Storage location for which AD pin is to be sampled, etc.

	0x100002b0 (uint8_t)  - ?? Check for possible branch... Sign extended

	0x100002b2 (uint8_t)  - Related to value of PIO0_2. Possibly inverse of value of PIO0_2 in init? Set to high value in interrupt handler for PIO0_2 state change...
	0x100002b3 (uint8_t)  - Related to value of PIO1_12 or PIO0_18 during init. If PIO1_12 is high, this is set to high. If PIO1_12 is low, this is set value of PIO0_18.

	0x100002b8 (uint16_t) - Checked if is greater than or equal to 0x000005dc if PIO0_2=1 during boot... (and USB_VBUS=0, PIO0_18=1, PIO1_12=1)
	0x100002ba (uint16_t) - 
	0x100002bc (uint32_t) - Function pointer. Called in PINT1.


	0x100002c4 (uint32_t) - Incremented during init and use to set value at 0x10000dd8

	0x100002c8 (uint32_t) - USB_HID2 Related?

	0x100002d0 (uint8_t)  - Used for calculating which GPIO to control in init (GPIO P1_1)
	0x100002d1 (uint8_t)  - Used for calculating which GPIO to control in init (GPIO P1_1)
	0x100002d2 (uint8_t)  - Related to TDI_PIO0_11 setup
	0x100002d3 (uint8_t)  - Related to TDO_PIO0_13 setup
	0x100002d4 (uint8_t)  - Related to TDI_PIO0_11 setup
	0x100002d5 (uint8_t)  - Related to TDO_PIO0_13 setup

	0x10000338 (uint32_t) - USB_HID2 Related?
	0x10000340 (uint8_t)  - Locking mechanism. Tracks if EEPROM access is taking place, and accessing other variables... Counting semaphore?

	0x10000348 (uint32_t) - Some callback function?

	0x1000034c (uint32_t) - USBD_HANDLE_T (is typedef void*)

	0x10000350 (uint32_t) - (const USBD_API_T *)LPC_ROM_API->usbdApiBase
	0x10000354 (uint32_t) - Tracks bottom of USB stack, as devices/eps are added (i.e. mem_base after init functions)
	0x10000358 (uint32_t) - mem_size from last USBD init call 

	0x10000364 (uint32_t) - USB_HID1 Related?
	0x10000368 (uint16_t) - USB_HID1 USB_HID_REPORT_T->len
	0x1000036a (uint8_t)  - USB_HID1 USB_HID_REPORT_T->idle_time 
	0x1000036b (uint8_t)  - USB_HID1 USB_HID_REPORT_T->__pad
	0x1000036c (uint32_t) - USB_HID1 USB_HID_REPORT_T->desc (of type uint8_t*)

	0x10000373 (uint8_t)  - Set to 1 at end of PINT1. Indicates interrupt occurred?

	0x1000037c (uint32_t) - Checked in PINT1. If 0 is set to 1 before exit...

	0x10000380 (uint32_t) - USB_HID2 Related?

	0x10000390 (uint16_t) - USB_HID2 USB_HID_REPORT_T->len
	0x10000392 (uint8_t)  - USB_HID2 USB_HID_REPORT_T->idle_time 
	0x10000393 (uint8_t)  - USB_HID2 USB_HID_REPORT_T->__pad
	0x10000394 (uint32_t) - USB_HID2 USB_HID_REPORT_T->desc (of type uint8_t*)

	0x100007e8 (uint32_t) - Related to CT16B0 configuration...?

	0x10000818 (uint32_t) - Function pointer. ISR for CT16B0 for match channel 0

	0x10000924 (uint8_t)  -
	0x10000925 (uint8_t)  -

	0x1000092a (uint8_t)  -
	0x1000092b (uint8_t)  -

	0x10000953 (uint8_t)  -
	0x10000954 (uint8_t)  -
	0x10000955 (uint8_t)  -
	0x10000956 (uint8_t)  -

	0x10000959 (uint8_t)  -
	0x10000960 (uint8_t)  -
	0x10000961 (uint8_t)  -
	0x10000962 (uint8_t)  -

	0x100009b4 (uint32_t) - Start of 0x84 bytes of EEPROM data from EEPROM offset 0
	...
	0x10000a34 (uint32_t) - End of 0x84 bytes of EEPROM data from EEPROM offset 0

	0x10000d80 (uint8_t)  - I2C_XFER_T.slaveAddr // 7-bit I2C Slave address
	0x10000d81 (uint8_t)  - I2C_XFER_T alignment_padding
	0x10000d82 (uint8_t)  - I2C_XFER_T alignment_padding
	0x10000d83 (uint8_t)  - I2C_XFER_T alignment_padding
	0x10000d84 (uint8_t*) - I2C_XFER_T.txBuff // Pointer to array of bytes to be transmitted
	0x10000d88 (uint32_t) - I2C_XFER_T.txSz // Number of bytes in transmit array, if 0 only receive transfer will be carried on
	0x10000d8c (uint8_t*) - I2C_XFER_T.rxBuff // Pointer memory where bytes received from I2C be stored
	0x10000d90 (uint32_t) - I2C_XFER_T.rxSz // Number of bytes to received, if 0 only transmission we be carried on
	0x10000d94 (uint32_t) - I2C_XFER_T.status // Status of the current I2C transfer
	0x10000d98 (uint8_t)  - I2C_XFER_T.txBuff[0]
	0x10000d99 (uint8_t)  - I2C_XFER_T.txBuff[1]

	0x10000dd8 (uint32_t) - Set with hardcoded value (write address based on value in 0x100002c4)

	0x10000f8c (uint16_t) - Accumulator for upper 10 bits of AD6 (shifted to LSBs of this value). Incremention occurs in ADC ISR.

	0x10000fa8 (uint32_t) - Function pointer. Related to handling accumulated results of AD6 readings?

	0x10000fb0 (uint32_t) - Possible function pointer. Related to AD0?
	0x10000fb4 (uint32_t) - Possible function pointer. Related to AD1?
	0x10000fb8 (uint32_t) - Possible function pointer. Related to AD2?
	0x10000fbc (uint32_t) - Possible function pointer. Related to AD3?
	0x10000fc0 (uint32_t) - Possible function pointer. Related to AD4?
	0x10000fc4 (uint32_t) - Possible function pointer. Related to AD5?
	0x10000fc8 (uint32_t) - Function pointer. Executes code that checks P1_12 and (potentially) P0_18. Related to AD6 (or at least 6 in AD6...).
	0x10000fcc (uint32_t) - Possible function pointer. Related to AD7?
	
	0x100010b4 (uint32_t) - Checked if is zero after USB init.
	0x100010b8 (uint32_t) - Function pointer. Branch to in PINT1. Most likely function for customer interrupt handling of PIO0_2 state changing.

	0x100010d8 (uint32_t) - Cleared in PINT1, while 0x10000340 lock/semaphore is incremented.

	0x10001140 (uint16_t) -
	0x10001142 (uint8_t)  - 
	0x10001143 (uint8_t)  - 

	0x20000002 (uint8_t)  - Number of active haptics (or haptics to configure)?

	0x200002a0 (uint16_t) - Related to MR0 value calulation
	0x200002a2 (uint16_t) - Related to MR0 value calulation

  init phase2 hw version 0:

	TODO: Even bother with cleaning up and improving this?

	0x10000208 Pointer to USB device configuration descriptor when device is operating in full and high speed modes.

	0x10000211 Pointer to the HID interface descriptor within the descriptor array (\em high_speed_desc) passed to Init() through \ref USB_CORE_DESCS_T structure.

	0x10000234 USB_HID_REPORT_T*
	//TODO: size and contents of USB_HID_REPORT_T

	0x10000250 incremented/decrement before/after cps. Has to do with disabling interrupts (I think)

	0x200040b8 - USBD_HANDLE_T - Handle to the USB device stack
	//TODO: size and content of USBD_HANDLE_T

	0x20004340 -  USB HID Base memory location from where the stack can allocate data and buffers
	...
	0x20004800

*******************************************************************************/

/**
 * In this simulation run the system was run from reset with no external input
 *  (except steps necessary to simulate expected hardware unit reactions). Possible
 *  triggering of IRQs were ignored. Parsed from exeLog_00000000001496459595.csv.
 *
 * ENTRY POINT 0x000000d4, as defined in Vector Table entry for RESET
 *
 * \return None.
 */
void init()
{
	volatile uint32_t* reg32 = NULL;
	uint32_t val = 0;

        // Entry Num: 1 - 24
        // Step Num: 1 - 16
	// Firmware Offset(s): 
	//	0x000000d4 - 0x000000d6
	//	0x00000fe0 - 0x00000fe4 
	//	0x000005a4 - 0x000005b8

	// Make sure crystal oscillator is powered                                      
	pwrAnalogBlock(reg0 = 0x00000020);


        // Entry Num: 25 - 45087
        // Step Num: 17 - 33814
	// Firmware Offset(s): 
	//	0x00000fe8 - 0x00000ffe

	// Delay required after last system control register mod?          
	for (uint32_t cnt = 0; cnt < 0x1600; cnt++);


        // Entry Num: 45088 - 45098
        // Step Num: 33815 - 33821
	// Firmware Offset(s): 
	//	0x00000520 - 0x0000052c

	// Select Crystal Oscillator (SYSOSC)                                           
	reg32 = (volatile uint32_t*)0x40048040;                                                               
	*reg32 = 1;                                                                       

	// Enable system PLL clock source update                                        
	reg32 = (volatile uint32_t*)0x40048044;                                                               
	*reg32 = 0;                                                                       
	*reg32 = 1;


        // Entry Num: 45099 - 45115
        // Step Num: 33822 - 33834
	// Firmware Offset(s): 
	//	0x00001002 - 0x00001004
	//	0x00000584 - 0x00000598

	// Power Configuration Register                                                 
	reg32 = (volatile uint32_t*)0x40048238;                                                               
	// Read current value                                                           
	val = *reg32;                                                                     
	// Clear reserved bit that must stay cleared                                    
	val &= 0x5ff;                                                                   
	// Make sure system PLL is powered down                                         
	val |= 0x80;                                                                    
	// Reserved bits that must always be set                                        
	val |= 0xe800;                                                                  
	*reg32 = val;                    


        // Entry Num: 45116 - 45122
        // Step Num: 33835 - 33839
	// Firmware Offset(s): 
	//	0x00001008 - 0x00001010

	// System PLL control register                                                  
	reg32 = (volatile uint32_t*)0x40048008;                                                               
	// Division ratio = 2 x 4. Feedback divider value = 3 + 1.                      
	*reg32 = 0x23;


        // Entry Num: 45123 - 45137
        // Step Num: 33840 - 33850
	// Firmware Offset(s): 
	//	0x000005a4 - 0x000005b8

	// Make sure system PLL is powered                                                 
	pwrAnalogBlock(reg0 = 0x00000080);


        // Entry Num: 45138 - 45143
        // Step Num: 33851 - 33855
	// Firmware Offset(s): 
	//	0x00001014 - 0x00001014
	//	0x00001018 - 0x0000101e

	// Wait until PLL is locked                                                     
	do{
		// System PLL status register                                                   
		reg32 = (volatile uint32_t*)0x4004800c;                                                               
	} while(((*reg32) & 1) == 0);


        // Entry Num: 45144 - 45161
        // Step Num: 33856 - 33868
	// Firmware Offset(s): 
	//	0x00001020 - 0x00001038

	// System clock divider register                                                
	reg32 = (volatile uint32_t*)0x40048078;                                                               
	// Set system AHB clock divider to 1.                                           
	*reg32 = 1;

	// Flash configuration register                                                 
	reg32 = (volatile uint32_t*)0x4003c010;                                                               
	val = *reg32;                                                                     
	// Bits 31:2 must be written back exactly as read                               
	val &= 0xFFFFFFC0;                                                              
	// Set flash access time to 3 system clocks (for system clock up to 50 MHz)     
	val |=  2;                                                                      
	*reg32 = val;


        // Entry Num: 45162 - 45171
        // Step Num: 33869 - 33874
	// Firmware Offset(s): 
	//	0x0000050c - 0x00000518

	// Main clock source select register                                            
	reg32 = (volatile uint32_t*)0x40048070;                                                               
	// Select PLL output                                                            
	*reg32 = 3;                                                                       

	// Main clock source update enable register                                     
	reg32 = (volatile uint32_t*)0x40048074;                                                               
	// No change                                                                    
	*reg32 = 0;                                                                       
	// Update clock source                                                          
	*reg32 = 1; 


        // Entry Num: 45172 - 45185
        // Step Num: 33875 - 33884
	// Firmware Offset(s): 
	//	0x0000103c - 0x0000103e
	//	0x00000548 - 0x00000554

	// USB PLL clock source select register                                         
	reg32 = (volatile uint32_t*)0x40048048;                                                               
	// Select system oscillator                                                     
	*reg32 = 1;                                                                       

	// USB PLL clock source update enable register                                  
	reg32 = (volatile uint32_t*)0x4004804c;                                                               
	// No change                                                                    
	*reg32 = 0;                                                                       
	// Update clock source.                                                         
	*reg32 = 1; 


        // Entry Num: 45186 - 45190
        // Step Num: 33885 - 33888
	// Firmware Offset(s): 
	//	0x00001042 - 0x00001048

	// USB PLL control register                                                     
	reg32 = (volatile uint32_t*)0x40048010;                                                               
	// Division ration is 2 x 4. Feedback divider value is 3 + 1.                   
	*reg32 = 0x23;


        // Entry Num: 45191 - 45205
        // Step Num: 33889 - 33899
	// Firmware Offset(s): 
	//	0x000005a4 - 0x000005b8

	// Set USB PLL and USB transceiver to powered                                   
	pwrAnalogBlock(reg0 = 0x00000500);


        // Entry Num: 45206 - 45211
        // Step Num: 33900 - 33904
	// Firmware Offset(s): 
	//	0x0000104c - 0x0000104c
	//	0x00001050 - 0x00001056

	// Wait for PLL locked                                                          
	do{
		// USB PLL status register                                                      
		reg32 = (volatile uint32_t*)0x40048014;                                                               
	} while (((*reg32) & 1) == 0);


        // Entry Num: 45212 - 45226
        // Step Num: 33905 - 33912
	// Firmware Offset(s): 
	//	0x00001058 - 0x00001066

	// System clock control register                                                
	reg32 = (volatile uint32_t*)0x40048080;                                                               
	val = *reg32;                                                                     
	// Enable I/O configuration block                                               
	val |= 0x10000;                                                                 
	*reg32 = val;


        // Entry Num: 45227 - 53704
        // Step Num: 33913 - 40670 
	// Firmware Offset(s): 
	//	0x000000d8 - 0x000000da
	//	0x000000c0 - 0x000000c4
	//	0x000003b4 - 0x000003ba
	//	0x000003c8 - 0x000003ca
	//	0x000003bc - 0x000003c4
	//	0x0000152c - 0x0000152c
	//	0x00001534 - 0x00001536
	//	0x00001538 - 0x00001538	
	//	0x000003c6 - 0x000003ca
	//	0x000003bc - 0x000003c4
	//	0x0000153c - 0x0000153e
	//	0x00001540 - 0x00001548
	//	0x000003c6 - 0x000003cc
	//	0x000000cc - 0x000000ca
 	//	0x0000154c - 0x0000154e
	//	0x00000fd0 - 0x00000fd2

	// Initialize heap (bss and/or data segment?) in SRAM0
	*0x10000200 = 0x00000000
	*0x10000204 = 0x00002000	
	*0x10000208 = 0x00220209 // Passed as full_speed_desc later...
	*0x1000020c = 0x80000101
	*0x10000210 = 0x00040932
	*0x10000214 = 0x00030100
	*0x10000218 = 0x21090000
	*0x1000021c = 0x01000111	
	*0x10000220 = 0x07002122	
	*0x10000224 = 0x40038105	
	*0x10000228 = 0x00000600
	*0x1000022c = 0x00000000
	*0x10000230 = 0x00000000
	*0x10000234 = 0x00000000
	*0x10000238 = 0x00000000
	*0x1000023c = 0x00000000
	*0x10000240 = 0x00000000
	*0x10000244 = 0x00000000	
	*0x10000248 = 0x00000000	
	*0x1000024c = 0x00000000	
	*0x10000250 = 0x00000000	
	*0x10000254 = 0x00000000 // To be filled with data read from EEPROM (lower 16-bits are magic word?)
	*0x10000258 = 0x00000000 // To be filled with data read from EEPROM (indicates hardware version)
	*0x1000025c = 0x00000000 // Bytes seem to be used for marked CT32B1 as enabled, and whether CT32B1 interrupt occurred
	*0x10000260 = 0x00000000 // Results calculations based on value of system PLL control register (used for EEPROM access calculations)
	Clear 0x10000264 - 0x10001c1c (inclusive 4 byte writes)


        // Entry Num: 53705 - 53722
        // Step Num: 40671 - 40684
	// Firmware Offset(s): 
	//	0x00000494 - 0x00000496
	//	0x00000450 - 0x0000046a

	checkMainClockSourceSel();


        // Entry Num: 53723 - 53740
        // Step Num: 40685 - 40696
	// Firmware Offset(s): 
	//	0x000004d0 - 0x000004d2
	//	0x000004a8 - 0x000004b4
	//	0x000004be - 0x000004c2

	checkSysPllClockSrcSel();


        // Entry Num: 53741 - 54149
        // Step Num: 40697 - 41067
	// Firmware Offset(s): 
	//	0x000004d6 - 0x000004dc
	//	0x00000488 - 0x00000492
	//	0x000004e0 - 0x000004e0
	//	0x0000046e - 0x0000046e
	//	0x0000049a - 0x0000049e
	//	0x00000300 - 0x0000030c
	//	0x00000322 - 0x00000328
	//	0x0000030e - 0x0000032a
	//	0x000004a2 - 0x000004a2
	//	0x00000fd6 - 0x00000fda
	//	0x00001552 - 0x00001552
	//	0x00000d04 - 0x00000d0c
	//	0x00000bdc - 0x00000bf0
	//	0x00000bb4 - 0x00000bc0

	// Setup for EEPROM read via IAP command (i.e. calculation of system clock frequency):
	//
	// System PLL control register
	// reg32 = (volatile uint32_t*)0x40048008;
	// val = *reg32;
	// Perform calculations based on value of system PLL control register
	// Save results to 0x10000260
	//
	//	*0x10001bc0 = 0x0000003e Command code : 62
	//	*0x10001bc4 = 0x00000000 Param0: EEPROM Address = 0
	//	*0x10001bc8 = 0x10000254 Param1: RAM Address = 0x10000254
	//	*0x10001bcc = 0x00000008 Param2: Number of bytes to be read = 8
	//	*0x10001bd0 = 0x0000b71b Param3: System Clock Frequency = 0x0000b71b

	unsigned int command_param[5];
	unsigned int status_result[4];

	uint32_t eeprom_data[2];

	// Command 62 for EEPROM Read
	command_param[0] = 62;
	// EEPROM address (4 kB available)
	command_param[1] = 0;
	// RAM address where to read data to write to EEPROM
	command_param[2] = eeprom_data;
	// Number of bytes to write
	command_param[3] = sizeof(eeprom_data);
	// System clock frequency in kHz
	command_param[4] = 46875;


        // Entry Num: 54150 - 54163
        // Step Num: 41068 - 41077
	// Firmware Offset(s): 
	//	0x000007bc - 0x000007ba
	//	0x00000bc4 - 0x00000bca

	// Increment value in 0x10000250
	//	Has to do with cps command (i.e. disabling/enabling interrupts)
	// Call into IAB command function


        // Entry Num: 54164 - 55980
        // Step Num: 41078  - 42737
	// Firmware Offset(s): 
	//	0x1fff1ff0 - 0x1fff1ff2
	//	0x1fff171c - 0x1fff171c
	//	... 

	// boot ROM code for executing IAB command
	iap_entry(command_param = 0x10001bc0, status_result = 0x10001bd4);

	// Surprisingly no check of status_result...


        // Entry Num: 55981 - 55991
        // Step Num: 42738 - 42745
	// Firmware Offset(s): 
	//	0x00000bcc - 0x00000bcc
	//	0x000007c0 - 0x000007cc

	// Decrement value in 0x10000250
	//	Has to do with cps command (i.e. disabling/enabling interrupts)


        // Entry Num: 55992 - 56010
        // Step Num: 42746 - 42754
	// Firmware Offset(s): 
	//	0x00000bd0 - 0x00000bd4
	//	0x00000bf4 - 0x00000bf4
	//	0x00000d10 - 0x00000d18

	// Check if (uint16_t*)0x10000254 has value 0xa55a stored in it
	//	This is where EEPROM read data ends up
	// If it had been we would skip writing to EEPROM
	//	Not branching to 0x00000d26

	if ((uint16_t)eeprom_data[0] != 0xa55a)
	{
		// TODO: should re-sim this case to make sure we got everything correctly...
		// Firmware Offset(s): 
		//	0x00000f5c - 0x00000f64
		//	0x00000bfc - 0x00000c10
		//	0x00000bb4 - 0x00000bc0
		//	0x000007b0 - 0x000007ba
		//	0x00000bc4 - 0x00000bca

		// Filling in EEPROM with expected value (magic word to show EEPROM has been used by Steam Controller before?)	
		// 	*0x10000254 = 0x0000a55a
		// IAP command Write EEPROM
		//	*0x10001bb8 = 0x0000003d Command code : 61 (0x3d)
		//	*0x10001bbc = 0x00000000 Param0: EEPROM Address = 0
		//	*0x10001bc0 = 0x10000254 Param1: RAM Address = 0x10000254
		//	*0x10001bc4 = 0x00000008 Param2: Number of bytes to be read = 8
		//	*0x10001bc8 = 0x0000b71b Param3: System Clock Frequency = 0x0000b71b

		// Data to write to EEPROM
		eeprom_data[0] |= 0xa55a;
		eeprom_data[1] = 0;

		// Command 61 for EEPROM Write
		command_param[0] = 61;
		// EEPROM address (4 kB available)
		command_param[1] = 0;
		// RAM address where to read data to write to EEPROM
		command_param[2] = eeprom_data;
		// Number of bytes to write
		command_param[3] = sizeof(eeprom_data);
		// System clock frequency in kHz
		command_param[4] = 46875;


		// Firmware Offset(s): 
		//	0x1fff1ff0 - 0x1fff1ff2
		//	0x1fff171c - 0x1fff171c
		//	... 

		// boot ROM code for executing IAB command

		iap_entry(command_param = 0x10001bb8, status_result = 0x10001bcc);	

		// Surprisingly no check of status_result...


		// Firmware Offset(s): 
		//	0x00000bcc - 0x00000bcc
		//	0x000007c0 - 0x000007cc

		// Decrement value in 0x10000250
		//	Has to do with cps command (i.e. disabling/enabling interrupts)
	}


	// Firmware Offset(s): 
	//	0x00000d26 - 0x00000d26
	//	0x00001556 - 0x00001558
	//	0x00000428 - 0x00000434

	// Enables clock for GPIO port registers via system clock control register
	reg32 = (volatile uint32_t*)0x40048080;
	val = *reg32;
	val |= 0x40;
	*reg32 = val;


	// Firmware Offset(s): 
	//	0x0000155c - 0x0000155c
	//	0x00000ce8 - 0x00000cf0
	//	0x00000cf4 - 0x00000cf4

	bool usbConnected = usbVoltPresent();


	// Firmware Offset(s): 
	//	0x00001560 - 0x0000156a

	// To be used for setting upcoming GPIO value
	int gpio_val = 1; 

	if (!usbConnected){
		// System reset status register
		reg = (volatile uint32_t*)0x40048030;
		val = *reg;

		// Check for brown out detect reset
		if ((0x8 & val) == 0x8){
			// Firmware Offset(s): 
			//	0x0000156c - 0x00001572

			// Clear brown out detect status
			*reg = 0x8;
			gpio_val = 0; // Reg 0
		} else {
			// Firmware Offset(s): 
			//	0x0000157a - 0x0000157c
			gpio_val = 1; // Reg 0
		}
	} else {
		// Firmware Offset(s): 
		//	0x0000157a - 0x0000157c
		gpio_val = 1; // Reg 0
	}


	// Firmware Offset(s): 
	//	0x00000f90 - 0x00000f94
	//	0x00000cf8 - 0x00000cfc
	//	0x00000f98 - 0x00000fa0
	//	0x00000fa2 - 0x00000fac
	//	0x00000fae - 0x00000fae
	//	0x00000cf8 - 0x00000cfc
	//	0x00000fb2 - 0x00000fb6
 	//	0x00000fb8 - ??
	//	0x00000fbe - 0x00000fc0

	uint32_t gpio_num = drivePwrUpGpio(hwVer = 0x10000258, uint8_t gpioVal = gpio_val);


	// Firmware Offset(s): 
	//	0x00000fc2 - 0x00000fc4

	// Branch to LR (0x0000055c)


	// Firmware Offset(s): 
	//	0x0000055c - 0x00000570

	// Set PIO1_{gpio_num} to output via GPIO direction port 1 register
	setGpioOutDir(baseAddr = 0x50000000, port = 1, gpioNum = gpio_num);


	// Firmware Offset(s): 
	//	0x00000fc8 - 0x00000fc8
	//	0x00001580 - 0x00001582
	//	0x000007a0 - 0x000007a8

	// Set GPREG1 to 0
	reg32 = (volatile uint32_t*)0x40038008;
	*reg32 = 0;


	// Firmware Offset(s): 
	//	0x00001586 - 0x0000159a
	//	0x00000572 - 0x00000576
	//	0x0000057e - 0x00000580

	// Enable pull down resistor on PIO0_3 register
	// *(uint32_t*)0x4004400c = 0x00000008;
	set32bitReg(uint32_t baseReg = 0x40044000, uint8_t additionalOffset = 0, regWordOffset = 0x00000003, regVal = 0x00000008);


	// Firmware Offset(s): 
	//	0x0000159e - 0x000015a2
	//	0x0000158c - 0x0000159a
	//	0x00000572 - 0x00000576
	//	0x0000057e - 0x00000580

	// Set PIO0_6 to function as ~USB_CONNECT
	// *(uint32_t*)0x40044018 = 0x00000001;
	set32bitReg(uint32_t baseReg = 0x40044000, uint8_t additionalOffset = 0, regWordOffset = 0x00000006, regVal = 0x00000001);
	

	// Firmware Offset(s): 
	//	0x0000159e - 0x000015a2
	//	0x0000158c - 0x0000159a
	//	0x00000572 - 0x0000057c

	// Set PIO1_17 to function as RXD - Receiver input for USART (for communications with Radio Chip?)
	// *(uint32_t*)0x400440a4 = 0x00000002;
	set32bitReg(uint32_t baseReg = 0x40044000, uint8_t additionalOffset = 1, regWordOffset = 0x00000011, regVal = 0x00000002);


	// Firmware Offset(s): 
	//	0x0000158c - 0x0000159a
	//	0x00000572 - 0x0000057c

	// Set PIO1_18 to function as TXD - Transmitter output for USART (for communications with Radio Chip?)
	// *(uint32_t*)0x400440a8 = 0x00000002
	set32bitReg(uint32_t baseReg = 0x40044000, uint8_t additionalOffset = 1, regWordOffset = 0x00000012, regVal = 0x00000002);


	// Firmware Offset(s): 
	//	0x0000159e - 0x000015a4
	//	0x00000ce8 - 0x00000cf0
	//	0x00000cf4 - 0x00000cf4

	usbConnected = usbVoltPresent();


	// Firmware Offset(s): 
	//	0x000015a8 - 0x000015ac
	//	0x00000f90 - 0x00000f94
	//	0x00000cf8 - 0x00000cfc
	//	0x00000f98 - 0x00000fa0
	//	0x00000fa2 - 0x00000fac
	//	0x00000fae - 0x00000fae
	//	0x00000cf8 - 0x00000cfc
	//	0x00000fb2 - 0x00000fb6
 	//	0x00000fb8 - ??
	//	0x00000fbe - 0x00000fc0

	gpio_num = drivePwrUpGpio(hwVer = 0x10000258, uint8_t gpioVal = !usbConnected);


	// Firmware Offset(s): 
	//	0x00000fc2 - 0x00000fc4

	// Branch to LR (0x0000055c)


	// Firmware Offset(s): 
	//	0x0000055c - 0x00000570

	// Set PIO1_{gpio_num} to output via GPIO direction port 1 register
	setGpioOutDir(baseAddr = 0x50000000, port = 1, gpioNum = gpio_num);


	// Firmware Offset(s): 
	//	0x00000fc8 - 0x00000fc8
	//	0x000015b0 - 0x000015ba
	//	0x00000bdc - 0x00000bf0
	//	0x00000bb4 - 0x00000bc0
	//	0x000007b0 - 0x000007ba
	//	0x00000bc4 - 0x00000bca

	// Setup for EEPROM read via IAP command (i.e. calculation of system clock frequency)
	//	*0x10001bc8 = 0x0000003e Command code : 62 (0x3e)
	//	*0x10001bcc = 0x00000500 Param0: EEPROM Address = 0x00000500
	//	*0x10001bd0 = 0x10001c08 Param1: RAM Address = 0x10001c08
	//	*0x10001bd4 = 0x00000004 Param2: Number of bytes to be read = 4
	//	*0x10001bd8 = 0x0000b71b Param3: System Clock Frequency = 0x0000b71b

	// To store data read from EEPROM
	uint32_t eeprom_data2;

	// Command 62 for EEPROM Read
	command_param[0] = 62;
	// EEPROM address (4 kB available)
	command_param[1] = 0x500;
	// RAM address where to read data to write to EEPROM
	command_param[2] = eeprom_data2;
	// Number of bytes to write
	command_param[3] = sizeof(eeprom_data2);
	// System clock frequency in kHz
	command_param[4] = 46875;


	// Firmware Offset(s): 
	//	0x1fff1ff0 - 0x1fff1ff2
	//	0x1fff171c - 0x1fff171c
	//	... 

	// boot ROM code for executing IAP command
	
	iap_entry(command_param = 0x10001bc8, status_result = 0x10001bdc);	

	// Surprisingly no check of status_result...


	// Firmware Offset(s): 
	//	0x00000bcc - 0x00000bcc
	//	0x000007c0 - 0x000007cc

	// Decrement 0x10000250 and cps (change processor state (to reenable interrupts after IAP command?)


	// Firmware Offset(s): 
	//	0x00000bd0 - 0x00000bd4
	//	0x00000bf4 - 0x00000bf4
	//	0x000015be - 0x000015c4 

	// Check if 0x10001c08 (Value read from EEPROM) is 0
	if (eeprom_data2 != 0)
	{
		// Firmware Offset(s): 
		//	0x000015c6 - 0x000015ce 
		// 	0x00000bfc - 0x00000c10
		//	0x00000bb4 - 0x00000bc0

		*(uint32_t*)0x10001c0c = 0;

		// Setup for EEPROM write via IAP command 
		//	*0x10001bc8 = 0x0000003d Command code : 61 (0x3d)
		//	*0x10001bcc = 0x00000500 Param0: EEPROM Address = 0x00000500
		//	*0x10001bd0 = 0x10001c0c Param1: RAM Address = 0x10001c0c
		//	*0x10001bd4 = 0x00000004 Param2: Number of bytes to be read = 4
		//	*0x10001bd8 = 0x0000b71b Param3: System Clock Frequency = 0x0000b71b

		// Firmware Offset(s): 
		//	0x000007b0 - 0x000007ba
		//	0x00000bc4 - 0x00000bca

		// For marking cps state of disabling interrupts (I think)
		*(uint32_t*)0x10000250 += 1;

		// Firmware Offset(s): 
		//	0x1fff1ff0 - 0x1fff1ff2
		//	0x1fff171c - 0x1fff171c
		//	... 

		// boot ROM code for executing IAB command
		iap_entry(command_param = 0x10001bc8, status_result = 0x10001bdc);


		// Firmware Offset(s): 
		//	0x00000bcc - 0x00000bcc
		//	0x000007d0 - 0x000007cc

		// Decrement 0x10000250 and cps (change processor state (to reenable interrupts after IAP command?)
	}


	// Firmware Offset(s): 
	//	0x000015de - 0x000015e6

	// Check if GPREG0 is set to 0xecaabac0
	reg32 = 0x40038004;
	val = *reg32;
	if (val == 0xecaabac0)
	{
	     // TODO: UNKNOWN PATHS
	     //	If GPREG0 is 0xecaabac0 execute instruction 0x000015e6 instead of branching to 0x000015ec
	}


	// Firmware Offset(s): 
	//	0x000015ec - 0x000015fa
	//	0x000015fc - 0x000015fc

	// Call into some function that checks if Reg 0 is set to 0xecaabac0. 
	//  I think this is an impossible path, as Reg 0 is set compare above.
	//  Either way UKNOWN PATH is to branch to instruction at 0x00001618 if Reg 0 does not equal 0xecaabac0


	// Firmware Offset(s): 
	//	0x00000cf8 - 0x00000cfc
	//	0x00001600 - 0x00001602	

	// Check hw version read from EEPROM
	if (*0x10000258 == 0) {
		// This path I decomposed before properly aquiring EEPROM
		//  data. This is kept mostly for the sake of having already
		//  put the work in. It most likely will not actually be 
		//  useful at this point.
		init_phase2_hw_0();
	} else {
		// This path matches behavior of my Steam Controller.
		init_phase2_hw_not0();
	}
}

/**
 * Function to enable power to a specified analog block.
 *
 * Firmware Offset(s): 
 *	0x000005a4 - 0x000005b8
 * 
 * \param reg0 Set bit(s) specify which blocks to power. See 3.5.41 
 *	Power configuration register in UM10462 for details.
 * 
 * \return None.
 */
void pwrAnalogBlock(uint32_t reg0)
{
	// Power Configuration Register                                                 
	volatile uint32_t* reg32 = (volatile uint32_t*)0x40048238;
	uint32_t val = 0;

	// Read current register value                                                           
	val = *reg32;                                                                     
	// Clear reserved bit that must stay cleared                                    
	val &= 0x000005ff;                                                              
	// Clear desired bit (clearing enables desired block(s))
	val &= ~(reg0 & 0x000005ff);                                                           
	// Reserved bits that must always be set                                        
	val |= 0xe800;                                                                  

	// Write result to register
	*reg32 = val;  
}

/**
 * Function for setting a 32-bit register to a particular value.
 * 
 * Firmware Offset(s): 
 * 	0x00000572 - 0x00000576
 *	0x00000578 - 0x0000057c
 * 	0x0000057e - 0x00000580
 *
 * \param baseReg Base register value
 * \param additionalOffset Add additional 0x60 byte offset to baseReg
 * \param regWordOffset Word sized offset from baseReg indicates which register to change
 * \param regVal Value to write to register
 * 
 * \return None.
 */
void set32bitReg(uint32_t baseReg, uint8_t additionalOffset, uint32_t regWordOffset, uint32_t regVal)
{
	regWordOffset <<= 2;

	if (additionalOffset != 0)
	{
		// Execture instruction 0x00000578
		volatile uint32_t* reg32 = (volatile uint32_t*)(baseReg + regWordOffset + 0x60);
		*reg32 = regVal;
		return;
	}

	volatile uint32_t* reg32 = (volatile uint32_t*)baseReg + regWordOffset;
	*reg32 = regVal;
}

/**
 * Function for checking Main Clock Source Select Register.
 * 
 * Firmware Offset(s): 
 *	0x00000494 - 0x00000496
 *	0x00000450 - 0x0000046a
 * 
 * \return None.
 */
void checkMainClockSourceSel(){
	// Check main clock source select register and verify is set to PLL output
	//  reg32 = (volatile uint32_t*)0x40048070;
	//  val = *reg32;
	//  if (val ...)
	//  {
		// TODO: UKNOWN PATHS
		// 	Branch to 0x00000470 if 0x3&val is 0
		// 	Branch to 0x00000474 if val is 1
		// 	Branch to 0x0000047a if val is 2
		// 	Branch to 0x0000046e if val != 3
	//  }
}

/**
 * Function for checking Main Clock Source Select Register.
 * 
 * Firmware Offset(s): 
 * 	0x000004d0 - 0x000004d2
 *	0x000004a8 - 0x000004b4
 *	0x000004be - 0x000004c2
 * 
 * \return None.
 */
void checkSysPllClockSrcSel(){
	// Check system PLL clock source select register and verify is set to Crystal Oscillator (SYSOSC)
	//  reg32 = (volatile uint32_t*)0x40048040;
	//  val = *reg32;
	//  if (val ...)
	//  {
		// TODO: UKNOWN PATHS
		// 	Branch to 0x000004ba if val is 0
		// 	Execute instruction at 0x000004b6 if val != 1
	//  }
}

/**
 * Check if a USB voltage is detected (i.e. from plugged in cable).
 *
 * Firmware Offset(s): 
 *	0x00000ce8 - 0x00000cf0
 *	0x00000cf2 - ...
 *	0x00000cf4 - 0x00000cf4
 *
 * \return True if USB cable is plugged into controller. False otherwise. (Reg 0).
 */
bool usbVoltPresent(){
	bool retval = false;

	// Check state of PIO0_3 (USB voltage detected) 
	uint8_t val = *((uint8_t*)0x50000003);

	if (val) {
		// TODO: UKNOWN PATHS
		//	if PIO0_3 is not 0 (USB cable is conected) instruction at 0x00000cf2 is executed
	}

	return retval;
}

/**
 * Set the specified GPIO direction to output via the GPIO port direcetion 
 *  registers.
 *
 * Firmware Offset(s): 
 *	0x0000055c - 0x00000570
 *
 * \param baseAddr Base address of GPIO registers (Reg 0).
 * \param port Specify port 0 or port 1 banks of GPIOs (Reg 1).
 * \param gpioNum 0-based GPIO number to set as an output (Reg 2).
 *
 * \return None.
 */
void setGpioOutDir(uint32_t baseAddr, uint32_t port, uint32_t gpioNum) {
	volatile uint32_t* reg32 = (volatile uint32_t*)(baseAddr + 0x2000 + port * 4)
	uint32_t val = *reg32;
	val |= (1 << gpioNum);
	*reg32 = val;
}

/**
 * Set a GPIO's state as part of power up. GPIO driven differs based on hw
 *  version.
 *
 * Firmware Offset(s): 
 *	0x00000f90 - 0x00000f94
 * 	0x00000cf8 - 0x00000cfc
 * 	0x00000f98 - 0x00000fa0
 *	0x00000fa2 - 0x00000fac
 *	0x00000fae - 0x00000fae
 *	0x00000cf8 - 0x00000cfc
 *	0x00000fb2 - 0x00000fb6
 *	0x00000fb8 - ??
 *	0x00000fbe - 0x00000fc0
 *
 * \param hwVer Pointer to data read from EEPROM that stores hw version data. //TODO: This is referred to as Board Revision in Steam. My controller is 10
 * \param gpioVal Value to drive power up GPIO at (Reg 0).
 *
 * \return 0-based GPIO number that is being driven for proper power up.
 */
uint32_t drivePwrUpGpio(uint32_t* hwVer, uint8_t gpioVal) {
	int gpio_num = 0;

	if (*hwVer >= 8) {
		// Firmware Offset(s): 
		//	0x00000fa2 - 0x00000fac

		// Set PIO1_10 output bit
		*((uint8_t*)0x5000002a) = !gpio_val;
		gpio_num = 10;
	} else {
		// Firmware Offset(s): 
		//	0x00000fae - 0x00000fae

		// Entry Num: 58028 - 58035
		// Step Num: 44549 - 44555
		// Firmware Offset(s): 
		//	0x00000cf8 - 0x00000cfc
		//	0x00000fb2 - 0x00000fb6

		// Read value of 0x10000258 and check if it's 5
		//	TODO: UNKNOWN PATHS
		//		If value from EEPROM (written to 0x10000258) is 5, excecute instruction at 0x00000fb8

		// Entry Num: 58036 - 58040
		// Step Num: 44556 - 44559
		// Firmware Offset(s): 
		//	0x00000fbe - 0x00000fc0
		// Set PIO1_8 output bit
		*((uint8_t*)0x50000028) = gpio_val;
		gpio_num = 8;
	}

	return gpio_num;
}

/**
 * There reaches a point in the init code (i.e. execution starting from the RESET
 *  entry point as defined in the Vector Table) in which the hw version read 
 *  from EEPROM causes a significant branch in the code. I am calling everything
 *  after this branch point phase2, and creating different functions to 
 *  encapsulate what has been decomposed depending on what hw version was read.
 *
 * This function captures the path of reading a hw version that is not 0.
 *
 * Note that this matches the path my Steam Controller takes. 
 *
 * \return None.
 */
void init_phase2_hw_not0() 
{
	// Firmware Offset(s): 
	//	0x000007a0 - 0x000007a8

	// Set GPREG1 to 1
	reg32 = (volatile uint32_t*)0x40038008;
	*reg32 = 1;


	// Firmware Offset(s): 
	//	0x0000160a - 0x0000160c
	//	0x00000428 - 0x00000434
	//	0x00001610 - 0x00001610

	// Enables SRAM1 block at address 0x2000 0000 via system clock control register
	reg32 = (volatile uint32_t*)0x40048080;
	val = *reg32;
	val |= 0x04000000;
	*reg32 = val;


	// Firmware Offset(s): 
	//	0x000000dc - 0x000000e8
	//	0x000020d4 - 0x000020d6
	//	0x000020c0 - 0x000020c4
	//	0x000029e4 - 0x000029ea
	//	0x000029f8 - 0x000029fa
	
	// Read a whole bunch of code from flash and compare results
	//  There is a branch here, but its impossible given values are
	//   read from firmware section of memory.
	//  Not sure purpose of all this...


	// Firmware Offset(s): 
	//	0x000029ec - 0x000029f4
	//	0x0000c2cc - 0x0000c2cc

	// Read more code from flash into registers...


	// Firmware Offset(s): 
	//	0x0000c2ce - 0x0000c2d8

	// Initialize some heap space in SRAM0
	*(uint32_t*)0x10000000 = 0;
	*(uint32_t*)0x10000004 = 0;
	*(uint32_t*)0x10000008 = 0;
	*(uint32_t*)0x1000000c = 0;
	*(uint32_t*)0x10000010 = 0;
	*(uint32_t*)0x10000014 = 0;
	*(uint32_t*)0x10000018 = 0;
	*(uint32_t*)0x1000001c = 0;
	*(uint32_t*)0x10000020 = 0;
	*(uint32_t*)0x10000024 = 0;
	*(uint32_t*)0x10000028 = 0;
	*(uint32_t*)0x1000002c = 0;
	*(uint32_t*)0x10000030 = 0;
	*(uint32_t*)0x10000034 = 0;
	*(uint32_t*)0x10000038 = 0;
	*(uint32_t*)0x1000003c = 0;
	*(uint32_t*)0x10000040 = 0;
	*(uint32_t*)0x10000044 = 0;
	*(uint32_t*)0x10000048 = 0;
	*(uint32_t*)0x1000004c = 0;
	*(uint32_t*)0x10000050 = 0;
	*(uint32_t*)0x10000054 = 0;
	*(uint32_t*)0x10000058 = 0;
	*(uint32_t*)0x1000005c = 0;
	*(uint32_t*)0x10000060 = 0;
	*(uint32_t*)0x10000064 = 0;
	*(uint32_t*)0x10000068 = 0;
	*(uint32_t*)0x1000006c = 0;
	*(uint32_t*)0x10000070 = 0;
	*(uint32_t*)0x10000074 = 0;
	*(uint32_t*)0x10000078 = 0;
	*(uint32_t*)0x1000007c = 0;
	*(uint32_t*)0x10000080 = 0;
	*(uint32_t*)0x10000084 = 0;
	*(uint32_t*)0x10000088 = 0;
	*(uint32_t*)0x1000008c = 0;
	*(uint32_t*)0x10000090 = 0;
	*(uint32_t*)0x10000094 = 0;
	*(uint32_t*)0x10000098 = 0;
	*(uint32_t*)0x1000009c = 0;
	*(uint32_t*)0x100000a0 = 0;
	*(uint32_t*)0x100000a4 = 0; // 48000000 is stored here and may be some calculated clock rate
	*(uint32_t*)0x100000a8 = 0;
	*(uint32_t*)0x100000ac = 0;
	*(uint32_t*)0x100000b0 = 0;
	*(uint32_t*)0x100000b4 = 0;
	*(uint32_t*)0x100000b8 = 0;
	*(uint32_t*)0x100000bc = 0;
	*(uint32_t*)0x100000c0 = 0;


	// Firmware Offset(s): 
	//	0x000029f6 - 0x000029fa
	//	0x000029ec - 0x000029f4
	//	0x00002a2a - 0x00002a36
	//	0x00002a3c - 0x00002a3e	
	//	0x00002a46 - 0x00002a5a
	//	0x00002a78 - 0x00002a7a

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x10000200 = 0xff;
	*(uint8_t*)0x10000201 = 0xff;
	*(uint8_t*)0x10000202 = 0x00;
	*(uint8_t*)0x10000203 = 0x00;


	// Firmware Offset(s): 
	//	0x00002a2e - 0x00002a36
	//	0x00002a3c - 0x00002a3e
	//	0x00002a40 - 0x00002a44
	//	0x00002a46 - 0x00002a60

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x10000204 = 0x01;
	*(uint8_t*)0x10000205 = 0x0e;
	*(uint8_t*)0x10000206 = 0x08;
	*(uint8_t*)0x10000207 = 0x00;


	// Firmware Offset(s): 
	//	0x00002a58 - 0x00002a60
	//	0x00002a78 - 0x00002a7a

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x10000206 = 0x00;
	*(uint8_t*)0x10000207 = 0x00;
	*(uint8_t*)0x10000208 = 0x00;
	*(uint8_t*)0x10000209 = 0x00;
	*(uint8_t*)0x1000020a = 0x00;
	*(uint8_t*)0x1000020b = 0x00;
	*(uint8_t*)0x1000020c = 0x00;
	*(uint8_t*)0x1000020d = 0x00;
	*(uint8_t*)0x1000020e = 0x00;
	*(uint8_t*)0x1000020f = 0x00;
	*(uint8_t*)0x10000210 = 0x00;
	*(uint8_t*)0x10000211 = 0x00;
	*(uint8_t*)0x10000212 = 0x00;
	*(uint8_t*)0x10000213 = 0x00;
	*(uint8_t*)0x10000214 = 0x00;
	*(uint8_t*)0x10000215 = 0x00;
	*(uint8_t*)0x10000216 = 0x00;
	*(uint8_t*)0x10000217 = 0x00;
	*(uint8_t*)0x10000218 = 0x00;
	*(uint8_t*)0x10000219 = 0x00;
	*(uint8_t*)0x1000021a = 0x00;
	*(uint8_t*)0x1000021b = 0x00;
	*(uint8_t*)0x1000021c = 0x00;
	*(uint8_t*)0x1000021d = 0x00;
	*(uint8_t*)0x1000021e = 0x00;
	*(uint8_t*)0x1000021f = 0x00;
	*(uint8_t*)0x10000220 = 0x00;
	*(uint8_t*)0x10000221 = 0x00;
	*(uint8_t*)0x10000222 = 0x00;
	*(uint8_t*)0x10000223 = 0x00;
	*(uint8_t*)0x10000224 = 0x00;
	*(uint8_t*)0x10000225 = 0x00;
	*(uint8_t*)0x10000226 = 0x00;
	*(uint8_t*)0x10000227 = 0x00;
	*(uint8_t*)0x10000228 = 0x00;
	*(uint8_t*)0x10000229 = 0x00;
	*(uint8_t*)0x1000022a = 0x00;
	*(uint8_t*)0x1000022b = 0x00;
	*(uint8_t*)0x1000022c = 0x00;
	*(uint8_t*)0x1000022d = 0x00;
	*(uint8_t*)0x1000022e = 0x00;
	*(uint8_t*)0x1000022f = 0x00;
	*(uint8_t*)0x10000230 = 0x00;
	*(uint8_t*)0x10000231 = 0x00;
	*(uint8_t*)0x10000232 = 0x00;
	*(uint8_t*)0x10000233 = 0x00;
	*(uint8_t*)0x10000234 = 0x00;
	*(uint8_t*)0x10000235 = 0x00;


	// Firmware Offset(s): 
	//	0x00002a2e - 0x00002a36
	//	0x00002a3c - 0x00002a3e
	//	0x00002a46 - 0x00002a60
	//	0x00002a78 - 0x00002a7a

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x10000236 = 0x0b;
	*(uint8_t*)0x10000237 = 0x00;
	*(uint8_t*)0x10000238 = 0x00;
	*(uint8_t*)0x10000239 = 0x00;
	*(uint8_t*)0x1000023a = 0x00;


	// Firmware Offset(s): 
	//	0x00002a2e - 0x00002a36
	//	0x00002a3c - 0x00002a3e
	//	0x00002a46 - 0x00002a60	

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x1000023b = 0x01;
	*(uint8_t*)0x1000023c = 0x16;
	*(uint8_t*)0x1000023d = 0x0d;
	*(uint8_t*)0x1000023e = 0x01;
	*(uint8_t*)0x1000023f = 0x00;


	// Firmware Offset(s): 
	//	0x00002a58 - 0x00002a5a
	//	0x00002a78 - 0x00002a7a
	//	0x00002a2e - 0x00002a36
	//	0x00002a3c - 0x00002a44
	//	0x00002a46 - 0x00002a5a
	//	0x00002a78 - 0x00002a7a

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x10000240 = 0x1c;
	*(uint8_t*)0x10000241 = 0x07;
	*(uint8_t*)0x10000242 = 0x00;
	*(uint8_t*)0x10000243 = 0x00;
	*(uint8_t*)0x10000244 = 0x00;
	*(uint8_t*)0x10000245 = 0x00;
	*(uint8_t*)0x10000246 = 0x00;
	*(uint8_t*)0x10000247 = 0x00;
	*(uint8_t*)0x10000248 = 0x00;
	*(uint8_t*)0x10000249 = 0x00;
	*(uint8_t*)0x1000024a = 0x00;
	*(uint8_t*)0x1000024b = 0x00;
	*(uint8_t*)0x1000024c = 0x00;
	*(uint8_t*)0x1000024d = 0x00;
	*(uint8_t*)0x1000024e = 0x00;
	*(uint8_t*)0x1000024f = 0x00;
	*(uint8_t*)0x10000250 = 0x00;
	*(uint8_t*)0x10000251 = 0x00;
	*(uint8_t*)0x10000252 = 0x00;
	*(uint8_t*)0x10000253 = 0x00;
	*(uint8_t*)0x10000254 = 0x00;
	*(uint8_t*)0x10000255 = 0x00;


	// Firmware Offset(s): 
	//	0x00002a2e - 0x00002a36	
	//	0x00002a3c - 0x00002a3e
	//	0x00002a46 - 0x00002a5a
	//	0x00002a78 - 0x00002a7a

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x10000256 = 0x04;
	*(uint8_t*)0x10000257 = 0x40;
	*(uint8_t*)0x10000258 = 0x00;
	*(uint8_t*)0x10000259 = 0x00;
	*(uint8_t*)0x1000025a = 0x00;
	*(uint8_t*)0x1000025b = 0x00;
	*(uint8_t*)0x1000025c = 0x00;
	*(uint8_t*)0x1000025d = 0x00;
	*(uint8_t*)0x1000025e = 0x00;
	*(uint8_t*)0x1000025f = 0x00;
	*(uint8_t*)0x10000260 = 0x00;
	*(uint8_t*)0x10000261 = 0x00;
	*(uint8_t*)0x10000262 = 0x00;
	*(uint8_t*)0x10000263 = 0x00;
	*(uint8_t*)0x10000264 = 0x00;
	*(uint8_t*)0x10000265 = 0x00;
	*(uint8_t*)0x10000266 = 0x00;
	*(uint8_t*)0x10000267 = 0x00;
	*(uint8_t*)0x10000268 = 0x00;
	*(uint8_t*)0x10000269 = 0x00;
	*(uint8_t*)0x1000026a = 0x00;
	*(uint8_t*)0x1000026b = 0x00;
	*(uint8_t*)0x1000026c = 0x00;
	*(uint8_t*)0x1000026d = 0x00;
	*(uint8_t*)0x1000026e = 0x00;
	*(uint8_t*)0x1000026f = 0x00;
	*(uint8_t*)0x10000270 = 0x00;
	*(uint8_t*)0x10000271 = 0x00;
	*(uint8_t*)0x10000272 = 0x00;
	*(uint8_t*)0x10000273 = 0x00;
	*(uint8_t*)0x10000274 = 0x00;
	*(uint8_t*)0x10000275 = 0x00;
	*(uint8_t*)0x10000276 = 0x00;
	*(uint8_t*)0x10000277 = 0x00;
	*(uint8_t*)0x10000278 = 0x00;
	*(uint8_t*)0x10000279 = 0x00;
	*(uint8_t*)0x1000027a = 0x00;
	*(uint8_t*)0x1000027b = 0x00;
	*(uint8_t*)0x1000027c = 0x00;
	*(uint8_t*)0x1000027d = 0x00;
	*(uint8_t*)0x1000027e = 0x00;
	*(uint8_t*)0x1000027f = 0x00;
	*(uint8_t*)0x10000280 = 0x00;
	*(uint8_t*)0x10000281 = 0x00;


	// Firmware Offset(s): 
	//	0x00002a2e - 0x00002a36
	//	0x00002a3c - 0x00002a44
	//	0x00002a46 - 0x00002a5a
	//	0x00002a78 - 0x00002a7a

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x10000282 = 0x01;
	*(uint8_t*)0x10000283 = 0x01;
	*(uint8_t*)0x10000284 = 0x00;
	*(uint8_t*)0x10000285 = 0x00;
	*(uint8_t*)0x10000286 = 0x00;
	*(uint8_t*)0x10000287 = 0x00;
	*(uint8_t*)0x10000288 = 0x00;
	*(uint8_t*)0x10000289 = 0x00;
	*(uint8_t*)0x1000028a = 0x00;
	*(uint8_t*)0x1000028b = 0x00;
	*(uint8_t*)0x1000028c = 0x00;
	*(uint8_t*)0x1000028d = 0x00;
	*(uint8_t*)0x1000028e = 0x00;
	*(uint8_t*)0x1000028f = 0x00;
	*(uint8_t*)0x10000290 = 0x00;
	*(uint8_t*)0x10000291 = 0x00;
	*(uint8_t*)0x10000292 = 0x00;
	*(uint8_t*)0x10000293 = 0x00;
	*(uint8_t*)0x10000294 = 0x00;
	*(uint8_t*)0x10000295 = 0x00;
	*(uint8_t*)0x10000296 = 0x00;
	*(uint8_t*)0x10000297 = 0x00;
	*(uint8_t*)0x10000298 = 0x00;
	*(uint8_t*)0x10000299 = 0x00;
	*(uint8_t*)0x1000029a = 0x00;
	*(uint8_t*)0x1000029b = 0x00;
	*(uint8_t*)0x1000029c = 0x00;
	*(uint8_t*)0x1000029d = 0x00;
	*(uint8_t*)0x1000029e = 0x00;
	*(uint8_t*)0x1000029f = 0x00;
	*(uint8_t*)0x100002a0 = 0x00;
	*(uint8_t*)0x100002a1 = 0x00;
	*(uint8_t*)0x100002a2 = 0x00;
	*(uint8_t*)0x100002a3 = 0x00;
	*(uint8_t*)0x100002a4 = 0x00;
	*(uint8_t*)0x100002a5 = 0x00;
	*(uint8_t*)0x100002a6 = 0x00;
	*(uint8_t*)0x100002a7 = 0x00;
	*(uint8_t*)0x100002a8 = 0x00;
	*(uint8_t*)0x100002a9 = 0x00;
	*(uint8_t*)0x100002aa = 0x00;
	*(uint8_t*)0x100002ab = 0x00;


	// Firmware Offset(s): 
	//	0x00002a2e - 0x00002a36
	//	0x00002a3c - 0x00002a3e
	//	0x00002a4e - 0x00002a54
	//	0x00002a62 - 0x00002a6a
	//	0x00002a6c - 0x00002a7a

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x100002ac = 0xff;
	*(uint8_t*)0x100002ad = 0xff;
	*(uint8_t*)0x100002ae = 0x00;


	// Firmware Offset(s): 
	//	0x00002a2e - 0x00002a36
	//	0x00002a3c - 0x00002a3e
	//	0x00002a46 - 0x00002a54
	//	0x00002a62 - 0x00002a7a

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x100002af = 0xff;
	*(uint8_t*)0x100002b0 = 0xff;
	*(uint8_t*)0x100002b1 = 0xff;
	*(uint8_t*)0x100002b2 = 0x00;
	*(uint8_t*)0x100002b3 = 0x00;


	// Firmware Offset(s): 
	//	... - 0x00002a7a (See note below)

	// Note: This SRAM0 heap initialization is going on forever, 
	//  and repetitive, but not repetivie enough to generalize into
	//  a function (conditionals are based on code reads from 
	//  flash).
	// Therefore, I'm going to just list how the memory is being
	//  setup without concern for all the firmware offsets being
	//  used as code. It may be worth painstakingly revisiting this
	//  in the future if something isn't adding up in terms of an
	//  important branch (not based on code read from flash).

	// Initialize more heap space in SRAM0
	*(uint8_t*)0x100002b4  = 0x;

	*(uint8_t*)0x100002b4 = 0x00
	*(uint8_t*)0x100002b5 = 0x00
	*(uint8_t*)0x100002b6 = 0x01
	*(uint8_t*)0x100002b7 = 0x00
	*(uint8_t*)0x100002b8 = 0x00
	*(uint8_t*)0x100002b9 = 0x00
	*(uint8_t*)0x100002ba = 0xca
	*(uint8_t*)0x100002bb = 0x08
	*(uint8_t*)0x100002bc = 0x00
	*(uint8_t*)0x100002bd = 0x00
	*(uint8_t*)0x100002be = 0x00
	*(uint8_t*)0x100002bf = 0x00
	*(uint8_t*)0x100002c0 = 0x00
	*(uint8_t*)0x100002c1 = 0x00
	*(uint8_t*)0x100002c2 = 0x00
	*(uint8_t*)0x100002c3 = 0x40
	*(uint8_t*)0x100002c4 = 0x00
	*(uint8_t*)0x100002c5 = 0x00
	*(uint8_t*)0x100002c6 = 0x00
	*(uint8_t*)0x100002c7 = 0x00
	*(uint8_t*)0x100002c8 = 0x00
	*(uint8_t*)0x100002c9 = 0x00
	*(uint8_t*)0x100002ca = 0x00
	*(uint8_t*)0x100002cb = 0x00
	*(uint8_t*)0x100002cc = 0x00
	*(uint8_t*)0x100002cd = 0x00
	*(uint8_t*)0x100002ce = 0x00
	*(uint8_t*)0x100002cf = 0x00
	*(uint8_t*)0x100002d0 = 0xff
	*(uint8_t*)0x100002d1 = 0xff
	*(uint8_t*)0x100002d2 = 0xff
	*(uint8_t*)0x100002d3 = 0xff
	*(uint8_t*)0x100002d4 = 0xff
	*(uint8_t*)0x100002d5 = 0xff
	*(uint8_t*)0x100002d6 = 0x00
	*(uint8_t*)0x100002d7 = 0x00
	*(uint8_t*)0x100002d8 = 0x00
	*(uint8_t*)0x100002d9 = 0x00
	*(uint8_t*)0x100002da = 0x00
	*(uint8_t*)0x100002db = 0x00
	*(uint8_t*)0x100002dc = 0x00
	*(uint8_t*)0x100002dd = 0x00
	*(uint8_t*)0x100002de = 0x00
	*(uint8_t*)0x100002df = 0x00
	*(uint8_t*)0x100002e0 = 0x00
	*(uint8_t*)0x100002e1 = 0x00
	*(uint8_t*)0x100002e2 = 0x00
	*(uint8_t*)0x100002e3 = 0x00
	*(uint8_t*)0x100002e4 = 0x00
	*(uint8_t*)0x100002e5 = 0x00
	*(uint8_t*)0x100002e6 = 0x00
	*(uint8_t*)0x100002e7 = 0x00
	*(uint8_t*)0x100002e8 = 0x00
	*(uint8_t*)0x100002e9 = 0x00
	*(uint8_t*)0x100002ea = 0x00
	*(uint8_t*)0x100002eb = 0x00
	*(uint8_t*)0x100002ec = 0x00
	*(uint8_t*)0x100002ed = 0x00
	*(uint8_t*)0x100002ee = 0x00
	*(uint8_t*)0x100002ef = 0x00
	*(uint8_t*)0x100002f0 = 0x00
	*(uint8_t*)0x100002f1 = 0x00
	*(uint8_t*)0x100002f2 = 0x00
	*(uint8_t*)0x100002f3 = 0x00
	*(uint8_t*)0x100002f4 = 0x00
	*(uint8_t*)0x100002f5 = 0x00
	*(uint8_t*)0x100002f6 = 0x00
	*(uint8_t*)0x100002f7 = 0x00
	*(uint8_t*)0x100002f8 = 0x00
	*(uint8_t*)0x100002f9 = 0x00
	*(uint8_t*)0x100002fa = 0x00
	*(uint8_t*)0x100002fb = 0x00
	*(uint8_t*)0x100002fc = 0x00
	*(uint8_t*)0x100002fd = 0x00
	*(uint8_t*)0x100002fe = 0x00
	*(uint8_t*)0x100002ff = 0x00
	*(uint8_t*)0x10000300 = 0x00
	*(uint8_t*)0x10000301 = 0x00
	*(uint8_t*)0x10000302 = 0x00
	*(uint8_t*)0x10000303 = 0x00
	*(uint8_t*)0x10000304 = 0x00
	*(uint8_t*)0x10000305 = 0x00
	*(uint8_t*)0x10000306 = 0x00
	*(uint8_t*)0x10000307 = 0x00
	*(uint8_t*)0x10000308 = 0x00
	*(uint8_t*)0x10000309 = 0x00
	*(uint8_t*)0x1000030a = 0x00
	*(uint8_t*)0x1000030b = 0x00
	*(uint8_t*)0x1000030c = 0x00
	*(uint8_t*)0x1000030d = 0x00
	*(uint8_t*)0x1000030e = 0x00
	*(uint8_t*)0x1000030f = 0x00
	*(uint8_t*)0x10000310 = 0x02
	*(uint8_t*)0x10000311 = 0x03
	*(uint8_t*)0x10000312 = 0x00
	*(uint8_t*)0x10000313 = 0x00
	*(uint8_t*)0x10000314 = 0x00
	*(uint8_t*)0x10000315 = 0x00
	*(uint8_t*)0x10000316 = 0x00
	*(uint8_t*)0x10000317 = 0x00
	*(uint8_t*)0x10000318 = 0x00
	*(uint8_t*)0x10000319 = 0x00
	*(uint8_t*)0x1000031a = 0x00
	*(uint8_t*)0x1000031b = 0x00
	*(uint8_t*)0x1000031c = 0x00
	*(uint8_t*)0x1000031d = 0x00
	*(uint8_t*)0x1000031e = 0x00
	*(uint8_t*)0x1000031f = 0x00
	*(uint8_t*)0x10000320 = 0x00
	*(uint8_t*)0x10000321 = 0x00
	*(uint8_t*)0x10000322 = 0x00
	*(uint8_t*)0x10000323 = 0x00
	*(uint8_t*)0x10000324 = 0x00
	*(uint8_t*)0x10000325 = 0x00
	*(uint8_t*)0x10000326 = 0x00
	*(uint8_t*)0x10000327 = 0x00
	*(uint8_t*)0x10000328 = 0x01
	*(uint8_t*)0x10000329 = 0x00
	*(uint8_t*)0x1000032a = 0x00
	*(uint8_t*)0x1000032b = 0x00
	*(uint8_t*)0x1000032c = 0x00
	*(uint8_t*)0x1000032d = 0x00
	*(uint8_t*)0x1000032e = 0x00
	*(uint8_t*)0x1000032f = 0x00
	*(uint8_t*)0x10000330 = 0x00
	*(uint8_t*)0x10000331 = 0x00
	*(uint8_t*)0x10000332 = 0x00
	*(uint8_t*)0x10000333 = 0x00
	*(uint8_t*)0x10000334 = 0x00
	*(uint8_t*)0x10000335 = 0x00
	*(uint8_t*)0x10000336 = 0x00
	*(uint8_t*)0x10000337 = 0x00
	*(uint8_t*)0x10000338 = 0x00
	*(uint8_t*)0x10000339 = 0x00
	*(uint8_t*)0x1000033a = 0x00
	*(uint8_t*)0x1000033b = 0x00
	*(uint8_t*)0x1000033c = 0x00
	*(uint8_t*)0x1000033d = 0x00
	*(uint8_t*)0x1000033e = 0x00
	*(uint8_t*)0x1000033f = 0x00
	*(uint8_t*)0x10000340 = 0x00 // Tracks if EEPROM access is taking place
	*(uint8_t*)0x10000341 = 0x00
	*(uint8_t*)0x10000342 = 0x00
	*(uint8_t*)0x10000343 = 0x00
	*(uint8_t*)0x10000344 = 0x00
	*(uint8_t*)0x10000345 = 0x00
	*(uint8_t*)0x10000346 = 0x00
	*(uint8_t*)0x10000347 = 0x00
	*(uint8_t*)0x10000348 = 0x00
	*(uint8_t*)0x10000349 = 0x00
	*(uint8_t*)0x1000034a = 0x00
	*(uint8_t*)0x1000034b = 0x00
	*(uint8_t*)0x1000034c = 0x00
	*(uint8_t*)0x1000034d = 0x00
	*(uint8_t*)0x1000034e = 0x00
	*(uint8_t*)0x1000034f = 0x00
	*(uint8_t*)0x10000350 = 0x00
	*(uint8_t*)0x10000351 = 0x00
	*(uint8_t*)0x10000352 = 0x00
	*(uint8_t*)0x10000353 = 0x00
	*(uint8_t*)0x10000354 = 0x00
	*(uint8_t*)0x10000355 = 0x00
	*(uint8_t*)0x10000356 = 0x00
	*(uint8_t*)0x10000357 = 0x00
	*(uint8_t*)0x10000358 = 0x00
	*(uint8_t*)0x10000359 = 0x00
	*(uint8_t*)0x1000035a = 0x00
	*(uint8_t*)0x1000035b = 0x00
	*(uint8_t*)0x1000035c = 0x00
	*(uint8_t*)0x1000035d = 0x01
	*(uint8_t*)0x1000035e = 0x00
	*(uint8_t*)0x1000035f = 0x00
	*(uint8_t*)0x10000360 = 0x00
	*(uint8_t*)0x10000361 = 0x00
	*(uint8_t*)0x10000362 = 0x00
	*(uint8_t*)0x10000363 = 0x00
	*(uint8_t*)0x10000364 = 0x00
	*(uint8_t*)0x10000365 = 0x00
	*(uint8_t*)0x10000366 = 0x00
	*(uint8_t*)0x10000367 = 0x00
	*(uint8_t*)0x10000368 = 0x00
	*(uint8_t*)0x10000369 = 0x00
	*(uint8_t*)0x1000036a = 0x00
	*(uint8_t*)0x1000036b = 0x00
	*(uint8_t*)0x1000036c = 0x00
	*(uint8_t*)0x1000036d = 0x00
	*(uint8_t*)0x1000036e = 0x00
	*(uint8_t*)0x1000036f = 0x00
	*(uint8_t*)0x10000370 = 0x00
	*(uint8_t*)0x10000371 = 0x00
	*(uint8_t*)0x10000372 = 0x00
	*(uint8_t*)0x10000373 = 0x00
	*(uint8_t*)0x10000374 = 0x40
	*(uint8_t*)0x10000375 = 0x11
	*(uint8_t*)0x10000376 = 0x00
	*(uint8_t*)0x10000377 = 0x10
	*(uint8_t*)0x10000378 = 0x00
	*(uint8_t*)0x10000379 = 0x00
	*(uint8_t*)0x1000037a = 0x00
	*(uint8_t*)0x1000037b = 0x00
	*(uint8_t*)0x1000037c = 0x00
	*(uint8_t*)0x1000037d = 0x00
	*(uint8_t*)0x1000037e = 0x00
	*(uint8_t*)0x1000037f = 0x00
	*(uint8_t*)0x10000380 = 0x00
	*(uint8_t*)0x10000381 = 0x00
	*(uint8_t*)0x10000382 = 0x00
	*(uint8_t*)0x10000383 = 0x00
	*(uint8_t*)0x10000384 = 0x00
	*(uint8_t*)0x10000385 = 0x00
	*(uint8_t*)0x10000386 = 0x00
	*(uint8_t*)0x10000387 = 0x00
	*(uint8_t*)0x10000388 = 0x00
	*(uint8_t*)0x10000389 = 0x00
	*(uint8_t*)0x1000038a = 0x00
	*(uint8_t*)0x1000038b = 0x00
	*(uint8_t*)0x1000038c = 0x00
	*(uint8_t*)0x1000038d = 0x00
	*(uint8_t*)0x1000038e = 0x00
	*(uint8_t*)0x1000038f = 0x00
	*(uint8_t*)0x10000390 = 0x00
	*(uint8_t*)0x10000391 = 0x00
	*(uint8_t*)0x10000392 = 0x00
	*(uint8_t*)0x10000393 = 0x00
	*(uint8_t*)0x10000394 = 0x00
	*(uint8_t*)0x10000395 = 0x00
	*(uint8_t*)0x10000396 = 0x00
	*(uint8_t*)0x10000397 = 0x00
	*(uint8_t*)0x10000398 = 0x00
	*(uint8_t*)0x10000399 = 0x00
	*(uint8_t*)0x1000039a = 0x00
	*(uint8_t*)0x1000039b = 0x00
	*(uint8_t*)0x1000039c = 0x00
	*(uint8_t*)0x1000039d = 0x00
	*(uint8_t*)0x1000039e = 0x00
	*(uint8_t*)0x1000039f = 0x00
	*(uint8_t*)0x100003a0 = 0x00
	*(uint8_t*)0x100003a1 = 0x00
	*(uint8_t*)0x100003a2 = 0x00
	*(uint8_t*)0x100003a3 = 0x00
	*(uint8_t*)0x100003a4 = 0x00
	*(uint8_t*)0x100003a5 = 0x00
	*(uint8_t*)0x100003a6 = 0x00
	*(uint8_t*)0x100003a7 = 0x00
	*(uint8_t*)0x100003a8 = 0x00
	*(uint8_t*)0x100003a9 = 0x00
	*(uint8_t*)0x100003aa = 0x00
	*(uint8_t*)0x100003ab = 0x00
	*(uint8_t*)0x100003ac = 0x00
	*(uint8_t*)0x100003ad = 0x00
	*(uint8_t*)0x100003ae = 0x00
	*(uint8_t*)0x100003af = 0x00
	*(uint8_t*)0x100003b0 = 0x00
	*(uint8_t*)0x100003b1 = 0x00
	*(uint8_t*)0x100003b2 = 0x00
	*(uint8_t*)0x100003b3 = 0x00
	*(uint8_t*)0x100003b4 = 0x00
	*(uint8_t*)0x100003b5 = 0x00
	*(uint8_t*)0x100003b6 = 0x00
	*(uint8_t*)0x100003b7 = 0x00
	*(uint8_t*)0x100003b8 = 0xad
	*(uint8_t*)0x100003b9 = 0xbe
	*(uint8_t*)0x100003ba = 0x00
	*(uint8_t*)0x100003bb = 0x00
	*(uint8_t*)0x100003bc = 0x0e
	*(uint8_t*)0x100003bd = 0x7b
	*(uint8_t*)0x100003be = 0x22
	*(uint8_t*)0x100003bf = 0x00
	*(uint8_t*)0x100003c0 = 0x62
	*(uint8_t*)0x100003c1 = 0x00
	*(uint8_t*)0x100003c2 = 0xde
	*(uint8_t*)0x100003c3 = 0x00
	*(uint8_t*)0x100003c4 = 0x2a
	*(uint8_t*)0x100003c5 = 0x01
	*(uint8_t*)0x100003c6 = 0x58
	*(uint8_t*)0x100003c7 = 0x01
	*(uint8_t*)0x100003c8 = 0x7a
	*(uint8_t*)0x100003c9 = 0x01
	*(uint8_t*)0x100003ca = 0x96
	*(uint8_t*)0x100003cb = 0x01
	*(uint8_t*)0x100003cc = 0xdc
	*(uint8_t*)0x100003cd = 0x01
	*(uint8_t*)0x100003ce = 0xa0
	*(uint8_t*)0x100003cf = 0x02
	*(uint8_t*)0x100003d0 = 0xce
	*(uint8_t*)0x100003d1 = 0x02
	*(uint8_t*)0x100003d2 = 0xf6
	*(uint8_t*)0x100003d3 = 0x02
	*(uint8_t*)0x100003d4 = 0x18
	*(uint8_t*)0x100003d5 = 0x03
	*(uint8_t*)0x100003d6 = 0x4c
	*(uint8_t*)0x100003d7 = 0x03
	*(uint8_t*)0x100003d8 = 0x6e
	*(uint8_t*)0x100003d9 = 0x03
	*(uint8_t*)0x100003da = 0x05
	*(uint8_t*)0x100003db = 0x00
	*(uint8_t*)0x100003dc = 0x05
	*(uint8_t*)0x100003dd = 0x00
	*(uint8_t*)0x100003de = 0x5e
	*(uint8_t*)0x100003df = 0x00
	*(uint8_t*)0x100003e0 = 0x17
	*(uint8_t*)0x100003e1 = 0x04
	*(uint8_t*)0x100003e2 = 0x88
	*(uint8_t*)0x100003e3 = 0x00
	*(uint8_t*)0x100003e4 = 0x7f
	*(uint8_t*)0x100003e5 = 0x00
	*(uint8_t*)0x100003e6 = 0x97
	*(uint8_t*)0x100003e7 = 0x04
	*(uint8_t*)0x100003e8 = 0x88
	*(uint8_t*)0x100003e9 = 0x00
	*(uint8_t*)0x100003ea = 0x00
	*(uint8_t*)0x100003eb = 0x00
	*(uint8_t*)0x100003ec = 0x00
	*(uint8_t*)0x100003ed = 0x00
	*(uint8_t*)0x100003ee = 0x01
	*(uint8_t*)0x100003ef = 0x00
	*(uint8_t*)0x100003f0 = 0x33
	*(uint8_t*)0x100003f1 = 0x00
	*(uint8_t*)0x100003f2 = 0x27
	*(uint8_t*)0x100003f3 = 0x05
	*(uint8_t*)0x100003f4 = 0x88
	*(uint8_t*)0x100003f5 = 0x00
	*(uint8_t*)0x100003f6 = 0x4f
	*(uint8_t*)0x100003f7 = 0x00
	*(uint8_t*)0x100003f8 = 0x75
	*(uint8_t*)0x100003f9 = 0x05
	*(uint8_t*)0x100003fa = 0xc7
	*(uint8_t*)0x100003fb = 0x00
	*(uint8_t*)0x100003fc = 0x54
	*(uint8_t*)0x100003fd = 0x00
	*(uint8_t*)0x100003fe = 0x75
	*(uint8_t*)0x100003ff = 0x05
	*(uint8_t*)0x10000400 = 0x88
	*(uint8_t*)0x10000401 = 0x00
	*(uint8_t*)0x10000402 = 0x7b
	*(uint8_t*)0x10000403 = 0x00
	*(uint8_t*)0x10000404 = 0xe0
	*(uint8_t*)0x10000405 = 0x06
	*(uint8_t*)0x10000406 = 0x88
	*(uint8_t*)0x10000407 = 0x00
	*(uint8_t*)0x10000408 = 0x00
	*(uint8_t*)0x10000409 = 0x00
	*(uint8_t*)0x1000040a = 0x00
	*(uint8_t*)0x1000040b = 0x00
	*(uint8_t*)0x1000040c = 0x01
	*(uint8_t*)0x1000040d = 0x00
	*(uint8_t*)0x1000040e = 0x33
	*(uint8_t*)0x1000040f = 0x00
	*(uint8_t*)0x10000410 = 0x20
	*(uint8_t*)0x10000411 = 0x06
	*(uint8_t*)0x10000412 = 0x88
	*(uint8_t*)0x10000413 = 0x00
	*(uint8_t*)0x10000414 = 0x4f
	*(uint8_t*)0x10000415 = 0x00
	*(uint8_t*)0x10000416 = 0xe0
	*(uint8_t*)0x10000417 = 0x06
	*(uint8_t*)0x10000418 = 0xc7
	*(uint8_t*)0x10000419 = 0x00
	*(uint8_t*)0x1000041a = 0x0a
	*(uint8_t*)0x1000041b = 0x00
	*(uint8_t*)0x1000041c = 0x0a
	*(uint8_t*)0x1000041d = 0x00
	*(uint8_t*)0x1000041e = 0x71
	*(uint8_t*)0x1000041f = 0x00
	*(uint8_t*)0x10000420 = 0x75
	*(uint8_t*)0x10000421 = 0x05
	*(uint8_t*)0x10000422 = 0x22
	*(uint8_t*)0x10000423 = 0x00
	*(uint8_t*)0x10000424 = 0x5c
	*(uint8_t*)0x10000425 = 0x00
	*(uint8_t*)0x10000426 = 0x27
	*(uint8_t*)0x10000427 = 0x05
	*(uint8_t*)0x10000428 = 0x22
	*(uint8_t*)0x10000429 = 0x00
	*(uint8_t*)0x1000042a = 0x51
	*(uint8_t*)0x1000042b = 0x00
	*(uint8_t*)0x1000042c = 0xdd
	*(uint8_t*)0x1000042d = 0x04
	*(uint8_t*)0x1000042e = 0x22
	*(uint8_t*)0x1000042f = 0x00
	*(uint8_t*)0x10000430 = 0x43
	*(uint8_t*)0x10000431 = 0x00
	*(uint8_t*)0x10000432 = 0x17
	*(uint8_t*)0x10000433 = 0x04
	*(uint8_t*)0x10000434 = 0x22
	*(uint8_t*)0x10000435 = 0x00
	*(uint8_t*)0x10000436 = 0x3b
	*(uint8_t*)0x10000437 = 0x00
	*(uint8_t*)0x10000438 = 0xa4
	*(uint8_t*)0x10000439 = 0x03
	*(uint8_t*)0x1000043a = 0x22
	*(uint8_t*)0x1000043b = 0x00
	*(uint8_t*)0x1000043c = 0x33
	*(uint8_t*)0x1000043d = 0x00
	*(uint8_t*)0x1000043e = 0x17
	*(uint8_t*)0x1000043f = 0x04
	*(uint8_t*)0x10000440 = 0x22
	*(uint8_t*)0x10000441 = 0x00
	*(uint8_t*)0x10000442 = 0x00
	*(uint8_t*)0x10000443 = 0x00
	*(uint8_t*)0x10000444 = 0x00
	*(uint8_t*)0x10000445 = 0x00
	*(uint8_t*)0x10000446 = 0x01
	*(uint8_t*)0x10000447 = 0x00
	*(uint8_t*)0x10000448 = 0x2c
	*(uint8_t*)0x10000449 = 0x00
	*(uint8_t*)0x1000044a = 0xdd
	*(uint8_t*)0x1000044b = 0x04
	*(uint8_t*)0x1000044c = 0x22
	*(uint8_t*)0x1000044d = 0x00
	*(uint8_t*)0x1000044e = 0x26
	*(uint8_t*)0x1000044f = 0x00
	*(uint8_t*)0x10000450 = 0x27
	*(uint8_t*)0x10000451 = 0x05
	*(uint8_t*)0x10000452 = 0x22
	*(uint8_t*)0x10000453 = 0x00
	*(uint8_t*)0x10000454 = 0x21
	*(uint8_t*)0x10000455 = 0x00
	*(uint8_t*)0x10000456 = 0x75
	*(uint8_t*)0x10000457 = 0x05
	*(uint8_t*)0x10000458 = 0x22
	*(uint8_t*)0x10000459 = 0x00
	*(uint8_t*)0x1000045a = 0x71
	*(uint8_t*)0x1000045b = 0x00
	*(uint8_t*)0x1000045c = 0xe0
	*(uint8_t*)0x1000045d = 0x06
	*(uint8_t*)0x1000045e = 0x22
	*(uint8_t*)0x1000045f = 0x00
	*(uint8_t*)0x10000460 = 0x5c
	*(uint8_t*)0x10000461 = 0x00
	*(uint8_t*)0x10000462 = 0x20
	*(uint8_t*)0x10000463 = 0x06
	*(uint8_t*)0x10000464 = 0x22
	*(uint8_t*)0x10000465 = 0x00
	*(uint8_t*)0x10000466 = 0x51
	*(uint8_t*)0x10000467 = 0x00
	*(uint8_t*)0x10000468 = 0x75
	*(uint8_t*)0x10000469 = 0x05
	*(uint8_t*)0x1000046a = 0x22
	*(uint8_t*)0x1000046b = 0x00
	*(uint8_t*)0x1000046c = 0x43
	*(uint8_t*)0x1000046d = 0x00
	*(uint8_t*)0x1000046e = 0x27
	*(uint8_t*)0x1000046f = 0x05
	*(uint8_t*)0x10000470 = 0x22
	*(uint8_t*)0x10000471 = 0x00
	*(uint8_t*)0x10000472 = 0x3b
	*(uint8_t*)0x10000473 = 0x00
	*(uint8_t*)0x10000474 = 0x97
	*(uint8_t*)0x10000475 = 0x04
	*(uint8_t*)0x10000476 = 0x22
	*(uint8_t*)0x10000477 = 0x00
	*(uint8_t*)0x10000478 = 0x33
	*(uint8_t*)0x10000479 = 0x00
	*(uint8_t*)0x1000047a = 0x27
	*(uint8_t*)0x1000047b = 0x05
	*(uint8_t*)0x1000047c = 0x22
	*(uint8_t*)0x1000047d = 0x00
	*(uint8_t*)0x1000047e = 0x00
	*(uint8_t*)0x1000047f = 0x00
	*(uint8_t*)0x10000480 = 0x00
	*(uint8_t*)0x10000481 = 0x00
	*(uint8_t*)0x10000482 = 0x01
	*(uint8_t*)0x10000483 = 0x00
	*(uint8_t*)0x10000484 = 0x2c
	*(uint8_t*)0x10000485 = 0x00
	*(uint8_t*)0x10000486 = 0x75
	*(uint8_t*)0x10000487 = 0x05
	*(uint8_t*)0x10000488 = 0x22
	*(uint8_t*)0x10000489 = 0x00
	*(uint8_t*)0x1000048a = 0x26
	*(uint8_t*)0x1000048b = 0x00
	*(uint8_t*)0x1000048c = 0x20
	*(uint8_t*)0x1000048d = 0x06
	*(uint8_t*)0x1000048e = 0x22
	*(uint8_t*)0x1000048f = 0x00
	*(uint8_t*)0x10000490 = 0x21
	*(uint8_t*)0x10000491 = 0x00
	*(uint8_t*)0x10000492 = 0xe0
	*(uint8_t*)0x10000493 = 0x06
	*(uint8_t*)0x10000494 = 0x22
	*(uint8_t*)0x10000495 = 0x00
	*(uint8_t*)0x10000496 = 0x0a
	*(uint8_t*)0x10000497 = 0x00
	*(uint8_t*)0x10000498 = 0x02
	*(uint8_t*)0x10000499 = 0x00
	*(uint8_t*)0x1000049a = 0x60
	*(uint8_t*)0x1000049b = 0x00
	*(uint8_t*)0x1000049c = 0xc0
	*(uint8_t*)0x1000049d = 0x0d
	*(uint8_t*)0x1000049e = 0x2f
	*(uint8_t*)0x1000049f = 0x00
	*(uint8_t*)0x100004a0 = 0x00
	*(uint8_t*)0x100004a1 = 0x00
	*(uint8_t*)0x100004a2 = 0x00
	*(uint8_t*)0x100004a3 = 0x00
	*(uint8_t*)0x100004a4 = 0x16
	*(uint8_t*)0x100004a5 = 0x00
	*(uint8_t*)0x100004a6 = 0x7f
	*(uint8_t*)0x100004a7 = 0x00
	*(uint8_t*)0x100004a8 = 0x17
	*(uint8_t*)0x100004a9 = 0x04
	*(uint8_t*)0x100004aa = 0x41
	*(uint8_t*)0x100004ab = 0x00
	*(uint8_t*)0x100004ac = 0x00
	*(uint8_t*)0x100004ad = 0x00
	*(uint8_t*)0x100004ae = 0x00
	*(uint8_t*)0x100004af = 0x00
	*(uint8_t*)0x100004b0 = 0x03
	*(uint8_t*)0x100004b1 = 0x00
	*(uint8_t*)0x100004b2 = 0x7d
	*(uint8_t*)0x100004b3 = 0x00
	*(uint8_t*)0x100004b4 = 0xc0
	*(uint8_t*)0x100004b5 = 0x0d
	*(uint8_t*)0x100004b6 = 0x2c
	*(uint8_t*)0x100004b7 = 0x00
	*(uint8_t*)0x100004b8 = 0x00
	*(uint8_t*)0x100004b9 = 0x00
	*(uint8_t*)0x100004ba = 0x00
	*(uint8_t*)0x100004bb = 0x00
	*(uint8_t*)0x100004bc = 0x01
	*(uint8_t*)0x100004bd = 0x00
	*(uint8_t*)0x100004be = 0x00
	*(uint8_t*)0x100004bf = 0x00
	*(uint8_t*)0x100004c0 = 0x00
	*(uint8_t*)0x100004c1 = 0x00
	*(uint8_t*)0x100004c2 = 0x18
	*(uint8_t*)0x100004c3 = 0x00
	*(uint8_t*)0x100004c4 = 0x7b
	*(uint8_t*)0x100004c5 = 0x00
	*(uint8_t*)0x100004c6 = 0x17
	*(uint8_t*)0x100004c7 = 0x04
	*(uint8_t*)0x100004c8 = 0x48
	*(uint8_t*)0x100004c9 = 0x00
	*(uint8_t*)0x100004ca = 0x00
	*(uint8_t*)0x100004cb = 0x00
	*(uint8_t*)0x100004cc = 0x00
	*(uint8_t*)0x100004cd = 0x00
	*(uint8_t*)0x100004ce = 0x41
	*(uint8_t*)0x100004cf = 0x00
	*(uint8_t*)0x100004d0 = 0x75
	*(uint8_t*)0x100004d1 = 0x00
	*(uint8_t*)0x100004d2 = 0x17
	*(uint8_t*)0x100004d3 = 0x04
	*(uint8_t*)0x100004d4 = 0x3e
	*(uint8_t*)0x100004d5 = 0x00
	*(uint8_t*)0x100004d6 = 0x00
	*(uint8_t*)0x100004d7 = 0x00
	*(uint8_t*)0x100004d8 = 0x00
	*(uint8_t*)0x100004d9 = 0x00
	*(uint8_t*)0x100004da = 0x11
	*(uint8_t*)0x100004db = 0x01
	*(uint8_t*)0x100004dc = 0x7f
	*(uint8_t*)0x100004dd = 0x00
	*(uint8_t*)0x100004de = 0xc0
	*(uint8_t*)0x100004df = 0x0d
	*(uint8_t*)0x100004e0 = 0x32
	*(uint8_t*)0x100004e1 = 0x00
	*(uint8_t*)0x100004e2 = 0x05
	*(uint8_t*)0x100004e3 = 0x00
	*(uint8_t*)0x100004e4 = 0x02
	*(uint8_t*)0x100004e5 = 0x00
	*(uint8_t*)0x100004e6 = 0x5c
	*(uint8_t*)0x100004e7 = 0x00
	*(uint8_t*)0x100004e8 = 0xba
	*(uint8_t*)0x100004e9 = 0x02
	*(uint8_t*)0x100004ea = 0x88
	*(uint8_t*)0x100004eb = 0x00
	*(uint8_t*)0x100004ec = 0x00
	*(uint8_t*)0x100004ed = 0x00
	*(uint8_t*)0x100004ee = 0x00
	*(uint8_t*)0x100004ef = 0x00
	*(uint8_t*)0x100004f0 = 0x88
	*(uint8_t*)0x100004f1 = 0x00
	*(uint8_t*)0x100004f2 = 0x00
	*(uint8_t*)0x100004f3 = 0x00
	*(uint8_t*)0x100004f4 = 0x00
	*(uint8_t*)0x100004f5 = 0x00
	*(uint8_t*)0x100004f6 = 0x01
	*(uint8_t*)0x100004f7 = 0x00
	*(uint8_t*)0x100004f8 = 0x66
	*(uint8_t*)0x100004f9 = 0x00
	*(uint8_t*)0x100004fa = 0xba
	*(uint8_t*)0x100004fb = 0x02
	*(uint8_t*)0x100004fc = 0x88
	*(uint8_t*)0x100004fd = 0x00
	*(uint8_t*)0x100004fe = 0x76
	*(uint8_t*)0x100004ff = 0x00
	*(uint8_t*)0x10000500 = 0x17
	*(uint8_t*)0x10000501 = 0x04
	*(uint8_t*)0x10000502 = 0x18
	*(uint8_t*)0x10000503 = 0x01
	*(uint8_t*)0x10000504 = 0x00
	*(uint8_t*)0x10000505 = 0x00
	*(uint8_t*)0x10000506 = 0x00
	*(uint8_t*)0x10000507 = 0x00
	*(uint8_t*)0x10000508 = 0x99
	*(uint8_t*)0x10000509 = 0x01
	*(uint8_t*)0x1000050a = 0x38
	*(uint8_t*)0x1000050b = 0x00
	*(uint8_t*)0x1000050c = 0x75
	*(uint8_t*)0x1000050d = 0x05
	*(uint8_t*)0x1000050e = 0x19
	*(uint8_t*)0x1000050f = 0x01
	*(uint8_t*)0x10000510 = 0x02
	*(uint8_t*)0x10000511 = 0x00
	*(uint8_t*)0x10000512 = 0x03
	*(uint8_t*)0x10000513 = 0x00
	*(uint8_t*)0x10000514 = 0x40
	*(uint8_t*)0x10000515 = 0x00
	*(uint8_t*)0x10000516 = 0xba
	*(uint8_t*)0x10000517 = 0x02
	*(uint8_t*)0x10000518 = 0x99
	*(uint8_t*)0x10000519 = 0x01
	*(uint8_t*)0x1000051a = 0x56
	*(uint8_t*)0x1000051b = 0x00
	*(uint8_t*)0x1000051c = 0x17
	*(uint8_t*)0x1000051d = 0x04
	*(uint8_t*)0x1000051e = 0x44
	*(uint8_t*)0x1000051f = 0x02
	*(uint8_t*)0x10000520 = 0x00
	*(uint8_t*)0x10000521 = 0x00
	*(uint8_t*)0x10000522 = 0x00
	*(uint8_t*)0x10000523 = 0x00
	*(uint8_t*)0x10000524 = 0x11
	*(uint8_t*)0x10000525 = 0x01
	*(uint8_t*)0x10000526 = 0x46
	*(uint8_t*)0x10000527 = 0x00
	*(uint8_t*)0x10000528 = 0xa4
	*(uint8_t*)0x10000529 = 0x03
	*(uint8_t*)0x1000052a = 0x11
	*(uint8_t*)0x1000052b = 0x01
	*(uint8_t*)0x1000052c = 0x8e
	*(uint8_t*)0x1000052d = 0x00
	*(uint8_t*)0x1000052e = 0x75
	*(uint8_t*)0x1000052f = 0x05
	*(uint8_t*)0x10000530 = 0xbb
	*(uint8_t*)0x10000531 = 0x01
	*(uint8_t*)0x10000532 = 0x02
	*(uint8_t*)0x10000533 = 0x00
	*(uint8_t*)0x10000534 = 0x02
	*(uint8_t*)0x10000535 = 0x00
	*(uint8_t*)0x10000536 = 0x40
	*(uint8_t*)0x10000537 = 0x00
	*(uint8_t*)0x10000538 = 0x75
	*(uint8_t*)0x10000539 = 0x05
	*(uint8_t*)0x1000053a = 0x88
	*(uint8_t*)0x1000053b = 0x00
	*(uint8_t*)0x1000053c = 0xc8
	*(uint8_t*)0x1000053d = 0x00
	*(uint8_t*)0x1000053e = 0x2d
	*(uint8_t*)0x1000053f = 0x08
	*(uint8_t*)0x10000540 = 0x62
	*(uint8_t*)0x10000541 = 0x00
	*(uint8_t*)0x10000542 = 0x00
	*(uint8_t*)0x10000543 = 0x00
	*(uint8_t*)0x10000544 = 0x00
	*(uint8_t*)0x10000545 = 0x00
	*(uint8_t*)0x10000546 = 0x44
	*(uint8_t*)0x10000547 = 0x00
	*(uint8_t*)0x10000548 = 0x7a
	*(uint8_t*)0x10000549 = 0x00
	*(uint8_t*)0x1000054a = 0xe0
	*(uint8_t*)0x1000054b = 0x06
	*(uint8_t*)0x1000054c = 0xa5
	*(uint8_t*)0x1000054d = 0x00
	*(uint8_t*)0x1000054e = 0x06
	*(uint8_t*)0x1000054f = 0x00
	*(uint8_t*)0x10000550 = 0x05
	*(uint8_t*)0x10000551 = 0x00
	*(uint8_t*)0x10000552 = 0x5e
	*(uint8_t*)0x10000553 = 0x00
	*(uint8_t*)0x10000554 = 0x17
	*(uint8_t*)0x10000555 = 0x04
	*(uint8_t*)0x10000556 = 0xaa
	*(uint8_t*)0x10000557 = 0x00
	*(uint8_t*)0x10000558 = 0x00
	*(uint8_t*)0x10000559 = 0x00
	*(uint8_t*)0x1000055a = 0x00
	*(uint8_t*)0x1000055b = 0x00
	*(uint8_t*)0x1000055c = 0x66
	*(uint8_t*)0x1000055d = 0x00
	*(uint8_t*)0x1000055e = 0x00
	*(uint8_t*)0x1000055f = 0x00
	*(uint8_t*)0x10000560 = 0x00
	*(uint8_t*)0x10000561 = 0x00
	*(uint8_t*)0x10000562 = 0x01
	*(uint8_t*)0x10000563 = 0x00
	*(uint8_t*)0x10000564 = 0x4b
	*(uint8_t*)0x10000565 = 0x00
	*(uint8_t*)0x10000566 = 0x70
	*(uint8_t*)0x10000567 = 0x03
	*(uint8_t*)0x10000568 = 0x66
	*(uint8_t*)0x10000569 = 0x00
	*(uint8_t*)0x1000056a = 0x00
	*(uint8_t*)0x1000056b = 0x00
	*(uint8_t*)0x1000056c = 0x00
	*(uint8_t*)0x1000056d = 0x00
	*(uint8_t*)0x1000056e = 0x22
	*(uint8_t*)0x1000056f = 0x00
	*(uint8_t*)0x10000570 = 0x7f
	*(uint8_t*)0x10000571 = 0x00
	*(uint8_t*)0x10000572 = 0x75
	*(uint8_t*)0x10000573 = 0x05
	*(uint8_t*)0x10000574 = 0x66
	*(uint8_t*)0x10000575 = 0x00
	*(uint8_t*)0x10000576 = 0x00
	*(uint8_t*)0x10000577 = 0x00
	*(uint8_t*)0x10000578 = 0x00
	*(uint8_t*)0x10000579 = 0x00
	*(uint8_t*)0x1000057a = 0x88
	*(uint8_t*)0x1000057b = 0x00
	*(uint8_t*)0x1000057c = 0x2e
	*(uint8_t*)0x1000057d = 0x00
	*(uint8_t*)0x1000057e = 0xba
	*(uint8_t*)0x1000057f = 0x02
	*(uint8_t*)0x10000580 = 0xaa
	*(uint8_t*)0x10000581 = 0x00
	*(uint8_t*)0x10000582 = 0x00
	*(uint8_t*)0x10000583 = 0x00
	*(uint8_t*)0x10000584 = 0x00
	*(uint8_t*)0x10000585 = 0x00
	*(uint8_t*)0x10000586 = 0x01
	*(uint8_t*)0x10000587 = 0x00
	*(uint8_t*)0x10000588 = 0x00
	*(uint8_t*)0x10000589 = 0x00
	*(uint8_t*)0x1000058a = 0x00
	*(uint8_t*)0x1000058b = 0x00
	*(uint8_t*)0x1000058c = 0x22
	*(uint8_t*)0x1000058d = 0x00
	*(uint8_t*)0x1000058e = 0x5e
	*(uint8_t*)0x1000058f = 0x00
	*(uint8_t*)0x10000590 = 0x17
	*(uint8_t*)0x10000591 = 0x04
	*(uint8_t*)0x10000592 = 0x66
	*(uint8_t*)0x10000593 = 0x00
	*(uint8_t*)0x10000594 = 0x04
	*(uint8_t*)0x10000595 = 0x00
	*(uint8_t*)0x10000596 = 0x1c
	*(uint8_t*)0x10000597 = 0x00
	*(uint8_t*)0x10000598 = 0x0e
	*(uint8_t*)0x10000599 = 0x00
	*(uint8_t*)0x1000059a = 0x5d
	*(uint8_t*)0x1000059b = 0x01
	*(uint8_t*)0x1000059c = 0x32
	*(uint8_t*)0x1000059d = 0x03
	*(uint8_t*)0x1000059e = 0x2a
	*(uint8_t*)0x1000059f = 0x00
	*(uint8_t*)0x100005a0 = 0x88
	*(uint8_t*)0x100005a1 = 0x01
	*(uint8_t*)0x100005a2 = 0x10
	*(uint8_t*)0x100005a3 = 0x03
	*(uint8_t*)0x100005a4 = 0x00
	*(uint8_t*)0x100005a5 = 0x00
	*(uint8_t*)0x100005a6 = 0x00
	*(uint8_t*)0x100005a7 = 0x00
	*(uint8_t*)0x100005a8 = 0x22
	*(uint8_t*)0x100005a9 = 0x00
	*(uint8_t*)0x100005aa = 0x32
	*(uint8_t*)0x100005ab = 0x00
	*(uint8_t*)0x100005ac = 0x0b
	*(uint8_t*)0x100005ad = 0x02
	*(uint8_t*)0x100005ae = 0x32
	*(uint8_t*)0x100005af = 0x03
	*(uint8_t*)0x100005b0 = 0x30
	*(uint8_t*)0x100005b1 = 0x00
	*(uint8_t*)0x100005b2 = 0xd2
	*(uint8_t*)0x100005b3 = 0x01
	*(uint8_t*)0x100005b4 = 0x5b
	*(uint8_t*)0x100005b5 = 0x00
	*(uint8_t*)0x100005b6 = 0x00
	*(uint8_t*)0x100005b7 = 0x00
	*(uint8_t*)0x100005b8 = 0x00
	*(uint8_t*)0x100005b9 = 0x00
	*(uint8_t*)0x100005ba = 0x0b
	*(uint8_t*)0x100005bb = 0x00
	*(uint8_t*)0x100005bc = 0x36
	*(uint8_t*)0x100005bd = 0x00
	*(uint8_t*)0x100005be = 0xb8
	*(uint8_t*)0x100005bf = 0x01
	*(uint8_t*)0x100005c0 = 0x84
	*(uint8_t*)0x100005c1 = 0x00
	*(uint8_t*)0x100005c2 = 0x00
	*(uint8_t*)0x100005c3 = 0x00
	*(uint8_t*)0x100005c4 = 0x00
	*(uint8_t*)0x100005c5 = 0x00
	*(uint8_t*)0x100005c6 = 0x05
	*(uint8_t*)0x100005c7 = 0x00
	*(uint8_t*)0x100005c8 = 0x3e
	*(uint8_t*)0x100005c9 = 0x00
	*(uint8_t*)0x100005ca = 0xd2
	*(uint8_t*)0x100005cb = 0x01
	*(uint8_t*)0x100005cc = 0x57
	*(uint8_t*)0x100005cd = 0x00
	*(uint8_t*)0x100005ce = 0x00
	*(uint8_t*)0x100005cf = 0x00
	*(uint8_t*)0x100005d0 = 0x00
	*(uint8_t*)0x100005d1 = 0x00
	*(uint8_t*)0x100005d2 = 0x0f
	*(uint8_t*)0x100005d3 = 0x00
	*(uint8_t*)0x100005d4 = 0x38
	*(uint8_t*)0x100005d5 = 0x00
	*(uint8_t*)0x100005d6 = 0xb8
	*(uint8_t*)0x100005d7 = 0x01
	*(uint8_t*)0x100005d8 = 0x83
	*(uint8_t*)0x100005d9 = 0x00
	*(uint8_t*)0x100005da = 0x00
	*(uint8_t*)0x100005db = 0x00
	*(uint8_t*)0x100005dc = 0x00
	*(uint8_t*)0x100005dd = 0x00
	*(uint8_t*)0x100005de = 0x06
	*(uint8_t*)0x100005df = 0x00
	*(uint8_t*)0x100005e0 = 0x46
	*(uint8_t*)0x100005e1 = 0x00
	*(uint8_t*)0x100005e2 = 0xd2
	*(uint8_t*)0x100005e3 = 0x01
	*(uint8_t*)0x100005e4 = 0x44
	*(uint8_t*)0x100005e5 = 0x00
	*(uint8_t*)0x100005e6 = 0x00
	*(uint8_t*)0x100005e7 = 0x00
	*(uint8_t*)0x100005e8 = 0x00
	*(uint8_t*)0x100005e9 = 0x00
	*(uint8_t*)0x100005ea = 0x11
	*(uint8_t*)0x100005eb = 0x01
	*(uint8_t*)0x100005ec = 0x58
	*(uint8_t*)0x100005ed = 0x00
	*(uint8_t*)0x100005ee = 0x4b
	*(uint8_t*)0x100005ef = 0x02
	*(uint8_t*)0x100005f0 = 0x66
	*(uint8_t*)0x100005f1 = 0x00
	*(uint8_t*)0x100005f2 = 0x4c
	*(uint8_t*)0x100005f3 = 0x00
	*(uint8_t*)0x100005f4 = 0x0b
	*(uint8_t*)0x100005f5 = 0x02
	*(uint8_t*)0x100005f6 = 0x84
	*(uint8_t*)0x100005f7 = 0x00
	*(uint8_t*)0x100005f8 = 0x00
	*(uint8_t*)0x100005f9 = 0x00
	*(uint8_t*)0x100005fa = 0x00
	*(uint8_t*)0x100005fb = 0x00
	*(uint8_t*)0x100005fc = 0x05
	*(uint8_t*)0x100005fd = 0x00
	*(uint8_t*)0x100005fe = 0x52
	*(uint8_t*)0x100005ff = 0x00
	*(uint8_t*)0x10000600 = 0x4b
	*(uint8_t*)0x10000601 = 0x02
	*(uint8_t*)0x10000602 = 0x66
	*(uint8_t*)0x10000603 = 0x00
	*(uint8_t*)0x10000604 = 0x48
	*(uint8_t*)0x10000605 = 0x00
	*(uint8_t*)0x10000606 = 0x0b
	*(uint8_t*)0x10000607 = 0x02
	*(uint8_t*)0x10000608 = 0x83
	*(uint8_t*)0x10000609 = 0x00
	*(uint8_t*)0x1000060a = 0x00
	*(uint8_t*)0x1000060b = 0x00
	*(uint8_t*)0x1000060c = 0x00
	*(uint8_t*)0x1000060d = 0x00
	*(uint8_t*)0x1000060e = 0x06
	*(uint8_t*)0x1000060f = 0x00
	*(uint8_t*)0x10000610 = 0x4e
	*(uint8_t*)0x10000611 = 0x00
	*(uint8_t*)0x10000612 = 0x4b
	*(uint8_t*)0x10000613 = 0x02
	*(uint8_t*)0x10000614 = 0x44
	*(uint8_t*)0x10000615 = 0x00
	*(uint8_t*)0x10000616 = 0x00
	*(uint8_t*)0x10000617 = 0x00
	*(uint8_t*)0x10000618 = 0x00
	*(uint8_t*)0x10000619 = 0x00
	*(uint8_t*)0x1000061a = 0x01
	*(uint8_t*)0x1000061b = 0x00
	*(uint8_t*)0x1000061c = 0x00
	*(uint8_t*)0x1000061d = 0x00
	*(uint8_t*)0x1000061e = 0x00
	*(uint8_t*)0x1000061f = 0x00
	*(uint8_t*)0x10000620 = 0x11
	*(uint8_t*)0x10000621 = 0x01
	*(uint8_t*)0x10000622 = 0x66
	*(uint8_t*)0x10000623 = 0x00
	*(uint8_t*)0x10000624 = 0xba
	*(uint8_t*)0x10000625 = 0x02
	*(uint8_t*)0x10000626 = 0x66
	*(uint8_t*)0x10000627 = 0x00
	*(uint8_t*)0x10000628 = 0x00
	*(uint8_t*)0x10000629 = 0x00
	*(uint8_t*)0x1000062a = 0x00
	*(uint8_t*)0x1000062b = 0x00
	*(uint8_t*)0x1000062c = 0x01
	*(uint8_t*)0x1000062d = 0x00
	*(uint8_t*)0x1000062e = 0x82
	*(uint8_t*)0x1000062f = 0x00
	*(uint8_t*)0x10000630 = 0x93
	*(uint8_t*)0x10000631 = 0x02
	*(uint8_t*)0x10000632 = 0x85
	*(uint8_t*)0x10000633 = 0x00
	*(uint8_t*)0x10000634 = 0x00
	*(uint8_t*)0x10000635 = 0x00
	*(uint8_t*)0x10000636 = 0x00
	*(uint8_t*)0x10000637 = 0x00
	*(uint8_t*)0x10000638 = 0x03
	*(uint8_t*)0x10000639 = 0x00
	*(uint8_t*)0x1000063a = 0x7c
	*(uint8_t*)0x1000063b = 0x00
	*(uint8_t*)0x1000063c = 0xba
	*(uint8_t*)0x1000063d = 0x02
	*(uint8_t*)0x1000063e = 0x66
	*(uint8_t*)0x1000063f = 0x00
	*(uint8_t*)0x10000640 = 0x90
	*(uint8_t*)0x10000641 = 0x00
	*(uint8_t*)0x10000642 = 0x93
	*(uint8_t*)0x10000643 = 0x02
	*(uint8_t*)0x10000644 = 0x80
	*(uint8_t*)0x10000645 = 0x00
	*(uint8_t*)0x10000646 = 0x00
	*(uint8_t*)0x10000647 = 0x00
	*(uint8_t*)0x10000648 = 0x00
	*(uint8_t*)0x10000649 = 0x00
	*(uint8_t*)0x1000064a = 0x01
	*(uint8_t*)0x1000064b = 0x00
	*(uint8_t*)0x1000064c = 0x00
	*(uint8_t*)0x1000064d = 0x00
	*(uint8_t*)0x1000064e = 0x00
	*(uint8_t*)0x1000064f = 0x00
	*(uint8_t*)0x10000650 = 0x08
	*(uint8_t*)0x10000651 = 0x00
	*(uint8_t*)0x10000652 = 0xaa
	*(uint8_t*)0x10000653 = 0x00
	*(uint8_t*)0x10000654 = 0xba
	*(uint8_t*)0x10000655 = 0x02
	*(uint8_t*)0x10000656 = 0x55
	*(uint8_t*)0x10000657 = 0x01
	*(uint8_t*)0x10000658 = 0x07
	*(uint8_t*)0x10000659 = 0x00
	*(uint8_t*)0x1000065a = 0x00
	*(uint8_t*)0x1000065b = 0x00
	*(uint8_t*)0x1000065c = 0x7f
	*(uint8_t*)0x1000065d = 0x00
	*(uint8_t*)0x1000065e = 0x75
	*(uint8_t*)0x1000065f = 0x05
	*(uint8_t*)0x10000660 = 0x32
	*(uint8_t*)0x10000661 = 0x00
	*(uint8_t*)0x10000662 = 0x00
	*(uint8_t*)0x10000663 = 0x00
	*(uint8_t*)0x10000664 = 0x00
	*(uint8_t*)0x10000665 = 0x00
	*(uint8_t*)0x10000666 = 0x2f
	*(uint8_t*)0x10000667 = 0x00
	*(uint8_t*)0x10000668 = 0x7f
	*(uint8_t*)0x10000669 = 0x00
	*(uint8_t*)0x1000066a = 0x97
	*(uint8_t*)0x1000066b = 0x04
	*(uint8_t*)0x1000066c = 0x3d
	*(uint8_t*)0x1000066d = 0x00
	*(uint8_t*)0x1000066e = 0x00
	*(uint8_t*)0x1000066f = 0x00
	*(uint8_t*)0x10000670 = 0x00
	*(uint8_t*)0x10000671 = 0x00
	*(uint8_t*)0x10000672 = 0x34
	*(uint8_t*)0x10000673 = 0x00
	*(uint8_t*)0x10000674 = 0x78
	*(uint8_t*)0x10000675 = 0x00
	*(uint8_t*)0x10000676 = 0x75
	*(uint8_t*)0x10000677 = 0x05
	*(uint8_t*)0x10000678 = 0x39
	*(uint8_t*)0x10000679 = 0x00
	*(uint8_t*)0x1000067a = 0x00
	*(uint8_t*)0x1000067b = 0x00
	*(uint8_t*)0x1000067c = 0x00
	*(uint8_t*)0x1000067d = 0x00
	*(uint8_t*)0x1000067e = 0x43
	*(uint8_t*)0x1000067f = 0x00
	*(uint8_t*)0x10000680 = 0x7f
	*(uint8_t*)0x10000681 = 0x00
	*(uint8_t*)0x10000682 = 0x97
	*(uint8_t*)0x10000683 = 0x04
	*(uint8_t*)0x10000684 = 0x46
	*(uint8_t*)0x10000685 = 0x00
	*(uint8_t*)0x10000686 = 0x03
	*(uint8_t*)0x10000687 = 0x00
	*(uint8_t*)0x10000688 = 0x03
	*(uint8_t*)0x10000689 = 0x00
	*(uint8_t*)0x1000068a = 0x46
	*(uint8_t*)0x1000068b = 0x00
	*(uint8_t*)0x1000068c = 0x93
	*(uint8_t*)0x1000068d = 0x02
	*(uint8_t*)0x1000068e = 0x8b
	*(uint8_t*)0x1000068f = 0x00
	*(uint8_t*)0x10000690 = 0x00
	*(uint8_t*)0x10000691 = 0x00
	*(uint8_t*)0x10000692 = 0x00
	*(uint8_t*)0x10000693 = 0x00
	*(uint8_t*)0x10000694 = 0x20
	*(uint8_t*)0x10000695 = 0x00
	*(uint8_t*)0x10000696 = 0x5a
	*(uint8_t*)0x10000697 = 0x00
	*(uint8_t*)0x10000698 = 0x93
	*(uint8_t*)0x10000699 = 0x02
	*(uint8_t*)0x1000069a = 0xaa
	*(uint8_t*)0x1000069b = 0x00
	*(uint8_t*)0x1000069c = 0x52
	*(uint8_t*)0x1000069d = 0x00
	*(uint8_t*)0x1000069e = 0xba
	*(uint8_t*)0x1000069f = 0x02
	*(uint8_t*)0x100006a0 = 0x8b
	*(uint8_t*)0x100006a1 = 0x00
	*(uint8_t*)0x100006a2 = 0x00
	*(uint8_t*)0x100006a3 = 0x00
	*(uint8_t*)0x100006a4 = 0x00
	*(uint8_t*)0x100006a5 = 0x00
	*(uint8_t*)0x100006a6 = 0x20
	*(uint8_t*)0x100006a7 = 0x00
	*(uint8_t*)0x100006a8 = 0x46
	*(uint8_t*)0x100006a9 = 0x00
	*(uint8_t*)0x100006aa = 0xba
	*(uint8_t*)0x100006ab = 0x02
	*(uint8_t*)0x100006ac = 0x9e
	*(uint8_t*)0x100006ad = 0x00
	*(uint8_t*)0x100006ae = 0x02
	*(uint8_t*)0x100006af = 0x00
	*(uint8_t*)0x100006b0 = 0x03
	*(uint8_t*)0x100006b1 = 0x00
	*(uint8_t*)0x100006b2 = 0x47
	*(uint8_t*)0x100006b3 = 0x00
	*(uint8_t*)0x100006b4 = 0x75
	*(uint8_t*)0x100006b5 = 0x05
	*(uint8_t*)0x100006b6 = 0x11
	*(uint8_t*)0x100006b7 = 0x01
	*(uint8_t*)0x100006b8 = 0x32
	*(uint8_t*)0x100006b9 = 0x00
	*(uint8_t*)0x100006ba = 0x70
	*(uint8_t*)0x100006bb = 0x03
	*(uint8_t*)0x100006bc = 0x11
	*(uint8_t*)0x100006bd = 0x01
	*(uint8_t*)0x100006be = 0x26
	*(uint8_t*)0x100006bf = 0x00
	*(uint8_t*)0x100006c0 = 0xe0
	*(uint8_t*)0x100006c1 = 0x06
	*(uint8_t*)0x100006c2 = 0x88
	*(uint8_t*)0x100006c3 = 0x00
	*(uint8_t*)0x100006c4 = 0x22
	*(uint8_t*)0x100006c5 = 0x00
	*(uint8_t*)0x100006c6 = 0x17
	*(uint8_t*)0x100006c7 = 0x04
	*(uint8_t*)0x100006c8 = 0x11
	*(uint8_t*)0x100006c9 = 0x01
	*(uint8_t*)0x100006ca = 0x33
	*(uint8_t*)0x100006cb = 0x00
	*(uint8_t*)0x100006cc = 0xba
	*(uint8_t*)0x100006cd = 0x02
	*(uint8_t*)0x100006ce = 0x88
	*(uint8_t*)0x100006cf = 0x00
	*(uint8_t*)0x100006d0 = 0x05
	*(uint8_t*)0x100006d1 = 0x00
	*(uint8_t*)0x100006d2 = 0x03
	*(uint8_t*)0x100006d3 = 0x00
	*(uint8_t*)0x100006d4 = 0x5e
	*(uint8_t*)0x100006d5 = 0x00
	*(uint8_t*)0x100006d6 = 0x17
	*(uint8_t*)0x100006d7 = 0x04
	*(uint8_t*)0x100006d8 = 0x88
	*(uint8_t*)0x100006d9 = 0x00
	*(uint8_t*)0x100006da = 0x7f
	*(uint8_t*)0x100006db = 0x00
	*(uint8_t*)0x100006dc = 0xa4
	*(uint8_t*)0x100006dd = 0x03
	*(uint8_t*)0x100006de = 0x88
	*(uint8_t*)0x100006df = 0x00
	*(uint8_t*)0x100006e0 = 0x00
	*(uint8_t*)0x100006e1 = 0x00
	*(uint8_t*)0x100006e2 = 0x00
	*(uint8_t*)0x100006e3 = 0x00
	*(uint8_t*)0x100006e4 = 0x01
	*(uint8_t*)0x100006e5 = 0x00
	*(uint8_t*)0x100006e6 = 0x33
	*(uint8_t*)0x100006e7 = 0x00
	*(uint8_t*)0x100006e8 = 0x70
	*(uint8_t*)0x100006e9 = 0x03
	*(uint8_t*)0x100006ea = 0x88
	*(uint8_t*)0x100006eb = 0x00
	*(uint8_t*)0x100006ec = 0x4f
	*(uint8_t*)0x100006ed = 0x00
	*(uint8_t*)0x100006ee = 0xba
	*(uint8_t*)0x100006ef = 0x02
	*(uint8_t*)0x100006f0 = 0xc7
	*(uint8_t*)0x100006f1 = 0x00
	*(uint8_t*)0x100006f2 = 0x00
	*(uint8_t*)0x100006f3 = 0x00
	*(uint8_t*)0x100006f4 = 0x00
	*(uint8_t*)0x100006f5 = 0x00
	*(uint8_t*)0x100006f6 = 0x11
	*(uint8_t*)0x100006f7 = 0x01
	*(uint8_t*)0x100006f8 = 0x54
	*(uint8_t*)0x100006f9 = 0x00
	*(uint8_t*)0x100006fa = 0x75
	*(uint8_t*)0x100006fb = 0x05
	*(uint8_t*)0x100006fc = 0x88
	*(uint8_t*)0x100006fd = 0x00
	*(uint8_t*)0x100006fe = 0x7b
	*(uint8_t*)0x100006ff = 0x00
	*(uint8_t*)0x10000700 = 0xe0
	*(uint8_t*)0x10000701 = 0x06
	*(uint8_t*)0x10000702 = 0xcd
	*(uint8_t*)0x10000703 = 0x00
	*(uint8_t*)0x10000704 = 0x05
	*(uint8_t*)0x10000705 = 0x00
	*(uint8_t*)0x10000706 = 0x00
	*(uint8_t*)0x10000707 = 0x00
	*(uint8_t*)0x10000708 = 0x64
	*(uint8_t*)0x10000709 = 0x00
	*(uint8_t*)0x1000070a = 0x20
	*(uint8_t*)0x1000070b = 0x06
	*(uint8_t*)0x1000070c = 0xc8
	*(uint8_t*)0x1000070d = 0x00
	*(uint8_t*)0x1000070e = 0xc8
	*(uint8_t*)0x1000070f = 0x00
	*(uint8_t*)0x10000710 = 0xc8
	*(uint8_t*)0x10000711 = 0x05
	*(uint8_t*)0x10000712 = 0xc8
	*(uint8_t*)0x10000713 = 0x00
	*(uint8_t*)0x10000714 = 0x64
	*(uint8_t*)0x10000715 = 0x00
	*(uint8_t*)0x10000716 = 0x27
	*(uint8_t*)0x10000717 = 0x05
	*(uint8_t*)0x10000718 = 0xc8
	*(uint8_t*)0x10000719 = 0x00
	*(uint8_t*)0x1000071a = 0xc8
	*(uint8_t*)0x1000071b = 0x00
	*(uint8_t*)0x1000071c = 0x27
	*(uint8_t*)0x1000071d = 0x05
	*(uint8_t*)0x1000071e = 0xc8
	*(uint8_t*)0x1000071f = 0x00
	*(uint8_t*)0x10000720 = 0x64
	*(uint8_t*)0x10000721 = 0x00
	*(uint8_t*)0x10000722 = 0xc8
	*(uint8_t*)0x10000723 = 0x05
	*(uint8_t*)0x10000724 = 0xd6
	*(uint8_t*)0x10000725 = 0x00
	*(uint8_t*)0x10000726 = 0x0b
	*(uint8_t*)0x10000727 = 0x00
	*(uint8_t*)0x10000728 = 0x0b
	*(uint8_t*)0x10000729 = 0x00
	*(uint8_t*)0x1000072a = 0x00
	*(uint8_t*)0x1000072b = 0x00
	*(uint8_t*)0x1000072c = 0x00
	*(uint8_t*)0x1000072d = 0x00
	*(uint8_t*)0x1000072e = 0x04
	*(uint8_t*)0x1000072f = 0x00
	*(uint8_t*)0x10000730 = 0x56
	*(uint8_t*)0x10000731 = 0x00
	*(uint8_t*)0x10000732 = 0xdc
	*(uint8_t*)0x10000733 = 0x03
	*(uint8_t*)0x10000734 = 0xc6
	*(uint8_t*)0x10000735 = 0x00
	*(uint8_t*)0x10000736 = 0x00
	*(uint8_t*)0x10000737 = 0x00
	*(uint8_t*)0x10000738 = 0x00
	*(uint8_t*)0x10000739 = 0x00
	*(uint8_t*)0x1000073a = 0x04
	*(uint8_t*)0x1000073b = 0x00
	*(uint8_t*)0x1000073c = 0x5b
	*(uint8_t*)0x1000073d = 0x00
	*(uint8_t*)0x1000073e = 0xa4
	*(uint8_t*)0x1000073f = 0x03
	*(uint8_t*)0x10000740 = 0xce
	*(uint8_t*)0x10000741 = 0x00
	*(uint8_t*)0x10000742 = 0x00
	*(uint8_t*)0x10000743 = 0x00
	*(uint8_t*)0x10000744 = 0x00
	*(uint8_t*)0x10000745 = 0x00
	*(uint8_t*)0x10000746 = 0x01
	*(uint8_t*)0x10000747 = 0x00
	*(uint8_t*)0x10000748 = 0x00
	*(uint8_t*)0x10000749 = 0x00
	*(uint8_t*)0x1000074a = 0x00
	*(uint8_t*)0x1000074b = 0x00
	*(uint8_t*)0x1000074c = 0x06
	*(uint8_t*)0x1000074d = 0x00
	*(uint8_t*)0x1000074e = 0x5b
	*(uint8_t*)0x1000074f = 0x00
	*(uint8_t*)0x10000750 = 0x70
	*(uint8_t*)0x10000751 = 0x03
	*(uint8_t*)0x10000752 = 0xce
	*(uint8_t*)0x10000753 = 0x00
	*(uint8_t*)0x10000754 = 0x00
	*(uint8_t*)0x10000755 = 0x00
	*(uint8_t*)0x10000756 = 0x00
	*(uint8_t*)0x10000757 = 0x00
	*(uint8_t*)0x10000758 = 0x03
	*(uint8_t*)0x10000759 = 0x00
	*(uint8_t*)0x1000075a = 0x3b
	*(uint8_t*)0x1000075b = 0x00
	*(uint8_t*)0x1000075c = 0x20
	*(uint8_t*)0x1000075d = 0x06
	*(uint8_t*)0x1000075e = 0xc1
	*(uint8_t*)0x1000075f = 0x00
	*(uint8_t*)0x10000760 = 0x00
	*(uint8_t*)0x10000761 = 0x00
	*(uint8_t*)0x10000762 = 0x00
	*(uint8_t*)0x10000763 = 0x00
	*(uint8_t*)0x10000764 = 0x02
	*(uint8_t*)0x10000765 = 0x00
	*(uint8_t*)0x10000766 = 0x61
	*(uint8_t*)0x10000767 = 0x00
	*(uint8_t*)0x10000768 = 0x93
	*(uint8_t*)0x10000769 = 0x02
	*(uint8_t*)0x1000076a = 0xd7
	*(uint8_t*)0x1000076b = 0x00
	*(uint8_t*)0x1000076c = 0x00
	*(uint8_t*)0x1000076d = 0x00
	*(uint8_t*)0x1000076e = 0x00
	*(uint8_t*)0x1000076f = 0x00
	*(uint8_t*)0x10000770 = 0x06
	*(uint8_t*)0x10000771 = 0x00
	*(uint8_t*)0x10000772 = 0x39
	*(uint8_t*)0x10000773 = 0x00
	*(uint8_t*)0x10000774 = 0xb8
	*(uint8_t*)0x10000775 = 0x07
	*(uint8_t*)0x10000776 = 0xc5
	*(uint8_t*)0x10000777 = 0x00
	*(uint8_t*)0x10000778 = 0x00
	*(uint8_t*)0x10000779 = 0x00
	*(uint8_t*)0x1000077a = 0x00
	*(uint8_t*)0x1000077b = 0x00
	*(uint8_t*)0x1000077c = 0x05
	*(uint8_t*)0x1000077d = 0x00
	*(uint8_t*)0x1000077e = 0x32
	*(uint8_t*)0x1000077f = 0x00
	*(uint8_t*)0x10000780 = 0x49
	*(uint8_t*)0x10000781 = 0x07
	*(uint8_t*)0x10000782 = 0xce
	*(uint8_t*)0x10000783 = 0x00
	*(uint8_t*)0x10000784 = 0x00
	*(uint8_t*)0x10000785 = 0x00
	*(uint8_t*)0x10000786 = 0x00
	*(uint8_t*)0x10000787 = 0x00
	*(uint8_t*)0x10000788 = 0x01
	*(uint8_t*)0x10000789 = 0x00
	*(uint8_t*)0x1000078a = 0x00
	*(uint8_t*)0x1000078b = 0x00
	*(uint8_t*)0x1000078c = 0x00
	*(uint8_t*)0x1000078d = 0x00
	*(uint8_t*)0x1000078e = 0x04
	*(uint8_t*)0x1000078f = 0x00
	*(uint8_t*)0x10000790 = 0x3f
	*(uint8_t*)0x10000791 = 0x00
	*(uint8_t*)0x10000792 = 0xe0
	*(uint8_t*)0x10000793 = 0x06
	*(uint8_t*)0x10000794 = 0xc8
	*(uint8_t*)0x10000795 = 0x00
	*(uint8_t*)0x10000796 = 0x00
	*(uint8_t*)0x10000797 = 0x00
	*(uint8_t*)0x10000798 = 0x00
	*(uint8_t*)0x10000799 = 0x00
	*(uint8_t*)0x1000079a = 0x0a
	*(uint8_t*)0x1000079b = 0x00
	*(uint8_t*)0x1000079c = 0x5b
	*(uint8_t*)0x1000079d = 0x00
	*(uint8_t*)0x1000079e = 0x10
	*(uint8_t*)0x1000079f = 0x03
	*(uint8_t*)0x100007a0 = 0xbf
	*(uint8_t*)0x100007a1 = 0x00
	*(uint8_t*)0x100007a2 = 0x00
	*(uint8_t*)0x100007a3 = 0x00
	*(uint8_t*)0x100007a4 = 0x00
	*(uint8_t*)0x100007a5 = 0x00
	*(uint8_t*)0x100007a6 = 0x09
	*(uint8_t*)0x100007a7 = 0x00
	*(uint8_t*)0x100007a8 = 0x35
	*(uint8_t*)0x100007a9 = 0x00
	*(uint8_t*)0x100007aa = 0x27
	*(uint8_t*)0x100007ab = 0x05
	*(uint8_t*)0x100007ac = 0xd5
	*(uint8_t*)0x100007ad = 0x00
	*(uint8_t*)0x100007ae = 0x00
	*(uint8_t*)0x100007af = 0x00
	*(uint8_t*)0x100007b0 = 0x00
	*(uint8_t*)0x100007b1 = 0x00
	*(uint8_t*)0x100007b2 = 0x00
	*(uint8_t*)0x100007b3 = 0x00
	*(uint8_t*)0x100007b4 = 0x00
	*(uint8_t*)0x100007b5 = 0x00
	*(uint8_t*)0x100007b6 = 0x00
	*(uint8_t*)0x100007b7 = 0x00
	*(uint8_t*)0x100007b8 = 0x60
	*(uint8_t*)0x100007b9 = 0xf1
	*(uint8_t*)0x100007ba = 0x00
	*(uint8_t*)0x100007bb = 0x00
	*(uint8_t*)0x100007bc = 0x7e
	*(uint8_t*)0x100007bd = 0xf1
	*(uint8_t*)0x100007be = 0x00
	*(uint8_t*)0x100007bf = 0x00
	*(uint8_t*)0x100007c0 = 0x00
	*(uint8_t*)0x100007c1 = 0x00
	*(uint8_t*)0x100007c2 = 0x00
	*(uint8_t*)0x100007c3 = 0x00
	*(uint8_t*)0x100007c4 = 0x00
	*(uint8_t*)0x100007c5 = 0x00
	*(uint8_t*)0x100007c6 = 0x00
	*(uint8_t*)0x100007c7 = 0x00
	*(uint8_t*)0x100007c8 = 0x00
	*(uint8_t*)0x100007c9 = 0x00
	*(uint8_t*)0x100007ca = 0x00
	*(uint8_t*)0x100007cb = 0x00
	*(uint8_t*)0x100007cc = 0x00
	*(uint8_t*)0x100007cd = 0x00
	*(uint8_t*)0x100007ce = 0x00
	*(uint8_t*)0x100007cf = 0x00
	*(uint8_t*)0x100007d0 = 0x00
	*(uint8_t*)0x100007d1 = 0x00
	*(uint8_t*)0x100007d2 = 0x00
	*(uint8_t*)0x100007d3 = 0x00
	*(uint8_t*)0x100007d4 = 0x00
	*(uint8_t*)0x100007d5 = 0x00
	*(uint8_t*)0x100007d6 = 0x00
	*(uint8_t*)0x100007d7 = 0x00
	*(uint8_t*)0x100007d8 = 0x00
	*(uint8_t*)0x100007d9 = 0x00
	*(uint8_t*)0x100007da = 0x00
	*(uint8_t*)0x100007db = 0x00
	*(uint8_t*)0x100007dc = 0x00
	*(uint8_t*)0x100007dd = 0x00
	*(uint8_t*)0x100007de = 0x00
	*(uint8_t*)0x100007df = 0x00
	*(uint8_t*)0x100007e0 = 0x8c
	*(uint8_t*)0x100007e1 = 0xf1
	*(uint8_t*)0x100007e2 = 0x00
	*(uint8_t*)0x100007e3 = 0x00
	*(uint8_t*)0x100007e4 = 0x00
	*(uint8_t*)0x100007e5 = 0x00
	*(uint8_t*)0x100007e6 = 0x00
	*(uint8_t*)0x100007e7 = 0x00


	// Firmware Offset(s): 
	//	0x00002a7e - 0x00002a7e
	//	0x000029f6 - 0x000029fa
	//	0x000029ec - 0x000029f4
	//	0x0000c2cc - 0x0000c2cc

	// Control logic to exit SRAM0 heap init above


	// Firmware Offset(s): 
	//	0x0000c2ce - 0x0000c2d8

	// SRAM1 initialization
	*(uint32_t*)0x20000000 = 0x0000ffff;
	*(uint32_t*)0x20000004 = 0x00016400	
	*(uint32_t*)0x20000008 = 0x00001400
	*(uint32_t*)0x2000000c = 0x00000000
	*(uint32_t*)0x20000010 = 0x27100000
	*(uint32_t*)0x20000014 = 0x00000000
	*(uint32_t*)0x20000018 = 0x00000000
	*(uint32_t*)0x2000001c = 0x00000000
	*(uint32_t*)0x20000020 = 0x00000000
	*(uint32_t*)0x20000024 = 0x00000000
	*(uint32_t*)0x20000028 = 0x00000000
	*(uint32_t*)0x2000002c = 0x00000000
	*(uint32_t*)0x20000030 = 0x00000000
	*(uint32_t*)0x20000034 = 0x00000000
	*(uint32_t*)0x20000038 = 0x00000000
	*(uint32_t*)0x2000003c = 0x00000000
	*(uint32_t*)0x20000040 = 0x00000000
	*(uint32_t*)0x20000044 = 0x00000000
	*(uint32_t*)0x20000048 = 0x00000000
	*(uint32_t*)0x2000004c = 0x00000000
	*(uint32_t*)0x20000050 = 0x00000000
	*(uint32_t*)0x20000054 = 0x00000000
	*(uint32_t*)0x2000005c = 0x00000000
	*(uint32_t*)0x20000060 = 0x00000000
	*(uint32_t*)0x20000064 = 0x00000000
	*(uint32_t*)0x20000068 = 0x00000000
	*(uint32_t*)0x2000006c = 0x00000000
	*(uint32_t*)0x20000070 = 0x00000000
	*(uint32_t*)0x20000074 = 0x00000000
	*(uint32_t*)0x20000078 = 0x00000000


	// Firmware Offset(s): 
	//	0x000029f6 - 0x000029fa
	//	0x000029ec - 0x000029f4
	//	0x0000c2dc - 0x0000c2de
	//	0x0000c2e0 - 0x0000c2e8

	// SRAM0 initialization
	*(uint32_t*)0x100000c4 = 0x00000000
	*(uint32_t*)0x100000c8 = 0x00000000
	*(uint32_t*)0x100000cc = 0x00000000
	*(uint32_t*)0x100000d0 = 0x00000000
	*(uint32_t*)0x100000d4 = 0x00000000
	*(uint32_t*)0x100000d8 = 0x00000000
	*(uint32_t*)0x100000dc = 0x00000000
	*(uint32_t*)0x100000e0 = 0x00000000
	*(uint32_t*)0x100000e4 = 0x00000000
	*(uint32_t*)0x100000e8 = 0x00000000
	*(uint32_t*)0x100000ec = 0x00000000
	*(uint32_t*)0x100000f0 = 0x00000000


	// Firmware Offset(s): 
	//	0x000029f6 - 0x000029fa
	//	0x000029ec - 0x000029f4
	//	0x0000c2dc - 0x0000c2de
	//	0x0000c2e0 - 0x0000c2e8

	// SRAM0 initialization
	write 0's to 0x100007e8 to 0x10001fc4 with 32-bit writes


	// Firmware Offset(s): 
	//	0x000029f6 - 0x000029fa
	//	0x000029ec - 0x000029f4
	//	0x0000c2dc - 0x0000c2de
	//	0x0000c2e0 - 0x0000c2e8

	// SRAM1 initialization
	write 0's to 0x2000007c to 0x2000030c with 32-bit writes


	// Firmware Offset(s): 
	//	0x000029f6 - 0x000029fc
	//	0x000020c8 - 0x000020ca
	//	0x0000d778 - 0x0000d778
	//	0x00009cfc - 0x00009cfe
	//	0x00004174 - 0x00004176

	// Steps to back away from memory filling logics (i.e. stack pops, etc.)


	// Firmware Offset(s): 
	//	0x00004130 - 0x0000414a

	//	Check that Main clock source select register is set to PLL output
	val = *(uint32_t*)0x40048070;

	if (val != 3) {
		// TODO: UNKNOWN PATHS
		//	Jump to 0x00004150 for IRC Oscillator
		//	Jump to 0x00004154 for PLL input
		//	Jump to 0x0000415a for Watchdown oscillator
		//	Execute 0x0000414e if none of the above
	}


	// Firmware Offset(s): 
	//	0x000041b0 - 0x000041b2
	//	0x00004188 - 0x00004194

	// Check system PLL clock source select register and verify is set to Crystal Oscillator (SYSOSC)
	val = *(uint32_t*)0x40048040;
	if (val != 1) {
		// TODO: UNKNOWN PATHS 
		//	Branch to 0x0000419a if val == 0
		//	Execute 0x00004196 if val != 0 && val != 1
	}


	// Firmware Offset(s): 
	//	0x0000419e - 0x000041a2
	//	0x000041b6 - 0x000041bc
	//	0x00004168 - 0x00004172
	//	0x000041c0 - 0x000041c0
	//	0x0000414e - 0x0000414e
	//	0x0000417a - 0x0000417e
	//	0x000020ec - 0x000020f8
	//	0x0000210e - 0x00002114
	//	0x000020fa - 0x00002100
	//	0x00002102 - 0x00002116
	//	0x00004182 - 0x00004182
	//	0x00009d06 - 0x00009d06
	//	0x0000d77c - 0x0000d77c

	// Read System PLL control register
	reg0 = *(uint32_t*)0x40048008;
	// Isolate MSEL (feedback divider value)
	reg0 &= 0x1f;

	// Read System clock divider register
	reg1 = *(uint32_t*)0x40048078;

	// And then a long series of loops based on the values read above
	//  Looks like a delay based on PLL and system clock settings

	// Store these result to SRAM0 value
	*(uint32_t*)0x100000a4 = 0x02dc6c00;


	// Firmware Offset(s): 
	//	0x00009c50 - 0x00009c56
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 0;
	reg0 = 0x15;

	reg2 = 0xff;

	// Read Interrupt Priority Register 5
	reg3 = (*uint32_t*)0xe000e414;

	// Isolate interrupt priority for SSP0 and set to highest (0)
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009c5a - 0x00009c5e
	//	0x000072dc - 0x00007304

	reg1 = 0;
	reg0 = 0xFFFFFFFF;
	
	reg3 = reg0;
	reg2 = 0xff000000;

	// Used to count shifts for reg1 and reg2
	reg3 >>= 27; // 0x18

	// Read Interrupt Control and State Register (ICSR)
	reg3 = *(uint32_t*)0xe000ed04;

	// Set lower 24 bits, but these are all RO... Not sure why this is happening...
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009c62 - 0x00009c66
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 1;
	reg0 = 0x14;

	...
	reg2 = 0xFF;
	reg1 = 0x40;

	// Read Interrupt Priority Register 5
	reg3 = *(uint32_t*)0xe000e414;

	// Isolate interrupt priority for SSP0 and set to 1, one below highest 
	reg3 &= ~reg2;
	reg3 |= reg1;

	
	
	// Firmware Offset(s): 
	//	0x00009c6a - 0x00009c6e
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 1;
	reg0 = 0xe;

	...
	reg2 = 0x00ff0000;
	reg1 = 0x00400000;

	// Read Interrupt Priority Register 3
	reg3 = *(uint32_t*)0xe000e40c;

	// Isolate interrupt priority for SSP1 and set to 1, one below highest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009c72 - 0x00009c76
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 1;
	reg0 = 0x12;

	...
	reg2 = 0x00ff0000;
	reg1 = 0x00400000;

	// Read Interrupt Priority Register 4
	reg3 = *(uint32_t*)0xe000e410;

	// Isolate interrupt priority for CT32B0 and set to 1, one below highest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009c7a - 0x00009c7e
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 1;
	reg0 = 0x16;

	...
	reg2 = 0x00ff0000;
	reg1 = 0x00400000;

	// Read Interrupt Priority Register 5
	reg3 = *(uint32_t*)0xe000e414;

	// Isolate interrupt priority for USB_IRQ and set to 1, one below highest 
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009c82 - 0x00009c86
	//	0x000072dc - 0x00007304

	reg1 = 1;
	reg0 = 0xFFFFFFFE;
	
	..
	reg2 = 0x00ff0000;
	reg1 = 0x00400000;

	// Read System Handler Priority Register 3 (SHPR3)
	reg3 = *(uint32_t*)0xe000ed20;

	// Set PRI_14 Priority of system handler 14, PendSV to 1, one below highest 
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009c8a - 0x00009c8e
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 2;
	reg0 = 0x10;

	...
	reg2 = 0x000000ff;
	reg1 = 0x00000080;

	// Read Interrupt Priority Register 4
	reg3 = *(uint32_t*)0xe000e410;

	// Isolate interrupt priority for CT16B0 and set to 2, one above lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009c92 - 0x00009c96
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 2;
	reg0 = 0x11;

	...
	reg2 = 0x0000ff00;
	reg1 = 0x00008000;

	// Read Interrupt Priority Register 4
	reg3 = *(uint32_t*)0xe000e410;

	// Isolate interrupt priority for CT16B1 and set to 2, one above lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009c9a - 0x00009c9e
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 2;
	reg0 = 0x13;

	...
	reg2 = 0xff000000;
	reg1 = 0x80000000;

	// Read Interrupt Priority Register 4
	reg3 = *(uint32_t*)0xe000e410;

	// Isolate interrupt priority for CT32B1 and set to 2, one above lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009ca2 - 0x00009ca6
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 2;
	reg0 = 0x18;

	...
	reg2 = 0x000000ff;
	reg1 = 0x00000080;

	// Read Interrupt Priority Register 4
	reg3 = *(uint32_t*)0xe000e418;

	// Isolate interrupt priority for ADC and set to 2, one above lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009caa - 0x00009cae
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 2;
	reg0 = 0xf;

	...
	reg2 = 0xff000000;
	reg1 = 0x80000000;

	// Read Interrupt Priority Register 3
	reg3 = *(uint32_t*)0xe000e40c;

	// Isolate interrupt priority for I2C0 and set to 2, one above lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cb2 - 0x00009cb6
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x0;

	...
	reg2 = 0x000000ff;
	reg1 = 0x000000c0;

	// Read Interrupt Priority Register 0
	reg3 = *(uint32_t*)0xe000e400;

	// Isolate interrupt priority for PIN_INT0 and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cba - 0x00009cbe
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x1;

	...
	reg2 = 0x0000ff00;
	reg1 = 0x0000c000;

	// Read Interrupt Priority Register 0
	reg3 = *(uint32_t*)0xe000e400;

	// Isolate interrupt priority for PIN_INT1 and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cc2 - 0x00009cc6
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x2;

	...
	reg2 = 0x00ff0000;
	reg1 = 0x00c00000;

	// Read Interrupt Priority Register 0
	reg3 = *(uint32_t*)0xe000e400;

	// Isolate interrupt priority for PIN_INT2 and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cca - 0x00009cce
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x3;

	...
	reg2 = 0xff000000;
	reg1 = 0xc0000000;

	// Read Interrupt Priority Register 0
	reg3 = *(uint32_t*)0xe000e400;

	// Isolate interrupt priority for PIN_INT3 and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cd2 - 0x00009cd6
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x4;

	...
	reg2 = 0x000000ff;
	reg1 = 0x000000c0;

	// Read Interrupt Priority Register 1
	reg3 = *(uint32_t*)0xe000e404;

	// Isolate interrupt priority for PIN_INT4 and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cda - 0x00009cde
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x5;

	...
	reg2 = 0x0000ff00;
	reg1 = 0x0000c000;

	// Read Interrupt Priority Register 1
	reg3 = *(uint32_t*)0xe000e404;

	// Isolate interrupt priority for PIN_INT5 and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009ce2 - 0x00009ce6
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x6;

	...
	reg2 = 0x00ff0000;
	reg1 = 0x00c00000;

	// Read Interrupt Priority Register 1
	reg3 = *(uint32_t*)0xe000e404;

	// Isolate interrupt priority for PIN_INT6 and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cea - 0x00009cee
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x7;

	...
	reg2 = 0xff000000;
	reg1 = 0xc0000000;

	// Read Interrupt Priority Register 1
	reg3 = *(uint32_t*)0xe000e404;

	// Isolate interrupt priority for PIN_INT7 and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cf2 - 0x00009cf6
	//	0x000072dc - 0x000072ec
	//	0x00007306 - 0x00007316

	reg1 = 3;
	reg0 = 0x8;

	...
	reg2 = 0x000000ff;
	reg1 = 0x000000c0;

	// Read Interrupt Priority Register 2
	reg3 = *(uint32_t*)0xe000e408;

	// Isolate interrupt priority for GINT0 (GPIO GROUP0) and set to 3, lowest
	reg3 &= ~reg2;
	reg3 |= reg1;


	// Firmware Offset(s): 
	//	0x00009cfa - 0x00009cfa
	//	0x0000d780 - 0x0000d780
	//	0x0000a0d8 - 0x0000a0f4

	// Initialize more heap space in SRAM0
	*(uint32_t*)0x10000818 = 0x00000000;
	*(uint32_t*)0x1000081c = 0x00000000;
	*(uint32_t*)0x10000820 = 0x00000000;
	*(uint32_t*)0x10000824 = 0x00000000;
	*(uint32_t*)0x10000828 = 0x00000000;
	*(uint32_t*)0x1000082c = 0x00000000;
	*(uint32_t*)0x10000830 = 0x00000000;
	*(uint32_t*)0x10000834 = 0x00000000;
	*(uint32_t*)0x10000838 = 0x00000000;
	*(uint32_t*)0x1000083c = 0x00000000;
	*(uint32_t*)0x10000840 = 0x00000000;
	*(uint32_t*)0x10000844 = 0x00000000;
	*(uint32_t*)0x10000848 = 0x00000000;
	*(uint32_t*)0x1000084c = 0x00000000;
	*(uint32_t*)0x10000850 = 0x00000000;
	*(uint32_t*)0x10000854 = 0x00000000;


	// Firmware Offset(s): 
	//	0x0000a0f6 - 0x0000a0f6
	//	0x0000d784 - 0x0000d784
	//	0x00005644 - 0x00005648
	//	0x00004108 - 0x00004114

	// Enables clock for I/O configuration block via System clock control register
	reg2 = *(uint32_t*)0x40048080;
	reg2 |= 0x00010000;
	*(uint32_t*)0x40048080 = reg2;


	// Firmware Offset(s): 
	//	0x0000564c - 0x00005650
	//	0x00004224 - 0x0000422e

	// Enables clock for 16-bit counter/timer 0 via System clock control register
	reg1 = *(uint32_t*)0x40048080;
	reg1 |= 0x00000040;
	*(uint32_t*)0x40048080 = reg1;


	// Firmware Offset(s): 
	//	0x00005654 - 0x00005656
	//	0x00004108 - 0x00004114

	// Enables clock to GPIO Pin interrupts register via System clock control register
	reg2 = *(uint32_t*)0x40048080;
	reg2 |= 0x00080000;
	*(uint32_t*)0x40048080 = reg2;


	// Firmware Offset(s): 
	//	0x0000565a - 0x0000565a
	//	0x0000d788 - 0x0000d788
	//	0x00002ba0 - 0x00002ba8
	//	0x00003fd0 - 0x00003fd8
	//	0x0000452c - 0x00004540

	// Power ADC via Power configuration register
	reg1 = *(uint32_t*)0x40048238;
	reg1 &= 0x000005ff;
	reg1 &= ~0x00000010;
	reg1 |= 0x0000e800;
	*(uint32_t*)0x40048238 = reg1;


	// Firmware Offset(s): 
	//	0x00003fdc - 0x00003ffa

	// Enables clock for ADC via System clock control register
	reg1 = *(uint32_t*)0x40048080;
	reg1 |= 0x00002000;
	*(uint32_t*)0x40048080 = reg1;

	// Disable all A/D interrupts via A/D Interrupt Enable Register
	*(uint32_t*)0x4001c00c = 0x00000000	


	// Firmware Offset(s): 
	//	0x0000d0e8 - 0x0000d0f0
	//	0x00004174 - 0x00004176
	//	0x00004130 - 0x0000414a

	//	Check that Main clock source select register is set to PLL output
	val = *(uint32_t*)0x40048070;

	if (val != 3) {
		// TODO: UNKNOWN PATHS
		//	Jump to 0x00004150 for IRC Oscillator
		//	Jump to 0x00004154 for PLL input
		//	Jump to 0x0000415a for Watchdown oscillator
		//	Execute 0x0000414e if none of the above
	}


	// Firmware Offset(s): 
	//	0x00004188 - 0x00004194

	// Check system PLL clock source select register and verify is set to Crystal Oscillator (SYSOSC)
	val = *(uint32_t*)0x40048040;
	if (val != 1) {
		// TODO: UNKNOWN PATHS 
		//	Branch to 0x0000419a if val == 0
		//	Execute 0x00004196 if val != 0 && val != 1
	}


	// Firmware Offset(s): 
	//	0x0000419e - 0x000041a2
	//	0x000041b6 - 0x000041bc
	//	0x00004168 - 0x00004172
	//	0x000041c0 - 0x000041c0
	//	0x0000414e - 0x0000414e
	//	0x0000417a - 0x0000417e
	//	0x000020ec - 0x000020f8
	//	0x0000210e - 0x00002114
	//	0x000020fa - 0x00002100
	//	0x00002102 - 0x00002116
	//	0x00004182 - 0x00004182

	// Read System PLL control register
	reg0 = *(uint32_t*)0x40048008;
	// Isolate MSEL (feedback divider value)
	reg0 &= 0x1f;

	// Read System clock divider register
	reg1 = *(uint32_t*)0x40048078;

	// And then a long series of loops based on the values read above
	//  Looks like a delay based on PLL and system clock settings


	// Firmware Offset(s): 
	//	0x0000d0f4 - 0x0000d0f6
	//	0x0000d0fc - 0x0000d106
	//	0x000020ec - 0x000020f8
	//	0x0000210e - 0x00002114
	// 	0x000020fa - 0x00002100
	//	0x00002116 - 0x00002116

	// Some big loop calculating some values, possibly related to above


	// Firmware Offset(s): 
	//	0x0000d10a - 0x0000d10e
	//	0x00003ffe - 0x0000400c
	//	0x00002bac - 0x00002bb8

	// A/D Control Register
	//	Set CLKDIV to 11 (This divides APB/PCLK)
	//	TODO: Not sure why bit 21 is set '1' this should be a reserved bit and only 0 written...
	*(uint32_t*)0x4001c000 = 0x00200a00;


	// Firmware Offset(s): 
	//	0x0000404c - 0x00004066

	// Read A/D Control Register, but ends up stored on stack for now?
	reg6 = *(uint32_t*)0x4001c000;


	// Firmware Offset(s): 
	//	0x0000d0e8 - 0x0000d0f0
	//	0x00004174 - 0x00004176
	//	0x00004130 - 0x0000414a

	//	Check that Main clock source select register is set to PLL output
	val = *(uint32_t*)0x40048070;

	if (val != 3) {
		// TODO: UNKNOWN PATHS
		//	Jump to 0x00004150 for IRC Oscillator
		//	Jump to 0x00004154 for PLL input
		//	Jump to 0x0000415a for Watchdown oscillator
		//	Execute 0x0000414e if none of the above
	}


	// Firmware Offset(s): 
	//	0x000041b0 - 0x000041b2
	//	0x00004188 - 0x00004194

	// Check system PLL clock source select register and verify is set to Crystal Oscillator (SYSOSC)
	val = *(uint32_t*)0x40048040;
	if (val != 1) {
		// TODO: UNKNOWN PATHS 
		//	Branch to 0x0000419a if val == 0
		//	Execute 0x00004196 if val != 0 && val != 1
	}


	// Firmware Offset(s): 
	//	0x0000419e - 0x000041a2
	//	0x000041b6 - 0x000041bc
	//	0x00004168 - 0x00004172
	//	0x000041c0 - 0x000041c0
	//	0x0000414e - 0x0000414e
	//	0x0000417a - 0x0000417e
	//	0x000020ec - 0x000020f8
	//	0x0000210e - 0x00002114
	//	0x000020fa - 0x00002100
	//	0x00002102 - 0x00002116
	//	0x00004182 - 0x00004182

	// Read System PLL control register
	reg0 = *(uint32_t*)0x40048008;
	// Isolate MSEL (feedback divider value)
	reg0 &= 0x1f;

	// Read System clock divider register
	reg1 = *(uint32_t*)0x40048078;

	// And then a long series of loops based on the values read above
	//  Looks like a delay based on PLL and system clock settings


	// Firmware Offset(s): 
	//	0x0000d0f4 - 0x0000d0fa
	//	0x0000d100 - 0x0000d106
	//	0x000020ec - 0x000020f8
	//	0x0000210e - 0x00002114
	// 	0x000020fa - 0x00002100
	//	0x00002116 - 0x00002116

	// Some big loop calculating some values, possibly related to above


	// Firmware Offset(s): 
	//	0x0000d10a - 0x0000d10e
	//	0x0000406a - 0x00004078
	//	0x00002bbc - 0x00002bc2

	// Note: this is pretty much same code above for last access of this register, but executes different code space...
	//	Guessing this is superfluous code from some NXP library or something

	// A/D Control Register
	//	Set CLKDIV to 11 (This divides APB/PCLK)
	//	TODO: Not sure why bit 21 is set '1' this should be a reserved bit and only 0 written...
	*(uint32_t*)0x4001c000 = 0x00200a00;


	// Firmware Offset(s): 
	//	0x00004080 - 0x0000409c
	//	0x0000e6e8 - 0x0000e6f6

	reg1 = 0;

	// A/D Control Register
	reg2 = *(uint32_t*)0x4001c000;
	// Clear START (clearing clearing PDN to 0?)
	reg2 &= ~0x07000000;
	reg1 |= reg2;
	*(uint32_t*)0x4001c000 = reg1;


	// Firmware Offset(s): 
	//	0x000040a0 - 0x000040a0
	//	0x00002bc6 - 0x00002bce

	// Set a value in SRAM0 (heap?) 
	*(uint8_t*)0x10000012 = 0x00;


	// Firmware Offset(s): 
	//	0x000040b8 - 0x000040c4 
	
	// TODO: did I miss something above... Why was ADC enabled, and is now being disabled...?

	// Disable ADC clock via System clock control register 
	reg2 = *(uint32_t*)0x40048080;
	reg2 &= ~0x00002000;
	*(uint32_t*)0x40048080 = reg2;


	// Firmware Offset(s): 
	//	0x00002bd2 - 0x00002bd2
	//	0x0000d78c - 0x0000d78c
	//	0x00006644 - 0x0000664c
	//	0x000051c4 - 0x000051d8

	// Read SRAM0 value (think this is some clock in MHZ as sim value comes out to 48000000)
	reg1 = *(uint32_t*)0x100000a4;
	// reg1 val is then shifted to right by 10 and stored on the stack... (computes to 46875)


	// Firmware Offset(s): 
	//	0x00005d10 - 0x00005d1c
	//	0x00009b4c - 0x00009b56
	//	0x00005d20 - 0x00005d26

	// Setup command_param for EEPROM read via IAP command
	*0x10001f78 = 0x0000003e // Command code (62)
	*0x10001f7c = 0x00000000 // Param0: EEPROM Address
	*0x10001f80 = 0x100009b4 // Param1: RAM Address 
	*0x10001f84 = 0x00000084 // Param2: Number of bytes to be read (132)
	*0x10001f88 = 0x0000b71b // Param3: System Clock Frequency 

	// This means that 0x100009b4 - 0x10000a37 will store first 0x84 bytes of EEPROM

	// Mark EEPROM access is taking place
	reg1 = *(uint8_t*)0x10000340;
	reg1 += 1;
	*(uint8_t*)0x10000340 = reg1;


	// Firmware Offset(s): 
	//	0x1fff1ff0 - ...
	//	...        - 0x1fff1ff6

	// boot ROM code for executing IAB command
	iap_entry(command_param = 0x10001f78, status_result = 0x10001f8c);


	// Firmware Offset(s): 
	//	0x00005d28 - 0x00005d28
	//	0x00009b70 - 0x00009b80

	// Mark EEPROM access is taking place
	reg1 = *(uint8_t*)0x10000340;
	reg1 -= 1;
	*(uint8_t*)0x10000340 = reg1;


	// Firmware Offset(s): 
	//	0x00005d2c - 0x00005d30
	//	0x000051dc - 0x000051dc
	//	0x00006650 - 0x00006658

	// Check Magic Number (value read from EEPROM)
	reg0 = *(uint16_t)0x100009b4;
	if (reg0 != 0xa55a) {
		// UNKNOWN PATHS execute instruction 0x0000665A
	}


	// Firmware Offset(s): 
	//	0x0000666c - 0x00006670

	// Continuation of Magic Number check (value read from EEPROM)
	reg0 = *(uint16_t)0x100009b6;
	if (reg0 != 0x0005) {
		// UNKNOWN PATHS execute instruction 0x00006672
	}


	// Firmware Offset(s): 
	//	0x00006676 - 0x00006676
	//	0x0000d790 - 0x0000d790
	//	0x00006cb0 - 0x00006cb2
	//	0x00004cd8 - 0x00004cde
	//	0x000021be - 0x000021c0
	//	0x000021b0 - 0x000021b2
	//	0x000021b4 - 0x000021ba
	//	0x000021bc - 0x000021bc

	// SRAM0 Initialization (this this might be heap space, even though it's so close to the stack...)
	*(uint8_t*)0x1000172f = 0x00;
	*(uint8_t*)0x10001730 = 0x00;
	*(uint8_t*)0x10001731 = 0x00;
	*(uint8_t*)0x10001732 = 0x00;
	*(uint8_t*)0x10001733 = 0x00;
	*(uint8_t*)0x10001734 = 0x00;
	*(uint8_t*)0x10001735 = 0x00;
	*(uint8_t*)0x10001736 = 0x00;
	*(uint8_t*)0x10001737 = 0x00;
	*(uint8_t*)0x10001738 = 0x00;
	*(uint8_t*)0x10001739 = 0x00;
	*(uint8_t*)0x1000173a = 0x00;
	*(uint8_t*)0x1000173b = 0x00;
	*(uint8_t*)0x1000173c = 0x00;
	*(uint8_t*)0x1000173d = 0x00;
	*(uint8_t*)0x1000173e = 0x00;
	*(uint8_t*)0x1000173f = 0x00;
	*(uint8_t*)0x10001740 = 0x00;
	*(uint8_t*)0x10001741 = 0x00;
	*(uint8_t*)0x10001742 = 0x00;
	*(uint8_t*)0x10001743 = 0x00;
	*(uint8_t*)0x10001744 = 0x00;
	*(uint8_t*)0x10001745 = 0x00;
	*(uint8_t*)0x10001746 = 0x00;
	*(uint8_t*)0x10001747 = 0x00;
	*(uint8_t*)0x10001748 = 0x00;
	*(uint8_t*)0x10001749 = 0x00;
	*(uint8_t*)0x1000174a = 0x00;
	*(uint8_t*)0x1000174b = 0x00;
	*(uint8_t*)0x1000174c = 0x00;
	*(uint8_t*)0x1000174d = 0x00;
	*(uint8_t*)0x1000174e = 0x00;
	*(uint8_t*)0x1000174f = 0x00;
	*(uint8_t*)0x10001750 = 0x00;
	*(uint8_t*)0x10001751 = 0x00;
	*(uint8_t*)0x10001752 = 0x00;
	*(uint8_t*)0x10001753 = 0x00;
	*(uint8_t*)0x10001754 = 0x00;
	*(uint8_t*)0x10001755 = 0x00;
	*(uint8_t*)0x10001756 = 0x00;
	*(uint8_t*)0x10001757 = 0x00;
	*(uint8_t*)0x10001758 = 0x00;
	*(uint8_t*)0x10001759 = 0x00;
	*(uint8_t*)0x1000175a = 0x00;
	*(uint8_t*)0x1000175b = 0x00;
	*(uint8_t*)0x1000175c = 0x00;
	*(uint8_t*)0x1000175d = 0x00;
	*(uint8_t*)0x1000175e = 0x00;
	*(uint8_t*)0x1000175f = 0x00;
	*(uint8_t*)0x10001760 = 0x00;
	*(uint8_t*)0x10001761 = 0x00;
	*(uint8_t*)0x10001762 = 0x00;
	*(uint8_t*)0x10001763 = 0x00;
	*(uint8_t*)0x10001764 = 0x00;
	*(uint8_t*)0x10001765 = 0x00;
	*(uint8_t*)0x10001766 = 0x00;
	*(uint8_t*)0x10001767 = 0x00;
	*(uint8_t*)0x10001768 = 0x00;
	*(uint8_t*)0x10001769 = 0x00;
	*(uint8_t*)0x1000176a = 0x00;
	*(uint8_t*)0x1000176b = 0x00;
	*(uint8_t*)0x1000176c = 0x00;
	*(uint8_t*)0x1000176d = 0x00;
	*(uint8_t*)0x1000176e = 0x00;
	*(uint8_t*)0x1000176f = 0x00;
	*(uint8_t*)0x10001770 = 0x00;
	*(uint8_t*)0x10001771 = 0x00;
	*(uint8_t*)0x10001772 = 0x00;
	*(uint8_t*)0x10001773 = 0x00;
	*(uint8_t*)0x10001774 = 0x00;
	*(uint8_t*)0x10001775 = 0x00;
	*(uint8_t*)0x10001776 = 0x00;
	*(uint8_t*)0x10001777 = 0x00;
	*(uint8_t*)0x10001778 = 0x00;
	*(uint8_t*)0x10001779 = 0x00;
	*(uint8_t*)0x1000177a = 0x00;
	*(uint8_t*)0x1000177b = 0x00;
	*(uint8_t*)0x1000177c = 0x00;
	*(uint8_t*)0x1000177d = 0x00;
	*(uint8_t*)0x1000177e = 0x00;
	*(uint8_t*)0x1000177f = 0x00;
	*(uint8_t*)0x10001780 = 0x00;
	*(uint8_t*)0x10001781 = 0x00;
	*(uint8_t*)0x10001782 = 0x00;
	*(uint8_t*)0x10001783 = 0x00;
	*(uint8_t*)0x10001784 = 0x00;
	*(uint8_t*)0x10001785 = 0x00;
	*(uint8_t*)0x10001786 = 0x00;
	*(uint8_t*)0x10001787 = 0x00;
	*(uint8_t*)0x10001788 = 0x00;
	*(uint8_t*)0x10001789 = 0x00;
	*(uint8_t*)0x1000178a = 0x00;
	*(uint8_t*)0x1000178b = 0x00;
	*(uint8_t*)0x1000178c = 0x00;
	*(uint8_t*)0x1000178d = 0x00;
	*(uint8_t*)0x1000178e = 0x00;
	*(uint8_t*)0x1000178f = 0x00;
	*(uint8_t*)0x10001790 = 0x00;
	*(uint8_t*)0x10001791 = 0x00;
	*(uint8_t*)0x10001792 = 0x00;
	*(uint8_t*)0x10001793 = 0x00;
	*(uint8_t*)0x10001794 = 0x00;
	*(uint8_t*)0x10001795 = 0x00;
	*(uint8_t*)0x10001796 = 0x00;
	*(uint8_t*)0x10001797 = 0x00;
	*(uint8_t*)0x10001798 = 0x00;
	*(uint8_t*)0x10001799 = 0x00;
	*(uint8_t*)0x1000179a = 0x00;
	*(uint8_t*)0x1000179b = 0x00;
	*(uint8_t*)0x1000179c = 0x00;
	*(uint8_t*)0x1000179d = 0x00;
	*(uint8_t*)0x1000179e = 0x00;
	*(uint8_t*)0x1000179f = 0x00;
	*(uint8_t*)0x100017a0 = 0x00;
	*(uint8_t*)0x100017a1 = 0x00;
	*(uint8_t*)0x100017a2 = 0x00;
	*(uint8_t*)0x100017a3 = 0x00;
	*(uint8_t*)0x100017a4 = 0x00;
	*(uint8_t*)0x100017a5 = 0x00;
	*(uint8_t*)0x100017a6 = 0x00;
	*(uint8_t*)0x100017a7 = 0x00;
	*(uint8_t*)0x100017a8 = 0x00;
	*(uint8_t*)0x100017a9 = 0x00;
	*(uint8_t*)0x100017aa = 0x00;
	*(uint8_t*)0x100017ab = 0x00;
	*(uint8_t*)0x100017ac = 0x00;
	*(uint8_t*)0x100017ad = 0x00;
	*(uint8_t*)0x100017ae = 0x00;
	*(uint8_t*)0x100017af = 0x00;
	*(uint8_t*)0x100017b0 = 0x00;
	*(uint8_t*)0x100017b1 = 0x00;
	*(uint8_t*)0x100017b2 = 0x00;
	*(uint8_t*)0x100017b3 = 0x00;
	*(uint8_t*)0x100017b4 = 0x00;
	*(uint8_t*)0x100017b5 = 0x00;
	*(uint8_t*)0x100017b6 = 0x00;
	*(uint8_t*)0x100017b7 = 0x00;
	*(uint8_t*)0x100017b8 = 0x00;
	*(uint8_t*)0x100017b9 = 0x00;
	*(uint8_t*)0x100017ba = 0x00;
	*(uint8_t*)0x100017bb = 0x00;
	*(uint8_t*)0x100017bc = 0x00;
	*(uint8_t*)0x100017bd = 0x00;
	*(uint8_t*)0x100017be = 0x00;
	*(uint8_t*)0x100017bf = 0x00;
	*(uint8_t*)0x100017c0 = 0x00;
	*(uint8_t*)0x100017c1 = 0x00;
	*(uint8_t*)0x100017c2 = 0x00;
	*(uint8_t*)0x100017c3 = 0x00;
	*(uint8_t*)0x100017c4 = 0x00;


	// Firmware Offset(s): 
	//	0x00004ce2 - 0x00004ce8

	// Clear SRAM0 value
	*(uint32_t*)0x100007b4 = 0x00000000	


	// Firmware Offset(s): 
	//	0x00006cb6 - 0x00006cb6
	//	0x0000d794 - 0x0000d794
	//	0x00009184 - 0x00009188
	//	0x00004cd8 - 0x00004cde
	//	0x000021be - 0x000021c0
	//	0x000021b0 - 0x000021b2
	//	0x000021b4 - 0x000021ba
	//	0x000021bc - 0x000021bc

	// Same SRAM0 Initialization as above... 
	//	*(uint8_t*)0x1000172f to *(uint8_t*)0x100017c4 set to 0 


	// Firmware Offset(s): 
	//	0x00004ce2 - 0x00004ce8

	// Clear SRAM0 value
	*(uint32_t*)0x100007b4 = 0x00000000	


	// Firmware Offset(s): 
	//	0x0000918c - 0x00009190
	//	0x000091b0 - 0x000091bc

	reg1 = *(uint32_t*)0x100007b4;
	reg1 += 0xe;
	if (reg1 > 0x32) {
		// Note this seems impossible given 0x100007b4 is set to 0 immediately before this check...
		// UNKNOWN PATHS execute 0x000091be 
	}


	// Firmware Offset(s): 
	//	0x000091c2 - 0x000091d2
	//	0x0000218c - 0x00002194
	//	0x000021a2 - 0x000021ac
	//	0x000021ae - 0x000021ae

	// Read hardcoded values and write to SRAM0
	*(uint8_t*)0x1000172f = 0x00
	*(uint8_t*)0x10001730 = 0x01
	*(uint8_t*)0x10001731 = 0x00
	*(uint8_t*)0x10001732 = 0x01
	*(uint8_t*)0x10001733 = 0x01
	*(uint8_t*)0x10001734 = 0x01
	*(uint8_t*)0x10001735 = 0x09
	*(uint8_t*)0x10001736 = 0x00
	*(uint8_t*)0x10001737 = 0x29
	*(uint8_t*)0x10001738 = 0x0b
	*(uint8_t*)0x10001739 = 0x00
	*(uint8_t*)0x1000173a = 0x2b
	*(uint8_t*)0x1000173b = 0x16
	*(uint8_t*)0x1000173c = 0x00
	*(uint8_t*)0x1000173d = 0x52
	*(uint8_t*)0x1000173e = 0x18
	*(uint8_t*)0x1000173f = 0x00
	*(uint8_t*)0x10001740 = 0x4f
	*(uint8_t*)0x10001741 = 0x1a
	*(uint8_t*)0x10001742 = 0x00
	*(uint8_t*)0x10001743 = 0x51
	*(uint8_t*)0x10001744 = 0x1c
	*(uint8_t*)0x10001745 = 0x00
	*(uint8_t*)0x10001746 = 0x50
	*(uint8_t*)0x10001747 = 0x05
	*(uint8_t*)0x10001748 = 0x00
	*(uint8_t*)0x10001749 = 0x28
	*(uint8_t*)0x1000174a = 0x03
	*(uint8_t*)0x1000174b = 0x00
	*(uint8_t*)0x1000174c = 0x29
	*(uint8_t*)0x1000174d = 0x10
	*(uint8_t*)0x1000174e = 0x00
	*(uint8_t*)0x1000174f = 0x52
	*(uint8_t*)0x10001750 = 0x11
	*(uint8_t*)0x10001751 = 0x00
	*(uint8_t*)0x10001752 = 0x4f
	*(uint8_t*)0x10001753 = 0x13
	*(uint8_t*)0x10001754 = 0x00
	*(uint8_t*)0x10001755 = 0x51
	*(uint8_t*)0x10001756 = 0x12
	*(uint8_t*)0x10001757 = 0x00
	*(uint8_t*)0x10001758 = 0x50


	// Firmware Offset(s): 
	//	0x000091d6 - 0x000091dc
	//	0x00009194 - 0x00009194

	// Increment some value in SRAM0 (TODO: still not sure on purpose for this...)
	*(uint32_t*)0x100007b4 += 0x0000000e


	// Firmware Offset(s): 
	//	0x00006d54 - 0x00006d5a
	//	0x000021be - 0x000021c0
	//	0x000021b0 - 0x000021b2
	//	0x000021b4 - 0x000021ba
	//	0x000021bc - 0x000021bc

	// Zero out some more of SRAM0 	
	*(uint8_t*)0x10001700 = 0x00
	*(uint8_t*)0x10001701 = 0x00
	*(uint8_t*)0x10001702 = 0x00
	*(uint8_t*)0x10001703 = 0x00
	*(uint8_t*)0x10001704 = 0x00
	*(uint8_t*)0x10001705 = 0x00
	*(uint8_t*)0x10001706 = 0x00
	*(uint8_t*)0x10001707 = 0x00
	*(uint8_t*)0x10001708 = 0x00
	*(uint8_t*)0x10001709 = 0x00
	*(uint8_t*)0x1000170a = 0x00
	*(uint8_t*)0x1000170b = 0x00
	*(uint8_t*)0x1000170c = 0x00
	*(uint8_t*)0x1000170d = 0x00
	*(uint8_t*)0x1000170e = 0x00
	*(uint8_t*)0x1000170f = 0x00
	*(uint8_t*)0x10001710 = 0x00
	*(uint8_t*)0x10001711 = 0x00
	*(uint8_t*)0x10001712 = 0x00
	*(uint8_t*)0x10001713 = 0x00
	*(uint8_t*)0x10001714 = 0x00
	*(uint8_t*)0x10001715 = 0x00
	*(uint8_t*)0x10001716 = 0x00
	*(uint8_t*)0x10001717 = 0x00
	*(uint8_t*)0x10001718 = 0x00
	*(uint8_t*)0x10001719 = 0x00
	*(uint8_t*)0x1000171a = 0x00
	*(uint8_t*)0x1000171b = 0x00
	*(uint8_t*)0x1000171c = 0x00
	*(uint8_t*)0x1000171d = 0x00
	*(uint8_t*)0x1000171e = 0x00
	*(uint8_t*)0x1000171f = 0x00
	*(uint8_t*)0x10001720 = 0x00
	*(uint8_t*)0x10001721 = 0x00
	*(uint8_t*)0x10001722 = 0x00
	*(uint8_t*)0x10001723 = 0x00
	*(uint8_t*)0x10001724 = 0x00
	*(uint8_t*)0x10001725 = 0x00
	*(uint8_t*)0x10001726 = 0x00
	*(uint8_t*)0x10001727 = 0x00
	*(uint8_t*)0x10001728 = 0x00
	*(uint8_t*)0x10001729 = 0x00
	*(uint8_t*)0x1000172a = 0x00
	*(uint8_t*)0x1000172b = 0x00
	*(uint8_t*)0x1000172c = 0x00
	*(uint8_t*)0x1000172d = 0x00
	*(uint8_t*)0x1000172e = 0x00


	// Firmware Offset(s): 
	//	0x00006d5e - 0x00006d5e
	//	0x00009198 - 0x0000919c
	//	0x00006d94 - 0x00006d9a
	//	0x00006db2 - 0x00006db6
	//	0x00006d9c - 0x00006da6
	//	0x00006db8 - 0x00006db8

	// Read a series of hardcoded values and accumulate some sums...
	...
	Reg4 = 0x00000027
	Reg3 = 0x0000ed03


	// Firmware Offset(s): 
	//	0x000091a0 - 0x000091a0
	//	0x0000d798 - 0x0000d79c
	//	0x00004f20 - 0x00004f26

	// Set an SRAM1 value
	*(uint32_t*)0x20000078 = 0x0000ed06


	// Firmware Offset(s): 
	//	0x00004f30 - 0x00004f48
	//	0x00004f4a - 0x00004f4a

	// Set some SRAM1 values based on hardcoded values
	*(uint16_t*)0x20000248 = 0x0008

	*(uint16_t*)0x2000024a = 0x0003
	*(uint16_t*)0x2000024c = 0x0159
	*(uint16_t*)0x2000024e = 0x04b0
	*(uint16_t*)0x20000250 = 0x0000
	*(uint16_t*)0x20000252 = 0x0000
	*(uint16_t*)0x20000254 = 0x0000
	*(uint16_t*)0x20000256 = 0x0003
	*(uint16_t*)0x20000258 = 0x0000
	*(uint16_t*)0x2000025a = 0x0001
	*(uint16_t*)0x2000025c = 0x1b58
	*(uint16_t*)0x2000025e = 0x0006
	*(uint16_t*)0x20000260 = 0x0005
	*(uint16_t*)0x20000262 = 0x0064
	*(uint16_t*)0x20000264 = 0x0032
	*(uint16_t*)0x20000266 = 0x039b
	*(uint16_t*)0x20000268 = 0x017e
	*(uint16_t*)0x2000026a = 0x0002
	*(uint16_t*)0x2000026c = 0x1f40
	*(uint16_t*)0x2000026e = 0xf830
	*(uint16_t*)0x20000270 = 0xf254
	*(uint16_t*)0x20000272 = 0x0005
	*(uint16_t*)0x20000274 = 0x0002
	*(uint16_t*)0x20000276 = 0x0002
	*(uint16_t*)0x20000278 = 0x000f
	*(uint16_t*)0x2000027a = 0x0fa0
	*(uint16_t*)0x2000027c = 0x0000
	*(uint16_t*)0x2000027e = 0x6b6c
	*(uint16_t*)0x20000280 = 0xf830
	*(uint16_t*)0x20000282 = 0xf254
	*(uint16_t*)0x20000284 = 0x0000
	*(uint16_t*)0x20000286 = 0x2ee0
	*(uint16_t*)0x20000288 = 0x0001
	*(uint16_t*)0x2000028a = 0x0fa0
	*(uint16_t*)0x2000028c = 0x00c8
	*(uint16_t*)0x2000028e = 0x0000
	*(uint16_t*)0x20000290 = 0x0000
	*(uint16_t*)0x20000292 = 0x012c
	*(uint16_t*)0x20000294 = 0x0032
	*(uint16_t*)0x20000296 = 0x0000
	*(uint16_t*)0x20000298 = 0x0014
	*(uint16_t*)0x2000029a = 0x0258
	*(uint16_t*)0x2000029c = 0x0000
	*(uint16_t*)0x2000029e = 0x0000
	*(uint16_t*)0x200002a0 = 0x0064
	*(uint16_t*)0x200002a2 = 0x0064
	*(uint16_t*)0x200002a4 = 0x0000
	*(uint16_t*)0x200002a6 = 0x0000
	*(uint16_t*)0x200002a8 = 0x0000
	*(uint16_t*)0x200002aa = 0x0002
	*(uint16_t*)0x200002ac = 0x0708
	*(uint16_t*)0x200002ae = 0x0000
	*(uint16_t*)0x200002b0 = 0x0000
	*(uint16_t*)0x200002b2 = 0x0000
	*(uint16_t*)0x200002b4 = 0x0000
	*(uint16_t*)0x200002b6 = 0x0000
	*(uint16_t*)0x200002b8 = 0x0000
	*(uint16_t*)0x200002ba = 0x0000
	*(uint16_t*)0x200002bc = 0x0000
	*(uint16_t*)0x200002be = 0x0000


	// Firmware Offset(s): 
	//	0x00004f2a - 0x00004f2a
	//	0x0000d7a0 - 0x0000d7a0
	//	0x000076c4 - 0x000076cc
	//	0x0000d7a4 - 0x0000d7a4

	// Clear some SRAM0 values
	*(uint32_t*)0x100010d4 = 0x00000000
	*(uint32_t*)0x100010d8 = 0x00000000


	// Firmware Offset(s): 
	//	0x00003060 - 0x00003066
	//	0x0000b7c8 - 0x0000b7d8
	//	0x00004200 - 0x0000420e

	// Set USB clock source to USB PLL out via USB clock source select register
	*(uint32_t*)0x400480c0 = 0x00000000	
	// Indicate No change for Enable USB clock source update via USB clock source update enable register
	*(uint32_t*)0x400480c4 = 0x00000000
	// Indicate Update clock source for Enable USB clock source update via USB clock source update enable register
	*(uint32_t*)0x400480c4 = 0x00000001
	// Set USB clock divider values to Divide by 1 via USB clock divider register
	*(uint32_t*)0x400480c8 = 0x00000001


	// Firmware Offset(s): 
	//	0x0000b7dc - 0x0000b7de
	//	0x0000452c - 0x00004540

	// Power USB PLL and USB transceiver via Power configuration register 
	reg1 = *(uint32_t*)0x40048238
	reg1 &= 0x000005ff
	reg1 &= ~0x00000500
	reg1 |= 0x0000e800	
	*(uint32_t*)0x40048238 = reg1


	// Firmware Offset(s): 
	//	0x0000b7e2 - 0x0000b7ee

	// Verify USB PLL is locked via USB PLL status register
	do {
		reg1 = (*uint32_t*)0x40048014
	} while (!reg1);
	

	// Firmware Offset(s): 
	//	0x0000411c - 0x00004128
	
	// Enable clock to the USB register interface via System clock control register
	reg2 = *(uint32_t*)0x40048080;
	reg2 |= 0x00004000;
	*(uint32_t*)0x40048080 = reg2;
	

	// Firmware Offset(s): 
	//	0x0000b7f2 - 0x0000b7f4
	//	0x0000411c - 0x00004128

	// Enable USB SRAM block at address 0x2000 4000 via System clock control register
	reg2 = *(uint32_t*)0x40048080;
	reg2 |= 0x08000000;
	*(uint32_t*)0x40048080 = reg2;
	

	// Firmware Offset(s): 
	//	0x0000b7f8 - 0x0000b800
	//	0x000043a4 - 0x000043a8
	//	0x000043b0 - 0x000043b2

	// Set PIO_3 to function as USB_VBUS and enable pull-down resistor
	*(uint32_t*)0x4004400c = 0x00000009;
	

	// Firmware Offset(s): 
	//	0x0000b804 - 0x0000b80c
	//	0x000043a4 - 0x000043a8
	//	0x000043b0 - 0x000043b2

	// Set PIO_6 to function as not(USB_CONNECT)
	*(uint32_t*)0x40044018 = 0x00000001;
	

	// Firmware Offset(s): 
	//	0x0000b810 - 0x0000b810
	//	0x0000306a - 0x00003078

	// Access boot ROM to get (const USBD_API_T *)LPC_ROM_API->usbdApiBase
	reg0 = *(uint32_t*)0x1fff1ff8; // = 0x1fff1eb8
	reg1 = *(uint32_t*)reg0; // = 0x1fff1f24
	*(uint32_t*)0x10000350 = reg1;
	

	// Firmware Offset(s): 
	//	0x000021be - 0x000021c0
	//	0x000021b0 - 0x000021b2
	//	0x000021b4 - 0x000021ba
	//	0x000021bc - 0x000021bc

	// Clear some SRAM0 values (stack?)
	*(uint8_t*)0x10001f60 = 0x00
	*(uint8_t*)0x10001f61 = 0x00
	*(uint8_t*)0x10001f62 = 0x00
	*(uint8_t*)0x10001f63 = 0x00
	*(uint8_t*)0x10001f64 = 0x00
	*(uint8_t*)0x10001f65 = 0x00
	*(uint8_t*)0x10001f66 = 0x00
	*(uint8_t*)0x10001f67 = 0x00
	*(uint8_t*)0x10001f68 = 0x00
	*(uint8_t*)0x10001f69 = 0x00
	*(uint8_t*)0x10001f6a = 0x00
	*(uint8_t*)0x10001f6b = 0x00
	*(uint8_t*)0x10001f6c = 0x00
	*(uint8_t*)0x10001f6d = 0x00
	*(uint8_t*)0x10001f6e = 0x00
	*(uint8_t*)0x10001f6f = 0x00
	*(uint8_t*)0x10001f70 = 0x00
	*(uint8_t*)0x10001f71 = 0x00
	*(uint8_t*)0x10001f72 = 0x00
	*(uint8_t*)0x10001f73 = 0x00
	*(uint8_t*)0x10001f74 = 0x00
	*(uint8_t*)0x10001f75 = 0x00
	*(uint8_t*)0x10001f76 = 0x00
	*(uint8_t*)0x10001f77 = 0x00
	*(uint8_t*)0x10001f78 = 0x00
	*(uint8_t*)0x10001f79 = 0x00
	*(uint8_t*)0x10001f7a = 0x00
	*(uint8_t*)0x10001f7b = 0x00
	*(uint8_t*)0x10001f7c = 0x00
	*(uint8_t*)0x10001f7d = 0x00
	*(uint8_t*)0x10001f7e = 0x00
	*(uint8_t*)0x10001f7f = 0x00
	*(uint8_t*)0x10001f80 = 0x00
	*(uint8_t*)0x10001f81 = 0x00
	*(uint8_t*)0x10001f82 = 0x00
	*(uint8_t*)0x10001f83 = 0x00
	*(uint8_t*)0x10001f84 = 0x00
	*(uint8_t*)0x10001f85 = 0x00
	*(uint8_t*)0x10001f86 = 0x00
	*(uint8_t*)0x10001f87 = 0x00
	*(uint8_t*)0x10001f88 = 0x00
	*(uint8_t*)0x10001f89 = 0x00
	*(uint8_t*)0x10001f8a = 0x00
	*(uint8_t*)0x10001f8b = 0x00
	*(uint8_t*)0x10001f8c = 0x00
	*(uint8_t*)0x10001f8d = 0x00
	*(uint8_t*)0x10001f8e = 0x00
	*(uint8_t*)0x10001f8f = 0x00
	*(uint8_t*)0x10001f90 = 0x00
	*(uint8_t*)0x10001f91 = 0x00
	*(uint8_t*)0x10001f92 = 0x00
	*(uint8_t*)0x10001f93 = 0x00
	*(uint8_t*)0x10001f94 = 0x00
	*(uint8_t*)0x10001f95 = 0x00
	*(uint8_t*)0x10001f96 = 0x00
	*(uint8_t*)0x10001f97 = 0x00
	*(uint8_t*)0x10001f98 = 0x00
	*(uint8_t*)0x10001f99 = 0x00
	*(uint8_t*)0x10001f9a = 0x00
	*(uint8_t*)0x10001f9b = 0x00
	*(uint8_t*)0x10001f9c = 0x00
	*(uint8_t*)0x10001f9d = 0x00
	*(uint8_t*)0x10001f9e = 0x00
	*(uint8_t*)0x10001f9f = 0x00
	*(uint8_t*)0x10001fa0 = 0x00
	*(uint8_t*)0x10001fa1 = 0x00
	*(uint8_t*)0x10001fa2 = 0x00
	*(uint8_t*)0x10001fa3 = 0x00


	// Firmware Offset(s): 
	//	0x0000307c - 0x000030bc

	// Fill in USBD_API_INIT_PARAM_T
	*(uint32_t*)0x10001f60 = 0x40080000 // usb_reg_base - USB device controller's base register address
	*(uint32_t*)0x10001f64 = 0x20004000// mem_base - Base memory location from where the stack can allocate
		// data and buffers. \note The memory address set in this field
		// should be accessible by USB DMA controller. Also this value
		// should be aligned on 2048 byte boundary 
	*(uint32_t*)0x10001f68 = 0x00000800 // mem_size - The size of memory buffer which stack can use.       
                      // \note The \em mem_size should be greater than the size    
                      // returned by USBD_HW_API::GetMemSize() routine
	*(uint32_t*)0x10001f6C = 0x00000005 // max_num_ep - max number of endpoints supported by the USB device  
                      // controller instance (specified by \em usb_reg_base field) 
                      // to which this instance of stack is attached.

	*(uint32_t*)0x10001f70 = 0x00008d8b // USB_Reset_Event - USB Device Events Callback Function
	*(uint32_t*)0x10001f74 = 0x0000995d // USB_Suspend_Event - USB Device Events Callback Function
	*(uint32_t*)0x10001f78 = 0x00008de5 // USB_Resume_Event - USB Device Events Callback Function
	*(uint32_t*)0x10001f7C = 0x00000000 // reserved_sbz 

	*(uint32_t*)0x10001f80 = 0x00000000 // USB_SOF_Event - USB Device Events Callback Function
	*(uint32_t*)0x10001f84 = 0x00000000 // USB_WakeUpCfg 
	*(uint32_t*)0x10001f88 = 0x00000000 // USB_Power_Event
	*(uint32_t*)0x10001f8C = 0x00000000 // USB_Error_Event

	*(uint32_t*)0x10001f90 = 0x00004e59 // USB_Configure_Event
	*(uint32_t*)0x10001f94 = 0x00000000 // USB_Interface_Event
	*(uint32_t*)0x10001f98 = 0x00000000 // USB_Feature_Event
	*(uint32_t*)0x10001f9C = 0x00000000 // Reserved for future use, should be set to 0

	*(uint32_t*)0x10001fA0 = 0x00000000 // Reserved for future use, should be set to 0

	// Fill in USB_CORE_DESCS_T
	*(uint32_t*)0x10001fa4 = 0x0000ef14 // device_desc - Pointer to USB device descriptor
	*(uint32_t*)0x10001fa8 = 0x0000ef86 // string_desc - Pointer to array of USB string descriptors
	*(uint32_t*)0x10001fac = 0x0000ef28 // full_speed_desc - Pointer to USB device configuration descriptor 
                            // when device is operating in full speed mode
	*(uint32_t*)0x10001fb0 = 0x0000ef28 // high_speed_desc - Pointer to USB device configuration descriptor 
                            // when device is operating in high speed mode. For  
                            // full-speed only implementation this pointer should
                            // be same as full_speed_desc.
	*(uint32_t*)0x10001fb4 = 0x00000000 // device_qualifier; /**< Pointer to USB device qualifier descriptor. For
                            // full-speed only implementation this pointer should
                            // be set to null (0).

	reg0 = *(uint32_t*)0x1fff1f24; // = 0x1fff1f80
	reg3 = *(uint32_t)0x1fff1f84; // = 0x1fff351d

	reg0 = 0x1000034c;
	reg1 = 0x10001fa4;
	reg2 = 0x10001f60;


	// Firmware Offset(s): 
	//	0x1fff351c - ...
	//	...        - 0x1fff35ce

	// \param[in,out] phUsb Pointer to the USB device stack handle of type USBD_HANDLE_T.
	// \param[in]  pDesc Structure containing pointers to various descriptor arrays needed by the stack.
	// 		  These descriptors are reported to USB host as part of enumerations process.
	// \param[in]  param Structure containing USB device stack initialization parameters.
	// \return Returns \ref ErrorCode_t type to indicate success or error condition.
	// 	\retval LPC_OK(0) On success                                      
	// 	\retval ERR_USBD_BAD_MEM_BUF(0x0004000b) When insufficient memory buffer is passed or memory
        //                                    is not aligned on 2048 boundary.
	retval = USBD_HW_API->Init(USBD_HANDLE_T* phUsb = 0x1000034c, USB_CORE_DESCS_T* pDesc = 0x10001fa4, USBD_API_INIT_PARAM_T* param = 0x10001f60)


	// Firmware Offset(s): 
	//	0x000030be - 0x000030c0
	//	0x000030c2 - 0x000030dc

	// Check that USBD_HW_API->Init() return value is LPC_OK(0)
	if (retval != LPC_OK) {
		//	UNKNOWN PATHS branch to 0x000030d4 
	}

	// Read USBD_API_INIT_PARAM_T->mem_size
	reg0 = *(uint32_t*)0x10001f68;
	*(uint32_t*)0x10000358 = reg0;

	// Track how much of stack space is left for when next USB device/ep is added
	*(uint32_t*)0x10000354 = 0x20004800 - reg0;

	// Enable interrupt 22 (USB_IRQ) via Interrupt Set-enable Register
	*(uint32_t*)0xe000e100 = 0x00400000;


	// Firmware Offset(s): 
	//	0x000055e8 - 0x000055f2
	//	0x00005434 - 0x0000543e
	//	0x00005448 - 0x00005448

	reg2 = *(uint32_t)0x100010b4;
	if (reg2 != 0) {
		// UNKNOWN PATHS execute 0x00005440
	}


	// Firmware Offset(s): 
	//	0x000055f6 - 0x00005600
	//	0x0000454c - 0x0000455a

	// Some math to calculate which pin interrupt to enable
	reg1 = *(uint32_t*)0x10001f3c;
	reg1 *= 0x18;
	reg1 += reg2;
	...

	// Set PIO_3 (USB_VBUS) as INTPIN via Pin interrupt select register PINTSEL0
	//	Interrupt to react to USB cable being plugged in most likely
	*(uint32_t*)0x40048178 = 0x00000003;


	// Firmware Offset(s): 
	//	0x00005604 - 0x00005616

	// Set PSTAT (clear rising- and falling-edge detection for this pin (PIO_3?)) via Pin interrupt status register
	*(uint32_t*)0x4004c024 = 0x00000001;
	// Set SETENRL (Enable rising edge or level interrupt (for PIO_3?)) via Pin interrupt level (rising edge) interrupt set register	
	*(uint32_t*)0x4004c008 = 0x00000001;


	// Firmware Offset(s): 
	//	0x000044f8 - 0x00004504

	// Enable PINT0 via Interrupt wake-up enable register 0
	reg2 = *(uint32_t*)0x40048204;
	reg2 |= 1;
	*(uint32_t*)0x40048204 = reg2;


	// Firmware Offset(s): 
	//	0x0000561a - 0x00005630
	//	0x000030e0 - 0x000030e2
	//	0x0000d7a8 - 0x0000d7a8

	// Set with hardcoded value now that USB has started to occur?
	*(uint32_t*)0x100010b4 = 0x0000a87d

	// Remove pending state an interrupt 0 (PINT0) via Interrupt Clear-pending Register
	*(uint32_t*)0xe000e280 = 0x00000001;
	// Enable interrupt 0 (PINT0) via Interrupt Set-enable Register
	*(uint32_t*)0xe000e100 = 0x00000001;


	// Firmware Offset(s): 
	//	0x00006534 - 0x00006554

	// Set some SRAM0 value
	*(uint32_t*)0x10000088 = 0x00000000;
	*(uint32_t*)0x1000008c = 0x00000000;
	// USB_HID_REPORT_T
	*(uint16_t*)0x10000080 = 0x0041;
	*(uint8_t*)0x10000082 = 0x00;
	*(uint32_t*)0x10000084 = 0x0000eeaa;


	// Firmware Offset(s): 
	//	0x000021be - 0x000021c0
	//	0x000021b0 - 0x000021b2
	//	0x000021b4 - 0x000021ba
	//	0x000021bc - 0x000021bc

	// Clear some SRAM0 values
	*(uint8_t*)0x10001f88 = 0x00
	*(uint8_t*)0x10001f89 = 0x00
	*(uint8_t*)0x10001f8a = 0x00
	*(uint8_t*)0x10001f8b = 0x00
	*(uint8_t*)0x10001f8c = 0x00
	*(uint8_t*)0x10001f8d = 0x00
	*(uint8_t*)0x10001f8e = 0x00
	*(uint8_t*)0x10001f8f = 0x00
	*(uint8_t*)0x10001f90 = 0x00
	*(uint8_t*)0x10001f91 = 0x00
	*(uint8_t*)0x10001f92 = 0x00
	*(uint8_t*)0x10001f93 = 0x00
	*(uint8_t*)0x10001f94 = 0x00
	*(uint8_t*)0x10001f95 = 0x00
	*(uint8_t*)0x10001f96 = 0x00
	*(uint8_t*)0x10001f97 = 0x00
	*(uint8_t*)0x10001f98 = 0x00
	*(uint8_t*)0x10001f99 = 0x00
	*(uint8_t*)0x10001f9a = 0x00
	*(uint8_t*)0x10001f9b = 0x00
	*(uint8_t*)0x10001f9c = 0x00
	*(uint8_t*)0x10001f9d = 0x00
	*(uint8_t*)0x10001f9e = 0x00
	*(uint8_t*)0x10001f9f = 0x00
	*(uint8_t*)0x10001fa0 = 0x00
	*(uint8_t*)0x10001fa1 = 0x00
	*(uint8_t*)0x10001fa2 = 0x00
	*(uint8_t*)0x10001fa3 = 0x00
	*(uint8_t*)0x10001fa4 = 0x00
	*(uint8_t*)0x10001fa5 = 0x00
	*(uint8_t*)0x10001fa6 = 0x00
	*(uint8_t*)0x10001fa7 = 0x00
	*(uint8_t*)0x10001fa8 = 0x00
	*(uint8_t*)0x10001fa9 = 0x00
	*(uint8_t*)0x10001faa = 0x00
	*(uint8_t*)0x10001fab = 0x00
	*(uint8_t*)0x10001fac = 0x00
	*(uint8_t*)0x10001fad = 0x00
	*(uint8_t*)0x10001fae = 0x00
	*(uint8_t*)0x10001faf = 0x00
	*(uint8_t*)0x10001fb0 = 0x00
	*(uint8_t*)0x10001fb1 = 0x00
	*(uint8_t*)0x10001fb2 = 0x00
	*(uint8_t*)0x10001fb3 = 0x00
	*(uint8_t*)0x10001fb4 = 0x00
	*(uint8_t*)0x10001fb5 = 0x00
	*(uint8_t*)0x10001fb6 = 0x00
	*(uint8_t*)0x10001fb7 = 0x00
	*(uint8_t*)0x10001fb8 = 0x00
	*(uint8_t*)0x10001fb9 = 0x00
	*(uint8_t*)0x10001fba = 0x00
	*(uint8_t*)0x10001fbb = 0x00
	*(uint8_t*)0x10001fbc = 0x00
	*(uint8_t*)0x10001fbd = 0x00
	*(uint8_t*)0x10001fbe = 0x00
	*(uint8_t*)0x10001fbf = 0x00


	// Firmware Offset(s): 
	//	0x00006558 - 0x00006568
	//	0x0000300c - 0x0000301a
	//	0x00003022 - 0x00003042

	// Designating this USB_HID0 (appears as genric keyboard with Steam driver):

	// USBD_HID_INIT_PARAM_T
	*(uint32_t*)0x10001f88 = *(uint32_t*)0x10000354; // = 0x200044c0 // mem_base - Base memory location from where the stack can allocate
                      // data and buffers. \note The memory address set in this field
                      // should be accessible by USB DMA controller. Also this value
                      // should be aligned on 4 byte boundary
	*(uint32_t*)0x10001f8c = *(uint32_t*)0x10000358; // = 0x00000340 // mem_size - The size of memory buffer which stack can use.       
                      // \note The \em mem_size should be greater than the size    
                      // returned by USBD_HID_API::GetMemSize() routine.
	*(uint8_t*)0x10001f90 = 0x00000001; // max_reports - Number of HID reports supported by this instance    
                      // of HID class driver
	*(uint32_t*)0x10001f94 = 0x0000ef31; // intf_desc - Pointer to the HID interface descriptor within the   
                      // descriptor array (\em high_speed_desc) passed to Init()   
                      // through \ref USB_CORE_DESCS_T structure.
	*(uint32_t*)0x10001f98 = 0x10000080; // report_dataa - Pointer to an array of HID report descriptor
                      // data structure (\ref USB_HID_REPORT_T). The number
                      // of elements in the array should be same a \em max_reports
                      // value. The stack uses this array to respond to 
                      // requests received for various HID report descriptor
                      // information. \note This array should be of global scope
	*(uint32_t*)0x10001f9c = 0x00005a91; // HID_GetReport
	*(uint32_t*)0x10001fa0 = 0x0000951d; // HID_SetReport

	reg0 = *(uint32_t*)0x10000350; // = 0x1fff1f24	
	reg0 = *(uint32_t*)0x1fff1f34; // = 0x1fff1f78 // *(uing32_t*)(reg0 + 0x10)???
	reg2 = *(uint32_t*)0x1fff1f7c; // = 0x1fff2cfd // *(uint32_t*)(reg0 + 4)???
	
	reg0 = (uint32_t*)0x1000034c; // 0x20004118
	reg1 = 0x10001f88;


	// Firmware Offset(s): 
	//	0x1fff2cfc - ...
	//	...        - 0x1fff2cee

	// \param[in] hUsb Handle to the USB device stack.                           
	// \param[in, out] param Structure containing HID function driver module     
	//     initialization parameters.                                            
	// \return Returns \ref ErrorCode_t type to indicate success or error condition.
	// 	\retval LPC_OK On success                                         
	// 	\retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte  
	// 	    aligned or smaller than required.                             
	// 	\retval ERR_API_INVALID_PARAM2 Either HID_GetReport() or HID_SetReport()
	// 	    callback are not defined.                                     
	// 	\retval ERR_USBD_BAD_DESC  HID_HID_DESCRIPTOR_TYPE is not defined 
	// 	    immediately after interface descriptor.                       
	// 	\retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
	// 	\retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
	USBD_HID_API_T->init(USBD_HANDLE_T hUsb = 0x20004118, USBD_HID_INIT_PARAM_T* param = 0x10001f88)


	// Firmware Offset(s): 
	//	0x00003044 - 0x0000304c
	//	0x0000656c - 0x0000656e
	//	0x0000d7ac - 0x0000d7ac

	// Update global mem_base after USBD_HID_API_T->init()
	*(uint32_t*)0x10000354 = *(uint32_t*)0x10001f88; // = 0x200044f0
	// Update last mem_size after USBD_HID_API_T->init()
	*(uint32_t*)0x10000358 = *(uint32_t*)0x10001f8c; // = 0x00000310


	// Firmware Offset(s): 
	//	0x00007268 - 0x00007286

	*(uint32_t*)0x10000364 = 0x00000000
	// USB_HID_REPORT_T
	*(uint16_t*)0x10000368 = 0x0034;
	*(uint8_t*)0x1000036a = 0x00;
	*(uint32_t*)0x1000036c = 0x0000ee74;


	// Firmware Offset(s): 
	//	0x000021be - 0x000021c0
	//	0x000021b0 - 0x000021b2
	//	0x000021b4 - 0x000021ba
	//	0x000021bc - 0x000021bc

	// Clear some SRAM0 values
	*(uint8_t*)0x10001f88 = 0x00
	*(uint8_t*)0x10001f89 = 0x00
	*(uint8_t*)0x10001f8a = 0x00
	*(uint8_t*)0x10001f8b = 0x00
	*(uint8_t*)0x10001f8c = 0x00
	*(uint8_t*)0x10001f8d = 0x00
	*(uint8_t*)0x10001f8e = 0x00
	*(uint8_t*)0x10001f8f = 0x00
	*(uint8_t*)0x10001f90 = 0x00
	*(uint8_t*)0x10001f91 = 0x00
	*(uint8_t*)0x10001f92 = 0x00
	*(uint8_t*)0x10001f93 = 0x00
	*(uint8_t*)0x10001f94 = 0x00
	*(uint8_t*)0x10001f95 = 0x00
	*(uint8_t*)0x10001f96 = 0x00
	*(uint8_t*)0x10001f97 = 0x00
	*(uint8_t*)0x10001f98 = 0x00
	*(uint8_t*)0x10001f99 = 0x00
	*(uint8_t*)0x10001f9a = 0x00
	*(uint8_t*)0x10001f9b = 0x00
	*(uint8_t*)0x10001f9c = 0x00
	*(uint8_t*)0x10001f9d = 0x00
	*(uint8_t*)0x10001f9e = 0x00
	*(uint8_t*)0x10001f9f = 0x00
	*(uint8_t*)0x10001fa0 = 0x00
	*(uint8_t*)0x10001fa1 = 0x00
	*(uint8_t*)0x10001fa2 = 0x00
	*(uint8_t*)0x10001fa3 = 0x00
	*(uint8_t*)0x10001fa4 = 0x00
	*(uint8_t*)0x10001fa5 = 0x00
	*(uint8_t*)0x10001fa6 = 0x00
	*(uint8_t*)0x10001fa7 = 0x00
	*(uint8_t*)0x10001fa8 = 0x00
	*(uint8_t*)0x10001fa9 = 0x00
	*(uint8_t*)0x10001faa = 0x00
	*(uint8_t*)0x10001fab = 0x00
	*(uint8_t*)0x10001fac = 0x00
	*(uint8_t*)0x10001fad = 0x00
	*(uint8_t*)0x10001fae = 0x00
	*(uint8_t*)0x10001faf = 0x00
	*(uint8_t*)0x10001fb0 = 0x00
	*(uint8_t*)0x10001fb1 = 0x00
	*(uint8_t*)0x10001fb2 = 0x00
	*(uint8_t*)0x10001fb3 = 0x00
	*(uint8_t*)0x10001fb4 = 0x00
	*(uint8_t*)0x10001fb5 = 0x00
	*(uint8_t*)0x10001fb6 = 0x00
	*(uint8_t*)0x10001fb7 = 0x00
	*(uint8_t*)0x10001fb8 = 0x00
	*(uint8_t*)0x10001fb9 = 0x00
	*(uint8_t*)0x10001fba = 0x00
	*(uint8_t*)0x10001fbb = 0x00
	*(uint8_t*)0x10001fbc = 0x00
	*(uint8_t*)0x10001fbd = 0x00
	*(uint8_t*)0x10001fbe = 0x00
	*(uint8_t*)0x10001fbf = 0x00


	// Firmware Offset(s): 
	//	0x0000728a - 0x0000729c
	//	0x0000300c - 0x0000301a
	//	0x00003022 - 0x00003042

	// Designating this USB_HID1 (appears as generic mouse with Steam driver):

	// USBD_HID_INIT_PARAM_T
	*(uint32_t*)0x10001f88 = *(uint32_t*)0x10000354; // = 0x200044f0 // mem_base - Base memory location from where the stack can allocate
                      // data and buffers. \note The memory address set in this field
                      // should be accessible by USB DMA controller. Also this value
                      // should be aligned on 4 byte boundary
	*(uint32_t*)0x10001f8c = *(uint32_t*)0x10000358; // = 0x00000310 // mem_size - The size of memory buffer which stack can use.       
                      // \note The \em mem_size should be greater than the size    
                      // returned by USBD_HID_API::GetMemSize() routine.
	*(uint8_t*)0x10001f90 = 0x00000001; // max_reports - Number of HID reports supported by this instance    
                      // of HID class driver
	*(uint32_t*)0x10001f94 = 0x0000ef4a; // intf_desc - Pointer to the HID interface descriptor within the   
                      // descriptor array (\em high_speed_desc) passed to Init()   
                      // through \ref USB_CORE_DESCS_T structure.
	*(uint32_t*)0x10001f98 = 0x10000368; // report_dataa - Pointer to an array of HID report descriptor
                      // data structure (\ref USB_HID_REPORT_T). The number
                      // of elements in the array should be same a \em max_reports
                      // value. The stack uses this array to respond to 
                      // requests received for various HID report descriptor
                      // information. \note This array should be of global scope
	*(uint32_t*)0x10001f9c = 0x00005ac1; // HID_GetReport
	*(uint32_t*)0x10001fa0 = 0x00009549; // HID_SetReport

	reg0 = *(uint32_t*)0x10000350; // = 0x1fff1f24	
	reg0 = *(uint32_t*)0x1fff1f34; // = 0x1fff1f78 // *(uing32_t*)(reg0 + 0x10)???
	reg2 = *(uint32_t*)0x1fff1f7c; // = 0x1fff2cfd // *(uint32_t*)(reg0 + 4)???
	
	reg0 = (uint32_t*)0x1000034c; // 0x20004118
	reg1 = 0x10001f88;


	// Firmware Offset(s): 
	//	0x1fff2cfc - ...
	//	...        - 0x1fff2cee

	// \param[in] hUsb Handle to the USB device stack.                           
	// \param[in, out] param Structure containing HID function driver module     
	//     initialization parameters.                                            
	// \return Returns \ref ErrorCode_t type to indicate success or error condition.
	// 	\retval LPC_OK On success                                         
	// 	\retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte  
	// 	    aligned or smaller than required.                             
	// 	\retval ERR_API_INVALID_PARAM2 Either HID_GetReport() or HID_SetReport()
	// 	    callback are not defined.                                     
	// 	\retval ERR_USBD_BAD_DESC  HID_HID_DESCRIPTOR_TYPE is not defined 
	// 	    immediately after interface descriptor.                       
	// 	\retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
	// 	\retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
	USBD_HID_API_T->init(USBD_HANDLE_T hUsb = 0x20004118, USBD_HID_INIT_PARAM_T* param = 0x10001f88)


	// Firmware Offset(s): 
	//	0x00003044 - 0x0000304c
	//	0x000072a0 - 0x000072a2
	//	0x0000d7b0 - 0x0000d7b2

	// Update global mem_base after USBD_HID_API_T->init()
	*(uint32_t*)0x10000354 = *(uint32_t*)0x10001f88; // = 0x20004520
	// Update last mem_size after USBD_HID_API_T->init()
	*(uint32_t*)0x10000358 = *(uint32_t*)0x10001f8c; // = 0x000002e0


	// Firmware Offset(s): 
	//	0x00006058 - 0x00006062
	//	0x000021be - 0x000021c0
	//	0x000021b0 - 0x000021b2
	//	0x000021b4 - 0x000021ba
	//	0x000021bc - 0x000021bc

	// Clear some SRAM0 values
	*(uint8_t*)0x10001140 = 0x00
	*(uint8_t*)0x10001141 = 0x00
	*(uint8_t*)0x10001142 = 0x00
	*(uint8_t*)0x10001143 = 0x00
	*(uint8_t*)0x10001144 = 0x00
	*(uint8_t*)0x10001145 = 0x00
	*(uint8_t*)0x10001146 = 0x00
	*(uint8_t*)0x10001147 = 0x00
	*(uint8_t*)0x10001148 = 0x00
	*(uint8_t*)0x10001149 = 0x00
	*(uint8_t*)0x1000114a = 0x00
	*(uint8_t*)0x1000114b = 0x00
	*(uint8_t*)0x1000114c = 0x00
	*(uint8_t*)0x1000114d = 0x00
	*(uint8_t*)0x1000114e = 0x00
	*(uint8_t*)0x1000114f = 0x00
	*(uint8_t*)0x10001150 = 0x00
	*(uint8_t*)0x10001151 = 0x00
	*(uint8_t*)0x10001152 = 0x00
	*(uint8_t*)0x10001153 = 0x00
	*(uint8_t*)0x10001154 = 0x00
	*(uint8_t*)0x10001155 = 0x00
	*(uint8_t*)0x10001156 = 0x00
	*(uint8_t*)0x10001157 = 0x00
	*(uint8_t*)0x10001158 = 0x00
	*(uint8_t*)0x10001159 = 0x00
	*(uint8_t*)0x1000115a = 0x00
	*(uint8_t*)0x1000115b = 0x00
	*(uint8_t*)0x1000115c = 0x00
	*(uint8_t*)0x1000115d = 0x00
	*(uint8_t*)0x1000115e = 0x00
	*(uint8_t*)0x1000115f = 0x00
	*(uint8_t*)0x10001160 = 0x00
	*(uint8_t*)0x10001161 = 0x00
	*(uint8_t*)0x10001162 = 0x00
	*(uint8_t*)0x10001163 = 0x00
	*(uint8_t*)0x10001164 = 0x00
	*(uint8_t*)0x10001165 = 0x00
	*(uint8_t*)0x10001166 = 0x00
	*(uint8_t*)0x10001167 = 0x00
	*(uint8_t*)0x10001168 = 0x00
	*(uint8_t*)0x10001169 = 0x00
	*(uint8_t*)0x1000116a = 0x00
	*(uint8_t*)0x1000116b = 0x00
	*(uint8_t*)0x1000116c = 0x00
	*(uint8_t*)0x1000116d = 0x00
	*(uint8_t*)0x1000116e = 0x00
	*(uint8_t*)0x1000116f = 0x00
	*(uint8_t*)0x10001170 = 0x00
	*(uint8_t*)0x10001171 = 0x00
	*(uint8_t*)0x10001172 = 0x00
	*(uint8_t*)0x10001173 = 0x00
	*(uint8_t*)0x10001174 = 0x00
	*(uint8_t*)0x10001175 = 0x00
	*(uint8_t*)0x10001176 = 0x00
	*(uint8_t*)0x10001177 = 0x00
	*(uint8_t*)0x10001178 = 0x00
	*(uint8_t*)0x10001179 = 0x00
	*(uint8_t*)0x1000117a = 0x00
	*(uint8_t*)0x1000117b = 0x00
	*(uint8_t*)0x1000117c = 0x00
	*(uint8_t*)0x1000117d = 0x00
	*(uint8_t*)0x1000117e = 0x00
	*(uint8_t*)0x1000117f = 0x00


	// Firmware Offset(s): 
	//	0x00006066 - 0x0000606a
	//	0x00007c90 - 0x00007c92
	//	0x00009ab8 - 0x00009abc
	//	0x00007c96 - 0x00007c9a
	//	0x0000606e - 0x00006084 

	*(uint32_t*)0x10000380 = 0x00003161;

	reg0 = *(uint32_t*)0x10000338;

	*(uint32_t*)0x100002c8 = reg0;

	// USB_HID_REPORT_T
	*(uint16_t*)0x10000390 = 0x0021;
	*(uint8_t*)0x10000392 = 0x00;
	*(uint32_t*)0x10000394 = 0x0000eeee;


	// Firmware Offset(s): 
	//	0x000021be - 0x000021c0
	//	0x000021b0 - 0x000021b2
	//	0x000021b4 - 0x000021ba
	//	0x000021bc - 0x000021bc

	// Clear some SRAM0 values
	*(uint8_t*)0x10001f80 = 0x00
	*(uint8_t*)0x10001f81 = 0x00
	*(uint8_t*)0x10001f82 = 0x00
	*(uint8_t*)0x10001f83 = 0x00
	*(uint8_t*)0x10001f84 = 0x00
	*(uint8_t*)0x10001f85 = 0x00
	*(uint8_t*)0x10001f86 = 0x00
	*(uint8_t*)0x10001f87 = 0x00
	*(uint8_t*)0x10001f88 = 0x00
	*(uint8_t*)0x10001f89 = 0x00
	*(uint8_t*)0x10001f8a = 0x00
	*(uint8_t*)0x10001f8b = 0x00
	*(uint8_t*)0x10001f8c = 0x00
	*(uint8_t*)0x10001f8d = 0x00
	*(uint8_t*)0x10001f8e = 0x00
	*(uint8_t*)0x10001f8f = 0x00
	*(uint8_t*)0x10001f90 = 0x00
	*(uint8_t*)0x10001f91 = 0x00
	*(uint8_t*)0x10001f92 = 0x00
	*(uint8_t*)0x10001f93 = 0x00
	*(uint8_t*)0x10001f94 = 0x00
	*(uint8_t*)0x10001f95 = 0x00
	*(uint8_t*)0x10001f96 = 0x00
	*(uint8_t*)0x10001f97 = 0x00
	*(uint8_t*)0x10001f98 = 0x00
	*(uint8_t*)0x10001f99 = 0x00
	*(uint8_t*)0x10001f9a = 0x00
	*(uint8_t*)0x10001f9b = 0x00
	*(uint8_t*)0x10001f9c = 0x00
	*(uint8_t*)0x10001f9d = 0x00
	*(uint8_t*)0x10001f9e = 0x00
	*(uint8_t*)0x10001f9f = 0x00
	*(uint8_t*)0x10001fa0 = 0x00
	*(uint8_t*)0x10001fa1 = 0x00
	*(uint8_t*)0x10001fa2 = 0x00
	*(uint8_t*)0x10001fa3 = 0x00
	*(uint8_t*)0x10001fa4 = 0x00
	*(uint8_t*)0x10001fa5 = 0x00
	*(uint8_t*)0x10001fa6 = 0x00
	*(uint8_t*)0x10001fa7 = 0x00
	*(uint8_t*)0x10001fa8 = 0x00
	*(uint8_t*)0x10001fa9 = 0x00
	*(uint8_t*)0x10001faa = 0x00
	*(uint8_t*)0x10001fab = 0x00
	*(uint8_t*)0x10001fac = 0x00
	*(uint8_t*)0x10001fad = 0x00
	*(uint8_t*)0x10001fae = 0x00
	*(uint8_t*)0x10001faf = 0x00
	*(uint8_t*)0x10001fb0 = 0x00
	*(uint8_t*)0x10001fb1 = 0x00
	*(uint8_t*)0x10001fb2 = 0x00
	*(uint8_t*)0x10001fb3 = 0x00
	*(uint8_t*)0x10001fb4 = 0x00
	*(uint8_t*)0x10001fb5 = 0x00
	*(uint8_t*)0x10001fb6 = 0x00
	*(uint8_t*)0x10001fb7 = 0x00


	// Firmware Offset(s): 
	//	0x00006088 - 0x0000609c
	//	0x0000300c - 0x0000301a
	//	0x00003022 - 0x00003042

	// Designating this USB_HID2 (interface to haptics??):

	// USBD_HID_INIT_PARAM_T
	*(uint32_t*)0x10001f80 = *(uint32_t*)0x10000354; // = 0x20004520 // mem_base - Base memory location from where the stack can allocate
                      // data and buffers. \note The memory address set in this field
                      // should be accessible by USB DMA controller. Also this value
	*(uint32_t*)0x10001f84 = *(uint32_t*)0x10000358; // = 0x000002e0 // mem_size - The size of memory buffer which stack can use.       
                      // \note The \em mem_size should be greater than the size    
                      // returned by USBD_HID_API::GetMemSize() routine.
	*(uint8_t*)0x10001f88 = 0x00000001; // max_reports - Number of HID reports supported by this instance    
                      // of HID class driver
	*(uint32_t*)0x10001f8c = 0x0000ef63; // intf_desc - Pointer to the HID interface descriptor within the   
                      // descriptor array (\em high_speed_desc) passed to Init()   
                      // through \ref USB_CORE_DESCS_T structure.
	*(uint32_t*)0x10001f90 = 0x10000390; // report_dataa - Pointer to an array of HID report descriptor
                      // data structure (\ref USB_HID_REPORT_T). The number
                      // of elements in the array should be same a \em max_reports
                      // value. The stack uses this array to respond to 
                      // requests received for various HID report descriptor
                      // information. \note This array should be of global scope
	*(uint32_t*)0x10001f94 = 0x00005af1; // HID_GetReport
	*(uint32_t*)0x10001f98 = 0x00009565; // HID_SetReport

	reg0 = *(uint32_t*)0x10000350; // = 0x1fff1f24	
	reg0 = *(uint32_t*)0x1fff1f34; // = 0x1fff1f78 // *(uing32_t*)(reg0 + 0x10)???
	reg2 = *(uint32_t*)0x1fff1f7c; // = 0x1fff2cfd // *(uint32_t*)(reg0 + 4)???
	
	reg0 = (uint32_t*)0x1000034c; // 0x20004118
	reg1 = 0x10001f80;


	// Firmware Offset(s): 
	//	0x1fff2cfc - ...
	//	...        - 0x1fff2cee

	// \param[in] hUsb Handle to the USB device stack.                           
	// \param[in, out] param Structure containing HID function driver module     
	//     initialization parameters.                                            
	// \return Returns \ref ErrorCode_t type to indicate success or error condition.
	// 	\retval LPC_OK On success                                         
	// 	\retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte  
	// 	    aligned or smaller than required.                             
	// 	\retval ERR_API_INVALID_PARAM2 Either HID_GetReport() or HID_SetReport()
	// 	    callback are not defined.                                     
	// 	\retval ERR_USBD_BAD_DESC  HID_HID_DESCRIPTOR_TYPE is not defined 
	// 	    immediately after interface descriptor.                       
	// 	\retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
	// 	\retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
	USBD_HID_API_T->init(USBD_HANDLE_T hUsb = 0x20004118, USBD_HID_INIT_PARAM_T* param = 0x10001f80)


	// Firmware Offset(s): 
	//	0x00003044 - 0x0000304c

	// Update global mem_base after USBD_HID_API_T->init()
	*(uint32_t*)0x10000354 = *(uint32_t*)0x10001f80; // = 0x20004550
	// Update last mem_size after USBD_HID_API_T->init()
	*(uint32_t*)0x10000358 = *(uint32_t*)0x10001f84; // = 0x000002b0


	// Firmware Offset(s): 
	//	0x000060a0 - 0x000060ac
	//	0x0000d7b6 - 0x0000d7b6
	//	0x00005d90 - 0x00005d92

	*(uint16_t*)0x10001140 = 0x0001;
	*(uint8_t*)0x10001142 = 0x01;
	*(uint8_t*)0x10001143 = 0x3c;


	// Firmware Offset(s): 
	//	0x0000521c - 0x00005220
	//	0x0000452c - 0x00004540

	// Power BOD power-down via Power configuration register 
	reg1 = *(uint32_t*)0x40048238
	reg1 &= 0x000005ff
	reg1 &= ~0x00000008
	reg1 |= 0x0000e800	
	*(uint32_t*)0x40048238 = reg1


	// Firmware Offset(s): 
	//	0x00005224 - 0x00005238

	// Set BOD reset level to Level 2 (The reset assertion threshold voltage is 2.35 V; the reset de-assertion threshold voltage is 2.43 V)
	//  and BOD interrupt level to Level 1 (he interrupt assertion threshold voltage is 2.22 V; the interrupt de-assertion threshold voltage is 2.35 V)
	//  via BOD control register (BODCTRL)
	*(uint32_t*)0x40048150 = 0x00000006;

	// Clear Status of the Brown-out detect reset via System reset status register (SYSRSTSTAT)
	*(uint32_t*)0x40048030 = 0x00000008;

	// Enable BOD reset function via via BOD control register (BODCTRL)
	reg1 = *(uint32_t*)0x40048150;
	reg1 |= 0x00000010;
	*(uint32_t*)0x40048150 = reg1;


	// Firmware Offset(s): 
	//	0x00005d96 - 0x00005d98
	//	0x000065e4 - 0x000065ea

	// Save hardware/board revision (read from EEPROM) and copy to new variable
	reg1 = *(uint32_t*)0x100009b8; // 0xa
	*(uint32_t*)0x10000094 = reg1;


	// Firmware Offset(s): 
	//	0x00005d9c - 0x00005d9c
	//	0x00009204 - 0x00009206
	//	0x000056f0 - 0x000056f4
	//	0x0000920a - 0x00009210

	reg0 = *(uint8_t*)0x10000094;
	if (reg0 < 8) {
		// UNKNOWN PATHS branch to 0x00009212 if hw revision is < 8
	}


	// Firmware Offset(s): 
	//	0x00009214 - 0x00009218
	//	0x00007980 - 0x00007994

	// SRAM0 initialization
	*(uint8_t*)0x10000953 = 1;
	*(uint8_t*)0x10000954 = 0xd;

	*(uint8_t*)0x10000924 = 1;


	// Firmware Offset(s): 
	//	0x0000921c - 0x00009222
	//	0x00007980 - 0x00007994

	// SRAM0 initialization
	*(uint8_t*)0x10000955 = 1;
	*(uint8_t*)0x10000956 = 0x1b;

	*(uint8_t*)0x10000925 = 1;


	// Firmware Offset(s): 
	//	0x00009226 - 0x00009226
	//	0x000056f0 - 0x000056f4
	//	0x0000922a - 0x00009230

	reg0 = *(uint8_t*)0x10000094;
	if (reg0 < 8) {
		// UNKNOWN PATHS branch to 0x00009232 if hw revision is < 8
	}


	// Firmware Offset(s): 
	//	0x00009244 - 0x00009246
	//	0x0000924c - 0x0000924e
	//	0x00007980 - 0x00007994

	// SRAM0 initialization
	*(uint8_t*)0x1000095f = 1;
	*(uint8_t*)0x10000960 = 0xe;

	*(uint8_t*)0x1000092a = 1;


	// Firmware Offset(s): 
	//	0x00009252 - 0x00009258
	//	0x00007980 - 0x00007994

	// SRAM0 initialization
	*(uint8_t*)0x10000961 = 1;
	*(uint8_t*)0x10000962 = 0x4;

	*(uint8_t*)0xe000092b = 1;

	// Firmware Offset(s): 
	//	0x0000925c - 0x0000925c
	//	0x000056f0 - 

//TODO: switching to cleaned version of .c exeLog output. Go back and clean up previous to match?

				// Branch from 0x0000925c to 0x000056f0 (Set LR to 0x00009261)
				// At 0x000056f4 branching to 0x00009261 (reg14)

				// Check HW version
				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x00009272
				}

				// Branch from 0x0000926a to 0x00007980 (Set LR to 0x0000926f)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x0000926f)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x1000097d = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x1000097e = 0x03 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x10000939 = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x0000926f)
				// Stack Pointer updated to 0x10001fa8

				// Branching from PC = 0x00009270 to PC = 0x0000927e

				// Branch from 0x00009282 to 0x00007980 (Set LR to 0x00009287)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00009287)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x1000097b = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x1000097c = 0x19 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x10000938 = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00009287)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x0000928c to 0x00007980 (Set LR to 0x00009291)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00009291)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x10000965 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x10000966 = 0x02 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x1000092d = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00009291)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x00009290 to 0x000056f0 (Set LR to 0x00009295)

				// At 0x000056f4 branching to 0x00009295 (reg14)

				// Check HW version
				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x0000929c
				}

				// Branching from PC = 0x0000929a to PC = 0x0000929e

				// Branch from 0x000092a2 to 0x00007980 (Set LR to 0x000092a7)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000092a7)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x10000969 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x1000096a = 0x14 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x1000092f = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000092a7)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x000092a6 to 0x000056f0 (Set LR to 0x000092ab)

				// At 0x000056f4 branching to 0x000092ab (reg14)

				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x000092b2
				}

				// Branching from PC = 0x000092b0 to PC = 0x000092c2

				// Branch from 0x000092c6 to 0x00007980 (Set LR to 0x000092cb)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000092cb)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x10000967 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x10000968 = 0x13 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x1000092e = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000092cb)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x000092d0 to 0x00007980 (Set LR to 0x000092d5)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000092d5)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x1000095d = 0x00 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x1000095e = 0x11 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x10000929 = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000092d5)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x000092d4 to 0x000056f0 (Set LR to 0x000092d9)

				// At 0x000056f4 branching to 0x000092d9 (reg14)

				// Check HW version
				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x000092f4
				}

				// Branch from 0x000092e2 to 0x00007980 (Set LR to 0x000092e7)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000092e7)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x10000959 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x1000095a = 0x16 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x10000927 = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000092e7)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x000092ec to 0x00007980 (Set LR to 0x000092f1)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000092f1)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x1000095b = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x1000095c = 0x09 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x10000928 = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000092f1)
				// Stack Pointer updated to 0x10001fa8

				// Branching from PC = 0x000092f2 to PC = 0x0000930a

				// Branch from 0x0000930e to 0x00007980 (Set LR to 0x00009313)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00009313)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x10000957 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x10000958 = 0x0b 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x10000926 = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00009313)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x00009312 to 0x000056f0 (Set LR to 0x00009317)

				// At 0x000056f4 branching to 0x00009317 (reg14)

				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x00009320
				}

				// Branching from PC = 0x0000931e to PC = 0x00009324

				// Branch from 0x0000932a to 0x00007980 (Set LR to 0x0000932f)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000001)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x0000932f)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x100009a9 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x100009aa = 0x15 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x1000094f = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000001)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x0000932f)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x00009334 to 0x00007980 (Set LR to 0x00009339)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000001)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00009339)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x100009a7 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x100009a8 = 0x00 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x1000094e = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000001)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00009339)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x0000933e to 0x00007980 (Set LR to 0x00009343)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000001)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00009343)
					// Stack Pointer updated to 0x10001fa0

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint8_t*)0x10000963 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000001)
					*(uint8_t*)0x10000964 = 0x1a 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint8_t*)0x1000092c = 0x01 

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000001)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00009343)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x00009342 to 0x000056f0 (Set LR to 0x00009347)

				// At 0x000056f4 branching to 0x00009347 (reg14)

				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x0000934e
				}

				// Branching from PC = 0x0000934c to PC = 0x00009350

				// Branch from 0x00009354 to 0x0000721c (Set LR to 0x00009359)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg0)
				*(uint8_t*)0x10000204 = 0x00 

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
				*(uint8_t*)0x10000206 = 0x12 

				// At 0x00007224 branching to 0x00009359 (reg14)

				// Branch from 0x0000935e to 0x0000721c (Set LR to 0x00009363)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg0)
				*(uint8_t*)0x10000203 = 0x01 

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
				*(uint8_t*)0x10000205 = 0x0c 

				// At 0x00007224 branching to 0x00009363 (reg14)

				// Branch from 0x00009362 to 0x000056f0 (Set LR to 0x00009367)

				// At 0x000056f4 branching to 0x00009367 (reg14)

				// Check HW version
				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x0000936e
				}

				// Branching from PC = 0x0000936c to PC = 0x00009378

				// Branch from 0x0000937a to 0x000071e8 (Set LR to 0x0000937f)

				{
					// Save reg4 to Stack at 0x10001f98 (Value saved is 0x00000001)
					// Save reg5 to Stack at 0x10001f9c (Value saved is 0x00000000)
					// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x0000937f)
					// Stack Pointer updated to 0x10001f98

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000000)
					*(uint8_t*)0x10000200 = 0x01 

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000001)
					*(uint8_t*)0x10000201 = 0x07 

					// MemWrite GPIO: P1_7 PBYTE (address was computed as reg2 + reg6)
					*(uint8_t*)0x50000027 = 0x01 

					// Branch from 0x00007206 to 0x00004234 (Set LR to 0x0000720b)

					// MemWrite GPIO: DIR1 (address was computed as reg0 + 0x00000000)
					*(uint32_t*)0x50002004 = 0x00000480 

					// At 0x00004248 branching to 0x0000720b (reg14)

					// Branch from 0x00007210 to 0x00005508 (Set LR to 0x00007215)

					{
						// Save reg4 to Stack at 0x10001f90 (Value saved is 0x10000200)
						// Save reg14 to Stack at 0x10001f94 (Value saved is 0x00007215)
						// Stack Pointer updated to 0x10001f90

						// Compute 0x00000001 - 0x00000000 for compare
						if (*(uint8_t*)0x10000200 - 0x00000000) is NOT Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x00005510
						}

						// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

						// Compute 0x00000001 - 0x00000000 for compare
						if (*(uint8_t*)0x10000200 - 0x00000000) is Equal, Z == 1
						{
							// UNKOWN PATH execute 0x000043b0
						}

						// 0x4004401c = 0x0000001c + 0x40044000
						reg0 = (uint32_t)(*(uint8_t*)0x10000201 << 2) +  0x40044000;

						// MemWrite IOCON: PIO1_7 (address was computed as reg0 + 0x00000060)
						*(uint32_t*)0x4004407c = 0x00000080 

						// At 0x000043ae branching to 0x0000553f (reg14)

					}
					// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x10000200)
					// Restore PC from Stack at 0x10001f94 (Value saved was 0x00007215)
					// Stack Pointer updated to 0x10001f98

				}
				// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x00000001)
				// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x00000000)
				// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x0000937f)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x00009380 to 0x00004bf0 (Set LR to 0x00009385)

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000020)
				*(uint32_t*)0x10000254 = 0x40040000 

				// Branching from PC = 0x00004c06 to PC = 0x00004bfc

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000002)
				*(uint8_t*)0x10000236 = 0x0b 

				// At 0x00004bfe branching to 0x00009385 (reg14)

				// Branch from 0x0000938a to 0x00004bd0 (Set LR to 0x0000938f)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg0)
				*(uint8_t*)0x1000023b = 0x01 

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
				*(uint8_t*)0x1000023d = 0x06 

				// At 0x00004bd8 branching to 0x0000938f (reg14)

				// Branch from 0x00009394 to 0x00004be0 (Set LR to 0x00009399)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg0)
				*(uint8_t*)0x1000023f = 0x01 

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
				*(uint8_t*)0x10000241 = 0x10 

				// At 0x00004be8 branching to 0x00009399 (reg14)

				// Branch from 0x0000939e to 0x00004bd0 (Set LR to 0x000093a3)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg0)
				*(uint8_t*)0x1000023a = 0x01 

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
				*(uint8_t*)0x1000023c = 0x0f 

				// At 0x00004bd8 branching to 0x000093a3 (reg14)

				// Branch from 0x000093a8 to 0x00004be0 (Set LR to 0x000093ad)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg0)
				*(uint8_t*)0x1000023e = 0x00 

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
				*(uint8_t*)0x10000240 = 0x17 

				// At 0x00004be8 branching to 0x000093ad (reg14)

				// Branch from 0x000093ac to 0x000056f0 (Set LR to 0x000093b1)

				// At 0x000056f4 branching to 0x000093b1 (reg14)

				// Check HW Version
				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x000093dc
				}

				// Branch from 0x000093b8 to 0x00005b94 (Set LR to 0x000093bd)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000000)
				*(uint8_t*)0x100002d0 = 0x01 

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000001)
				*(uint8_t*)0x100002d1 = 0x01 

				// At 0x00005b9a branching to 0x000093bd (reg14)

				// Branch from 0x000093c2 to 0x00005bf0 (Set LR to 0x000093c7)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg0)
				*(uint8_t*)0x100002d3 = 0x00 

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
				*(uint8_t*)0x100002d5 = 0x0d 

				// At 0x00005bf8 branching to 0x000093c7 (reg14)

				// Branch from 0x000093cc to 0x00005bf0 (Set LR to 0x000093d1)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg0)
				*(uint8_t*)0x100002d2 = 0x00 

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
				*(uint8_t*)0x100002d4 = 0x0b 

				// At 0x00005bf8 branching to 0x000093d1 (reg14)

				// Branch from 0x000093d4 to 0x00002fbc (Set LR to 0x000093d9)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
				*(uint8_t*)0x10000310 = 0x02 

				// At 0x00002fc4 branching to 0x000093d9 (reg14)

				// Branching from PC = 0x000093da to PC = 0x00009402

				// Branch from 0x00009404 to 0x00002fbc (Set LR to 0x00009409)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
				*(uint8_t*)0x10000311 = 0x00 

				// At 0x00002fc4 branching to 0x00009409 (reg14)

				// Branch from 0x00009408 to 0x000056f0 (Set LR to 0x0000940d)

				// At 0x000056f4 branching to 0x0000940d (reg14)

				// Check HW version
				// Compute 0x0000000a - 0x00000008 for compare
				if (reg*(uint8_t*)0x100000940 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x0000942e
				}

				// Branch from 0x00009416 to 0x000064b4 (Set LR to 0x0000941b)

				// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
				*(uint8_t*)0x10000023 = 0x01 

				// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000001)
				*(uint8_t*)0x10000024 = 0x03 

				// At 0x000064be branching to 0x0000941b (reg14)

				// Branch from 0x00009420 to 0x00006524 (Set LR to 0x00009425)

				// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
				*(uint8_t*)0x10000021 = 0x01 

				// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000001)
				*(uint8_t*)0x10000022 = 0x00 

				// At 0x0000652e branching to 0x00009425 (reg14)

				// Branch from 0x00009428 to 0x000064c4 (Set LR to 0x0000942d)

				{
					// Save reg4 to Stack at 0x10001f98 (Value saved is 0x00000001)
					// Save reg5 to Stack at 0x10001f9c (Value saved is 0x00000000)
					// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x0000942d)
					// Stack Pointer updated to 0x10001f98

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000000)
					*(uint8_t*)0x1000001c = 0x00 

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000001)
					*(uint8_t*)0x1000001d = 0x13 

					// MemWrite GPIO: P0_19 PBYTE (address was computed as reg3 + reg5)
					*(uint8_t*)0x50000013 = 0x00 

					// MemWrite GPIO: DIR0 (address was computed as reg2 + 0x00000000)
					*(uint32_t*)0x50002000 = *(uint32_t*)0x50002000 | 0x00080000; // = 0x00080000 (modified bits = 0x00080000)

					// Branch from 0x000064f8 to 0x00005508 (Set LR to 0x000064fd)

					{
						// Save reg4 to Stack at 0x10001f90 (Value saved is 0x00080000)
						// Save reg14 to Stack at 0x10001f94 (Value saved is 0x000064fd)
						// Stack Pointer updated to 0x10001f90

						// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

						// MemWrite IOCON: PIO0_19 (address was computed as reg0 + reg2)
						*(uint32_t*)0x4004404c = 0x00000080 (modified bits = 0x00000010)

						// At 0x000043b2 branching to 0x0000553f (reg14)

					}
					// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x00080000)
					// Restore PC from Stack at 0x10001f94 (Value saved was 0x000064fd)
					// Stack Pointer updated to 0x10001f98

				}
				// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x00000001)
				// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x00000000)
				// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x0000942d)
				// Stack Pointer updated to 0x10001fa8

				// Branching from PC = 0x0000942c to PC = 0x00009470

				// Branch from 0x00009470 to 0x000056f0 (Set LR to 0x00009475)

				// At 0x000056f4 branching to 0x00009475 (reg14)

				// Check HW Version
				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x0000947e
				}

				// Branching from PC = 0x0000947c to PC = 0x00009490

				// Branch from 0x00009492 to 0x00007c10 (Set LR to 0x00009497)

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + 0x00000000)
				*(uint8_t*)0x100002ac = 0x01 

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + 0x00000001)
				*(uint8_t*)0x100002ad = 0x0a 

				// MemWrite 8 kB SRAM0 (address was computed as reg3 + 0x00000002)
				*(uint8_t*)0x100002ae = 0x01 

				// At 0x00007c18 branching to 0x00009497 (reg14)

				// Branch from 0x00009498 to 0x00007bf8 (Set LR to 0x0000949d)

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000003)
				*(uint8_t*)0x100002af = 0x06 (modified bits = 0xf9)

				// At 0x00007bfc branching to 0x0000949d (reg14)

				// Branch from 0x0000949c to 0x000056f0 (Set LR to 0x000094a1)

				// At 0x000056f4 branching to 0x000094a1 (reg14)

				// Check HW Version
				// Compute 0x0000000a - 0x00000009 for compare
				if (*(uint8_t*)0x10000094 - 0x00000009) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x000094b6
				}

				// Branch from 0x000094a6 to 0x00007c04 (Set LR to 0x000094ab)

				// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x00000014)
				*(uint32_t*)0x100002c0 = 0x3fe00000 (modified bits = 0x7fe00000)

				// At 0x00007c08 branching to 0x000094ab (reg14)

				// Branch from 0x000094b0 to 0x00007c38 (Set LR to 0x000094b5)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000001)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000094b5)
					// Stack Pointer updated to 0x10001fa0

					// Compute 0x00000000 - 0xffffffff for compare
					if (0x00000000 - (int32_t)(*(int8_t*)0x100002b0)) is NOT Not equal, Z == 0
					{
						// UNKOWN PATH execute 0x00007c44
					}

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000004)
					*(uint8_t*)0x100002b0 = 0x00 (modified bits = 0xff)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000005)
					*(uint8_t*)0x100002b1 = 0x02 (modified bits = 0xfd)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000010)
					*(uint32_t*)0x100002bc = 0x000065a9 (modified bits = 0x000065a9)

					// Branch from 0x00007c5a to 0x00004214 (Set LR to 0x00007c5f)

					// At 0x00004220 branching to 0x00007c5f (reg14)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000006)
					*(uint8_t*)0x100002b2 = *(uint8_t*)0x50000002 ^ 0x00000001; // = 0x01 (modified bits = 0x01)

					// Branch from 0x00007c6c to 0x00005544 (Set LR to 0x00007c71)

					{
						// Save reg0 to Stack at 0x10001f7c (Value saved is 0x00000000)
						// Save reg1 to Stack at 0x10001f80 (Value saved is 0x00000002)
						// Save reg2 to Stack at 0x10001f84 (Value saved is 0x00007355)
						// Save reg3 to Stack at 0x10001f88 (Value saved is 0x00000000)
						// Save reg4 to Stack at 0x10001f8c (Value saved is 0x100002ac)
						// Save reg5 to Stack at 0x10001f90 (Value saved is 0x00000000)
						// Save reg6 to Stack at 0x10001f94 (Value saved is 0x00010074)
						// Save reg7 to Stack at 0x10001f98 (Value saved is 0x00000000)
						// Save reg14 to Stack at 0x10001f9c (Value saved is 0x00007c71)
						// Stack Pointer updated to 0x10001f7c


						// Branch from 0x0000554e to 0x00005434 (Set LR to 0x00005553)

						// Compute 0x0000a87d - 0x00000000 for compare
						if (*(uint32_t*)0x100010b4 - 0x00000000) is Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00005448
						}

						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x100010b8 - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00005440
						}

						// At 0x00005448 branching to 0x00005553 (reg14)

						// Branch from 0x0000555c to 0x0000454c (Set LR to 0x00005561)

						// Setup GPIO interrupt 1 for PIO0_2
						// MemWrite system control: PINTSEL1 (address was computed as reg0 + 0x00000038)
						*(uint32_t*)0x4004817c = 0x00000018 * *(uint8_t*)0x100002b0 + *(uint8_t*)0x100002b1; // = 0x00000002 (modified bits = 0x00000002)

						// At 0x0000455a branching to 0x00005561 (reg14)

						// Clear rising/falling edge detection for PIO0_2 via PINT1
						// MemWrite GPIO interrupts: IST (address was computed as reg1 + 0x00000024)
						*(uint32_t*)0x4004c024 = 0x00000002; // = 0x00000002 (modified bits = 0x00000003)

						// Select falling edge interrupt for PIO0_2 via PINT1
						// MemWrite GPIO interrupts: SIENF (address was computed as reg1 + 0x00000014)
						*(uint32_t*)0x4004c014 = 0x00000002; // = 0x00000002 (modified bits = 0x00000002)

						// MemWrite 8 kB SRAM0 (address was computed as reg1 + reg0)
						*(uint32_t*)0x100010b8 = 0x00007355 (modified bits = 0x00007355)

						// Clear any pending interrupts for PIO0_2 via PINT1
						// MemWrite NVIC: ICPR0 (address was computed as reg0 + 0x00000000)
						*(uint32_t*)0xe000e280 = 0x00000002; // = 0x00000002 (modified bits = 0x00000003)

						// Enable interrupts for PIO0_2 via PINT1
						// MemWrite NVIC: ISER0 (address was computed as reg0 + 0x00000000)
						*(uint32_t*)0xe000e100 = 0x00000002; // = 0x00000002 (modified bits = 0x00000003)

					}
					// Restore reg4 from Stack at 0x10001f8c (Value saved was 0x100002ac)
					// Restore reg5 from Stack at 0x10001f90 (Value saved was 0x00000000)
					// Restore reg6 from Stack at 0x10001f94 (Value saved was 0x00010074)
					// Restore reg7 from Stack at 0x10001f98 (Value saved was 0x00000000)
					// Restore PC from Stack at 0x10001f9c (Value saved was 0x00007c71)
					// Stack Pointer updated to 0x10001fa0

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000001)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000094b5)
				// Stack Pointer updated to 0x10001fa8

				// Branching from PC = 0x000094b4 to PC = 0x000094be

				reg4 = 0x10001fa8 + 4*bitCount(fields.registers); // = 0x10001fb4

				// Branch from 0x000094d0 to 0x0000bb38 (Set LR to 0x000094d5)

				{
					// Save reg4 to Stack at 0x10001f94 (Value saved is 0x10001fb4)
					// Save reg5 to Stack at 0x10001f98 (Value saved is 0x00000000)
					// Save reg6 to Stack at 0x10001f9c (Value saved is 0x00010074)
					// Save reg7 to Stack at 0x10001fa0 (Value saved is 0x00000000)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000094d5)
					// Stack Pointer updated to 0x10001f94

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000008)
					*(uint32_t*)0x100010b0 = 0x000e1000 (modified bits = 0x000e1000)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000003)
					*(uint8_t*)0x100010ab = 0x11 (modified bits = 0x11)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000002)
					*(uint8_t*)0x100010aa = 0x01 (modified bits = 0x01)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000005)
					*(uint8_t*)0x100010ad = 0x12 (modified bits = 0x12)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000004)
					*(uint8_t*)0x100010ac = 0x01 (modified bits = 0x01)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000000)
					*(uint8_t*)0x100010a8 = 0x01 (modified bits = 0x01)

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000001)
					*(uint8_t*)0x100010a9 = 0x05 (modified bits = 0x05)

				}
				// Restore reg4 from Stack at 0x10001f94 (Value saved was 0x10001fb4)
				// Restore reg5 from Stack at 0x10001f98 (Value saved was 0x00000000)
				// Restore reg6 from Stack at 0x10001f9c (Value saved was 0x00010074)
				// Restore reg7 from Stack at 0x10001fa0 (Value saved was 0x00000000)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000094d5)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x000094d4 to 0x000056f0 (Set LR to 0x000094d9)

				// At 0x000056f4 branching to 0x000094d9 (reg14)

				// Check HW Version
				// Compute 0x0000000a - 0x00000007 for compare
				if (*(uint8_t*)0x10000094 - 0x00000007) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x000094ec
				}

				// Branch from 0x000094e0 to 0x0000ba88 (Set LR to 0x000094e5)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000000)
				*(uint8_t*)0x10000060 = 0x01 (modified bits = 0xfe)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000001)
				*(uint8_t*)0x10000061 = 0x18 (modified bits = 0xe7)

				// At 0x0000ba8e branching to 0x000094e5 (reg14)

				// Branch from 0x000094e8 to 0x0000ba7c (Set LR to 0x000094ed)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000002)
				*(uint8_t*)0x10000062 = 0x01 (modified bits = 0xfe)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000003)
				*(uint8_t*)0x10000063 = 0x08 (modified bits = 0xf7)

				// At 0x0000ba82 branching to 0x000094ed (reg14)

				// Branch from 0x000094f2 to 0x00004fdc (Set LR to 0x000094f7)

				{
					// Save reg4 to Stack at 0x10001f98 (Value saved is 0x10001fb4)
					// Save reg5 to Stack at 0x10001f9c (Value saved is 0x00000000)
					// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000094f7)
					// Stack Pointer updated to 0x10001f98

					// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg2)
					*(uint8_t*)0x10000008 = 0x01 (modified bits = 0x01)

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000001)
					*(uint8_t*)0x10000009 = 0x0000001c; // = 0x1c (modified bits = 0x1c)

					// Branch from 0x00004ff4 to 0x00005508 (Set LR to 0x00004ff9)

					{
						// Save reg4 to Stack at 0x10001f90 (Value saved is 0x0000001c)
						// Save reg14 to Stack at 0x10001f94 (Value saved is 0x00004ff9)
						// Stack Pointer updated to 0x10001f90

						// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

						// Set MODE to inactive (from default Pull-up resistor) for PIO1_28
						// MemWrite IOCON: PIO1_28 (address was computed as reg0 + 0x00000060)
						*(uint32_t*)0x400440d0 = 0x00000080 (modified bits = 0x00000010)

						// At 0x000043ae branching to 0x0000553f (reg14)

					}
					// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x0000001c)
					// Restore PC from Stack at 0x10001f94 (Value saved was 0x00004ff9)
					// Stack Pointer updated to 0x10001f98

					// Load P1_28 output value to be 0
					// MemWrite GPIO: P1_28 PBYTE (address was computed as reg2 + reg1)
					*(uint8_t*)0x5000003c = 0x00 (modified bits = 0x00)

					// Set P1_28 to output
					// MemWrite GPIO: DIR1 (address was computed as reg0 + 0x00000000)
					*(uint32_t*)0x50002004 = *(uint32_t*)0x50002004 | 0x10000000; // = 0x10000480 (modified bits = 0x10000000)

				}
				// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x10001fb4)
				// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x00000000)
				// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000094f7)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x000094fc to 0x00004fdc (Set LR to 0x00009501)

				{
					// Save reg4 to Stack at 0x10001f98 (Value saved is 0x10001fb4)
					// Save reg5 to Stack at 0x10001f9c (Value saved is 0x00000000)
					// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00009501)
					// Stack Pointer updated to 0x10001f98

					// MemWrite 8 kB SRAM0 (address was computed as reg3 + reg2)
					*(uint8_t*)0x1000000a = 0x00 (modified bits = 0x00)

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000001)
					*(uint8_t*)0x1000000b = 0x07 (modified bits = 0x07)

					// Branch from 0x00004ff4 to 0x00005508 (Set LR to 0x00004ff9)

					{
						// Save reg4 to Stack at 0x10001f90 (Value saved is 0x00000007)
						// Save reg14 to Stack at 0x10001f94 (Value saved is 0x00004ff9)
						// Stack Pointer updated to 0x10001f90

						// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

						// Set MODE to inactive (from pull-up resistor enabled) for PIO0_7
						// MemWrite IOCON: PIO0_7 (address was computed as reg0 + reg2)
						*(uint32_t*)0x4004401c = 0x00000080; // = 0x00000080 (modified bits = 0x00000010)

						// At 0x000043b2 branching to 0x0000553f (reg14)

					}
					// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x00000007)
					// Restore PC from Stack at 0x10001f94 (Value saved was 0x00004ff9)
					// Stack Pointer updated to 0x10001f98

					// Drive PIO0_7 with output value of 0
					// MemWrite GPIO: P0_7 PBYTE (address was computed as reg2 + reg1)
					*(uint8_t*)0x50000007 = 0x00 (modified bits = 0x00)

					// Set PIO0_7 to output mode
					// MemWrite GPIO: DIR0 (address was computed as reg0 + 0x00000000)
					*(uint32_t*)0x50002000 = *(uint32_t*)0x50002000 | 0x00000080; // = 0x00080080 (modified bits = 0x00000080)

				}
				// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x10001fb4)
				// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x00000000)
				// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00009501)
				// Stack Pointer updated to 0x10001fa8

				// Branch from 0x00009500 to 0x000056f0 (Set LR to 0x00009505)

				// At 0x000056f4 branching to 0x00009505 (reg14)

				// Check hardware version
				// Compute 0x0000000a - 0x00000008 for compare
				if (*(uint8_t*)0x10000094 - 0x00000008) is NOT Not equal, Z == 0
				{
					// UNKOWN PATH execute 0x00009508
				}

			}
			// Restore reg1 from Stack at 0x10001fa8 (Value saved was 0x00000012)
			// Restore reg2 from Stack at 0x10001fac (Value saved was 0x00000001)
			// Restore reg3 from Stack at 0x10001fb0 (Value saved was 0x00000005)
			// Restore reg4 from Stack at 0x10001fb4 (Value saved was 0x00010074)
			// Restore reg5 from Stack at 0x10001fb8 (Value saved was 0x00000001)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005da1)
			// Stack Pointer updated to 0x10001fc0

			// Branch from 0x00005da0 to 0x00007af0 (Set LR to 0x00005da5)

			{
				// Save reg3 to Stack at 0x10001fa8 (Value saved is 0x00000005)
				// Save reg4 to Stack at 0x10001fac (Value saved is 0x00010074)
				// Save reg5 to Stack at 0x10001fb0 (Value saved is 0x00000001)
				// Save reg6 to Stack at 0x10001fb4 (Value saved is 0x00010074)
				// Save reg7 to Stack at 0x10001fb8 (Value saved is 0x00000000)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005da5)
				// Stack Pointer updated to 0x10001fa8



				// The next part is a little messy (i.e. regN still remains in some lines)
				//  This is showing how SRAM0 values are being used to compute that PIO1_10 is the desired GPIO to control here

				// MemRead 8 kB SRAM0 (address was computed as reg4 + reg0)
				// Compute 0x00000001 - 0x00000000 for compare
				if ((int32_t)(*(int8_t*)0x100002ac) - 0x00000000) is Signed less than, N != V
				{
					// UNKOWN PATH execute 0x00007b2e
				}

				// MemRead 8 kB SRAM0 (address was computed as reg4 + reg0)
				// 0x50000020 = 0x00000020 + 0x50000000
				reg3 = (uint32_t)(uint32_t)(int32_t)(*(int8_t*)0x100002ac) << 24 >> 19 + 0x50000000;

				// Drive output value for GPIO1_10 to logic low
				// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000002)
				// MemWrite GPIO: P1_10 PBYTE (address was computed as reg3 + reg2)
				*(uint8_t*)0x5000002a = *(uint8_t*)0x100002ae ^ 0x00000001; // = 0x00 (modified bits = 0x00)

				// MemRead 8 kB SRAM0 (address was computed as reg4 + reg0)

				// 0x50002004 = 0x50000004 + 0x00002000
				reg2 = (uint32_t)((uint32_t)(int32_t)(*(int8_t*)0x100002ac) << 24) >> 22 + 0x50000000 + 0x00002000;

				// MemRead GPIO: DIR1 (address was computed as reg2 + 0x00000000)
				reg3 = *(uint32_t*)0x50002004; // = 0x10000480

				// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000001)
				// 0x00000400 = 0x00000001 << 0x0000000a (Carry Out = 0x00000000)
				reg6 = (uint32_t)0x00000001 << *(uint8_t*)0x100002ad;

				// 0x10000480 = 0x10000480 | 0x00000400;
				reg3 = reg3 | reg6;

				// Set GPIO1_10 direction to output (though it was already set to outpu during earlier init)
				// MemWrite GPIO: DIR1 (address was computed as reg2 + 0x00000000)
				*(uint32_t*)0x50002004 = reg3; // = 0x10000480 (modified bits = 0x00000000)


				
				// Branch from 0x00007b2a to 0x00005508 (Set LR to 0x00007b2f)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x100002ac)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00007b2f)
					// Stack Pointer updated to 0x10001fa0

					// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

					// Change MODE to inactive (i.e. remove pull-down resistor setting)
					// MemWrite IOCON: PIO1_10 (address was computed as reg0 + 0x00000060)
					*(uint32_t*)0x40044088 = 0x00000080 (modified bits = 0x00000010)

					// At 0x000043ae branching to 0x0000553f (reg14)

				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x100002ac)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00007b2f)
				// Stack Pointer updated to 0x10001fa8

				// MemRead 8 kB SRAM0 
				// Compute 0x00000006 - 0x00000000 for compare
				if ((int32_t)(*(int8_t*)0x100002af) - 0x00000000) is Signed less than, N != V
				{
					// UNKOWN PATH execute 0x00007b46
				}

				// Branch from 0x00007b3a to 0x00002a90 (Set LR to 0x00007b3f)

				{
					// Save reg3 to Stack at 0x10001f90 (Value saved is 0x00000080)
					// Save reg4 to Stack at 0x10001f94 (Value saved is 0x100002ac)
					// Save reg5 to Stack at 0x10001f98 (Value saved is 0x00000000)
					// Save reg6 to Stack at 0x10001f9c (Value saved is 0x00000400)
					// Save reg7 to Stack at 0x10001fa0 (Value saved is 0x50000000)
					// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00007b3f)
					// Stack Pointer updated to 0x10001f90

					// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
					*(uint32_t*)0x10000fa8 = 0x00003b49 (modified bits = 0x00003b49)

					// MemWrite 8 kB SRAM0 (address was computed as reg6 + 0x00000002)
					*(uint8_t*)0x10000012 = 0x00000040 | *(uint8_t*)0x10000012; // = 0x40 (modified bits = 0x40)

					// Branch from 0x00002aaa to 0x000040f4 (Set LR to 0x00002aaf)

					// Enable clock for ADC
					// MemRead system control: SYSAHBCLKCTRL (address was computed as reg1 + 0x00000000)
					// MemWrite system control: SYSAHBCLKCTRL (address was computed as reg1 + 0x00000000)
					*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | 0x00002000; // = 0x0c09607f (modified bits = 0x00002000)

					// At 0x00004100 branching to 0x00002aaf (reg14)

					// Disable all ADC related interrupts
					// MemWrite ADC: INTEN (address was computed as reg7 + 0x0000000c)
					*(uint32_t*)0x4001c00c = 0x00000000 (modified bits = 0x00000000)

					// Branch from 0x00002ac6 to 0x000043a4 (Set LR to 0x00002acb)

					// Set PIO0_22 pin function to AD6 (in analog input mode with no pull-up/pull-down resistor enabled)
					// MemWrite IOCON: PIO0_22 (address was computed as reg0 + reg2)
					*(uint32_t*)0x40044058 = 0x00000001 (modified bits = 0x00000091)

					// At 0x000043b2 branching to 0x00002acb (reg14)

					// Branch from 0x00002ad0 to 0x00003fb0 (Set LR to 0x00002ad5)

					// Branching from PC = 0x00003fcc to PC = 0x00003fc6

					// Select AD6 pin to sample and converted
					// MemRead ADC: CR (address was computed as reg0 + 0x00000000)
					// MemWrite ADC: CR (address was computed as reg0 + 0x00000000)
					*(uint32_t*)0x4001c000 = *(uint32_t*)0x4001c000 | 0x00000040; // = 0x00200a40 (modified bits = 0x00000040)

					// At 0x00003fc8 branching to 0x00002ad5 (reg14)

					// MemRead 8 kB SRAM0 (address was computed as reg6 + 0x00000002)
					// Compute 0x00000080 & 0x00000040 for compare
					if (0x00000080 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
					{
						// UNKOWN PATH execute 0x00002ae2
					}

					// MemRead 8 kB SRAM0 (address was computed as reg6 + 0x00000002)
					// Compute 0x00000040 & 0x00000040 for compare
					if (0x00000040 & *(uint8_t*)0x10000012) is Equal, Z == 1
					{
						// UNKOWN PATH execute 0x00002aee
					}

					// Branching from PC = 0x0000402a to PC = 0x00004024

					// Enable interrupt for conversion completion for AD6
					// MemRead ADC: INTEN (address was computed as reg0 + 0x0000000c)
					// MemWrite ADC: INTEN (address was computed as reg0 + 0x0000000c)
					*(uint32_t*)0x4001c00c = *(uint32_t*)0x4001c00c | 0x00000040; // = 0x00000040 (modified bits = 0x00000040)

					// At 0x00004026 branching to 0x00002aed (reg14)

					// Branching from PC = 0x00002aec to PC = 0x00002af2

					// Enable ADC interrupt
					// MemWrite NVIC: ISER0 (address was computed as reg1 + 0x00000000)
					*(uint32_t*)0xe000e100 = 0x01000000; // = 0x01000000 (modified bits = 0x01000002)

				}
				// Restore reg3 from Stack at 0x10001f90 (Value saved was 0x00000080)
				// Restore reg4 from Stack at 0x10001f94 (Value saved was 0x100002ac)
				// Restore reg5 from Stack at 0x10001f98 (Value saved was 0x00000000)
				// Restore reg6 from Stack at 0x10001f9c (Value saved was 0x00000400)
				// Restore reg7 from Stack at 0x10001fa0 (Value saved was 0x50000000)
				// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00007b3f)
				// Stack Pointer updated to 0x10001fa8
				
				// Branch from 0x00007b42 to 0x00002c40 (Set LR to 0x00007b47)

				// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000003)
				// 0x00000018 = 0x00000006 << 2 (Carry Out = 0x00000000)
				reg0 = (uint32_t)(*(uint8_t*)0x100002af) << 2;

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + reg0)
				*(uint32_t*)0x10000fc8 = 0x00003bf5; // = 0x00003bf5 (modified bits = 0x00003bf5)

				// At 0x00002c46 branching to 0x00007b47 (reg14)

			}
			// Restore reg3 from Stack at 0x10001fa8 (Value saved was 0x00000005)
			// Restore reg4 from Stack at 0x10001fac (Value saved was 0x00010074)
			// Restore reg5 from Stack at 0x10001fb0 (Value saved was 0x00000001)
			// Restore reg6 from Stack at 0x10001fb4 (Value saved was 0x00010074)
			// Restore reg7 from Stack at 0x10001fb8 (Value saved was 0x00000000)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005da5)
			// Stack Pointer updated to 0x10001fc0

			// Branch from 0x00005da4 to 0x00007b70 (Set LR to 0x00005da9)

			{
				// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005da9)
				// Stack Pointer updated to 0x10001fb8

				// Branch from 0x00007b7a to 0x00004214 (Set LR to 0x00007b7f)

				// Check if USB cable is plugged in
				// MemRead GPIO: P0_3 PBYTE (address was computed as reg0 + reg2)
				// Compute 0x00000000 - 0x00000000 for compare
				if (*(uint8_t*)0x50000003 - 0x00000000) is NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000421e
				}

				// At 0x00004220 branching to 0x00007b7f (reg14)

			}
			// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005da9)
			// Stack Pointer updated to 0x10001fc0

			// Check if USB cable is connected
			// MemRead GPIO: P0_3 PBYTE (address was computed as reg0 + reg2)
			// Compute 0x00000000 - 0x00000000 for compare
			if (*(uint8_t*)0x50000003 - 0x00000000) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00005dac
			}

			// Branching from PC = 0x00005dcc to PC = 0x00005dae

			// Branch from 0x00005dae to 0x00007b98 (Set LR to 0x00005db3)

			{
				// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005db3)
				// Stack Pointer updated to 0x10001fb8

				// MemRead 8 kB SRAM0 (address was computed as reg1 + 0x00000002)
				// Compute 0x00000001 - 0x00000000 for compare
				if (*(uint8_t*)0x100002ae - 0x00000000) is Equal, Z == 1
				{
					// UNKOWN PATH execute 0x00007bae
				}

				// MemRead 8 kB SRAM0 (address was computed as reg1 + 0x00000000)
				// 0x50000020 = 0x00000020 + 0x50000000
				reg1 = (uint32_t)*(uint8_t*)0x100002ac << 5 + 0x50000000;

				// MemWrite GPIO: P1_10 PBYTE (address was computed as reg1 + reg2)
				*(uint8_t*)0x5000002a = 0x00 (modified bits = 0x00)

			}
			// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005db3)
			// Stack Pointer updated to 0x10001fc0

			// Branch from 0x00005db6 to 0x00007c20 (Set LR to 0x00005dbb)

			// MemWrite 8 kB SRAM0 (address was computed as reg1 + 0x0000000e)
			*(uint16_t*)0x100002ba = 0x07d0 (modified bits = 0x0f1a)

			// At 0x00007c24 branching to 0x00005dbb (reg14)

			// Branch from 0x00005dba to 0x00005b44 (Set LR to 0x00005dbf)

			{
				// Save reg4 to Stack at 0x10001fb0 (Value saved is 0x00010074)
				// Save reg5 to Stack at 0x10001fb4 (Value saved is 0x00000001)
				// Save reg6 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005dbf)
				// Stack Pointer updated to 0x10001fb0

				// MemRead 8 kB SRAM0 (address was computed as reg1 + reg2)
				// Compute 0x00000001 - 0x00000000 for compare
				if ((int32_t)(*(int8_t*)0x100002d0) - 0x00000000) is Signed less than, N != V
				{
					// UNKOWN PATH execute 0x00005b88
				}

				// MemRead 8 kB SRAM0 (address was computed as reg1 + reg0)
				// Compute 0x00000001 - 0x00000000 for compare
				if ((int32_t)(*(int8_t*)0x100002d1) - 0x00000000) is Signed less than, N != V
				{
					// UNKOWN PATH execute 0x00005b88
				}

				// MemRead 8 kB SRAM0 (address was computed as reg1 + reg2)
				// 0x50000020 = 0x00000020 + 0x50000000
				reg4 = (uint32_t)((uint32_t)(int32_t)(*(int8_t*)0x100002d0) << 24) >> 19 + 0x50000000;

				// MemWrite GPIO: P1_1 PBYTE (address was computed as reg4 + reg3)
				*(uint8_t*)0x50000021 = 0x01 (modified bits = 0x01)

				// MemRead 8 kB SRAM0 (address was computed as reg1 + reg2)
				// 0x50002004 = 0x50000004 + 0x00002000
				reg1 = (uint32_t)((uint32_t)(int32_t)(*(int8_t*)0x100002d0) << 24) >> 22 + 0x50000000 + 0x00002000;

				// Set PIO1_1 to output GPIO
				// MemRead 8 kB SRAM0 (address was computed as reg1 + reg0)
				// MemRead GPIO: DIR1 (address was computed as reg1 + 0x00000000)
				// MemWrite GPIO: DIR1 (address was computed as reg1 + 0x00000000)
				*(uint32_t*)0x50002004 = *(uint32_t*)0x50002004 | ((uint32_t)0x00000001 << (int32_t)(*(int8_t*)0x100002d1)); // = 0x10000482 (modified bits = 0x00000002)

				// Branch from 0x00005b84 to 0x00005508 (Set LR to 0x00005b89)

				{
					// Save reg4 to Stack at 0x10001fa8 (Value saved is 0x00000002)
					// Save reg14 to Stack at 0x10001fac (Value saved is 0x00005b89)
					// Stack Pointer updated to 0x10001fa8

					// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

					// Change MODE from default to no pull-down/pull-up resistor
					// MemWrite IOCON: PIO1_1 (address was computed as reg0 + 0x00000060)
					*(uint32_t*)0x40044064 = 0x00000080 (modified bits = 0x00000010)

					// At 0x000043ae branching to 0x0000553f (reg14)

				}
				// Restore reg4 from Stack at 0x10001fa8 (Value saved was 0x00000002)
				// Restore PC from Stack at 0x10001fac (Value saved was 0x00005b89)
				// Stack Pointer updated to 0x10001fb0

				// Branch from 0x00005b8a to 0x00005ba0 (Set LR to 0x00005b8f)

				{
					// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000002)
					// Save reg5 to Stack at 0x10001fa4 (Value saved is 0x50000000)
					// Save reg6 to Stack at 0x10001fa8 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fac (Value saved is 0x00005b8f)
					// Stack Pointer updated to 0x10001fa0

					// MemRead 8 kB SRAM0 (address was computed as reg5 + 0x00000001)
					reg2 = *(uint8_t*)0x100002d1; // = 0x00000001

					// MemRead 8 kB SRAM0 (address was computed as reg5 + 0x00000000)
					// 0x50000020 = 0x00000020 + 0x50000000
					reg0 = ((uint32_t)(*(uint8_t*)0x100002d0) << 5) + 0x50000000;

					// MemWrite GPIO: P1_1 PBYTE (address was computed as reg0 + reg2)
					*(uint8_t*)0x50000021 = 0x01 (modified bits = 0x00)

					// Branch from 0x00005bdc to 0x00005244 (Set LR to 0x00005be1)

					// MemRead 8 kB SRAM0 (address was computed as reg3 + reg0)
					// Compute 0x00000000 - 0x00000000 for compare
					if ((int32_t)(*(int8_t*)0x100002d2) - 0x00000000) is Signed less than, N != V
					{
						// UNKOWN PATH execute 0x00005270
					}

					// MemRead 8 kB SRAM0 (address was computed as reg3 + reg0)
					// Compute 0x00000000 - 0x00000000 for compare
					if ((int32_t)(*(int8_t*)0x100002d2) - 0x00000000) is NOT Equal, Z == 1
					{
						// UNKOWN PATH execute 0x00005258
					}

					// MemRead 8 kB SRAM0 (address was computed as reg2 + reg0)
					// 0x4004402c = 0x0000002c + 0x40044000
					reg0 = (uint32_t)(int32_t)(*(int8_t*)0x100002d4) << 2 + 0x40044000;
				
					// Change MODE from default to no pull-down/pull-up resistor
					// MemRead IOCON: TDI_PIO0_11 (address was computed as reg0 + 0x00000000)
					// 0x00000080 = 0x00000090 & ~0x00000018;
					// MemWrite IOCON: TDI_PIO0_11 (address was computed as reg0 + 0x00000000)
					*(uint32_t*)0x4004402c = *(uint32_t*)0x4004402c * ~0x00000018; // = 0x00000080 (modified bits = 0x00000010)

					// Change MODE to pull-down resistor enabled
					// MemRead IOCON: TDI_PIO0_11 (address was computed as reg0 + 0x00000000)
					// 0x00000088 = 0x00000080 | 0x00000008;
					// MemWrite IOCON: TDI_PIO0_11 (address was computed as reg0 + 0x00000000)
					*(uint32_t*)0x4004402c = *(uint32_t*)0x4004402c | 0x00000008; // = 0x00000088 (modified bits = 0x00000008)

					// At 0x0000528c branching to 0x00005be1 (reg14)

					// Branch from 0x00005bdc to 0x00005244 (Set LR to 0x00005be1)

					// MemRead 8 kB SRAM0 (address was computed as reg3 + reg0)
					// Compute 0x00000000 - 0x00000000 for compare
					if ((int32_t)(*(int8_t*)0x100002d3) - 0x00000000) is Signed less than, N != V
					{
						// UNKOWN PATH execute 0x00005270
					}

					// MemRead 8 kB SRAM0 (address was computed as reg3 + reg0)
					// Compute 0x00000000 - 0x00000000 for compare
					if ((int32_t)(*(int8_t*)0x100002d3) - 0x00000000) is NOT Equal, Z == 1
					{
						// UNKOWN PATH execute 0x00005258
					}

					// MemRead 8 kB SRAM0 (address was computed as reg2 + reg0)
					// 0x40044034 = 0x00000034 + 0x40044000
					reg0 = (uint32_t)(int32_t)(*(int8_t*)0x100002d5) << 2 + 0x40044000;

					// Change MODE from default to no pull-down/pull-up resistor
					// MemRead IOCON: TDO_PIO0_13 (address was computed as reg0 + 0x00000000)
					// 0x00000080 = 0x00000090 & ~0x00000018;
					// MemWrite IOCON: TDO_PIO0_13 (address was computed as reg0 + 0x00000000)
					*(uint32_t*)0x40044034 = *(uint32_t*)0x40044034 * ~0x00000018; // = 0x00000080 (modified bits = 0x00000010)

					// Change MODE to pull-down resistor enabled
					// MemRead IOCON: TDO_PIO0_13 (address was computed as reg0 + 0x00000000)
					// 0x00000088 = 0x00000080 | 0x00000008;
					// MemWrite IOCON: TDO_PIO0_13 (address was computed as reg0 + 0x00000000)
					*(uint32_t*)0x40044034 = *(uint32_t*)0x40044034 | 0x00000008; // = 0x00000088 (modified bits = 0x00000008)

					// At 0x0000528c branching to 0x00005be1 (reg14)
				}
				// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000002)
				// Restore reg5 from Stack at 0x10001fa4 (Value saved was 0x50000000)
				// Restore reg6 from Stack at 0x10001fa8 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fac (Value saved was 0x00005b8f)
				// Stack Pointer updated to 0x10001fb0

			}
			// Restore reg4 from Stack at 0x10001fb0 (Value saved was 0x00010074)
			// Restore reg5 from Stack at 0x10001fb4 (Value saved was 0x00000001)
			// Restore reg6 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005dbf)
			// Stack Pointer updated to 0x10001fc0

			// Branch from 0x00005dbe to 0x000056f0 (Set LR to 0x00005dc3)

			// At 0x000056f4 branching to 0x00005dc3 (reg14)

			// Check hardware version
			// MemRead 8 kB SRAM0 (address was computed as reg0 + 0x00000004)
			// Compute 0x0000000a - 0x00000009 for compare
			if (*(uint8_t*)0x10000094 - 0x00000009) is Carry clear, C == 0
			{
				// UNKOWN PATH execute 0x00005dce
			}

			// Branching from PC = 0x00005dc8 to PC = 0x00005dd0

			// Branch from 0x00005dd0 to 0x000098b4 (Set LR to 0x00005dd5)

			{
				// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005dd5)
				// Stack Pointer updated to 0x10001fb8

				// Branch from 0x000098ba to 0x00007bbc (Set LR to 0x000098bf)

				{
					// Save reg4 to Stack at 0x10001fb0 (Value saved is 0x00000001)
					// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x000098bf)
					// Stack Pointer updated to 0x10001fb0

					// MemRead 8 kB SRAM0 (address was computed as reg2 + 0x00000018)
					// 0x00000000 = 0x00000000 << 2 (Carry Out = 0x00000000)
					reg3 = (uint32_t)*(uint32_t*)0x100002c4 << 2;

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + reg3)
					*(uint32_t*)0x10000dd8 = 0x000067dd (modified bits = 0x000067dd)

					// MemRead 8 kB SRAM0 (address was computed as reg2 + 0x00000018)
					// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000018)
					*(uint32_t*)0x100002c4 = *(uint32_t*)0x100002c4 + 0x00000001; // = 0x00000001 (modified bits = 0x00000001)

				}
				// Restore reg4 from Stack at 0x10001fb0 (Value saved was 0x00000001)
				// Restore PC from Stack at 0x10001fb4 (Value saved was 0x000098bf)
				// Stack Pointer updated to 0x10001fb8

				// Branch from 0x000098c2 to 0x00007424 (Set LR to 0x000098c7)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x0000000c)
				*(uint32_t*)0x10000050 = 0x40010000 (modified bits = 0x00000000)

				// MemWrite 8 kB SRAM0 (address was computed as reg2 + 0x00000001)
				*(uint8_t*)0x10000045 = 0x00 (modified bits = 0x00)

				// At 0x0000742a branching to 0x000098c7 (reg14)

				// Branch from 0x000098c8 to 0x00007388 (Set LR to 0x000098cd)

				{
					// Save reg4 to Stack at 0x10001fa8 (Value saved is 0x00000001)
					// Save reg5 to Stack at 0x10001fac (Value saved is 0x00000001)
					// Save reg6 to Stack at 0x10001fb0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x000098cd)
					// Stack Pointer updated to 0x10001fa8

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000003)
					*(uint8_t*)0x10000047 = 0x01 (modified bits = 0x01)

					// Branch from 0x00007390 to 0x000045bc (Set LR to 0x00007395)

					{
						// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x10000044)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00007395)
						// Stack Pointer updated to 0x10001fa0

						// Branch from 0x000045be to 0x0000458c (Set LR to 0x000045c3)

						// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
						// Compute 0x40010000 - 0x40018000 for compare
						if (*(uint32_t*)0x10000050 - 0x40018000) is NOT Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x00004592
						}

						// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
						// Compute 0x40010000 - 0x4000c000 for compare
						if (*(uint32_t*)0x10000050 - 0x4000c000) is NOT Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x0000459c
						}

						// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
						// Compute 0x40010000 - 0x40010000 for compare
						if (*(uint32_t*)0x10000050 - 0x40010000) is Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x000045aa
						}

						// At 0x000045a8 branching to 0x000045c3 (reg14)

						// Enable clock for 16-bit counter/timer 1 CT16B1
						// MemRead system control: SYSAHBCLKCTRL (address was computed as reg1 + 0x00000000)
						// 0x0c09617f = 0x0c09607f | 0x00000100;
						// MemWrite system control: SYSAHBCLKCTRL (address was computed as reg1 + 0x00000000)
						*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | 0x00000100; // = 0x0c09617f (modified bits = 0x00000100)

					}
					// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x10000044)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00007395)
					// Stack Pointer updated to 0x10001fa8

					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: PR (address was computed as *(uint32_t*)0x10000050 + 0x0000000c)
					*(uint32_t*)0x4001000c = 0x00000000 (modified bits = 0x00000000)

					// PWM mode is enabled for CT16B1_MAT0
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000001)
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemRead CT16B1: PWMC (address was computed as *(uint32_t*)0x10000050 + 0x00000074)
					// 0x00000001 = 0x00000000 | 0x00000001;
					// MemWrite CT16B1: PWMC (address was computed as *(uint32_t*)0x10000050 + 0x00000074)
					*(uint32_t*)0x40010074 = *(uint32_t*)0x40010074 | ((uint32_t)0x00000001 << (int32_t)(*(int8_t*)0x10000045)); // = 0x00000001 (modified bits = 0x00000001)

					// Set match register 3 value (when Timer Counter value matches some action will be triggered automatically)
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: MR3 (address was computed as *(uint32_t*)0x10000050 + 0x00000024)
					*(uint32_t*)0x40010024 = 0x00000fff (modified bits = 0x00000fff)

					// Set match register 1 value (when Timer Counter value matches some action will be triggered automatically)
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000001)
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: MR0 (address was computed as (uint32_t)(int32_t)(*(int8_t*)0x10000045) << 2 + *(uint32_t*)0x10000050 + 0x00000018)
					*(uint32_t*)0x40010018 = 0x00001000 (modified bits = 0x00001000)

					// The TC will be reset if MR3 (0xFFF) matches it
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemRead CT16B1: MCR (address was computed as *(uint32_t*)0x10000050 + 0x00000014)
					// 0x00000400 = 0x00000000 | 0x00000400;
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: MCR (address was computed as *(uint32_t*)0x10000050 + 0x00000014)
					*(uint32_t*)0x40010014 = *(uint32_t*)0x40010014 | 0x00000400; // = 0x00000400 (modified bits = 0x00000400)

					// Branch from 0x000073be to 0x000045e4 (Set LR to 0x000073c3)

					tcr_prev = *(uint32_t*)0x40010004

					// Make sure counter is disabled
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: TCR (address was computed as *(uint32_t*)0x10000050 + 0x00000004)
					*(uint32_t*)0x40010004 = 0x00000000 (modified bits = 0x00000000)

					// Set Timer Counter value to 1
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: TC (address was computed as *(uint32_t*)0x10000050 + 0x00000008)
					*(uint32_t*)0x40010008 = 0x00000001 (modified bits = 0x00000001)

					// Reset the Timer Counter and Prescale Counter on the next positive edge of PCLK
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: TCR (address was computed as *(uint32_t*)0x10000050 + 0x00000004)
					*(uint32_t*)0x40010004 = 0x00000002 (modified bits = 0x00000002)

					// Wait for TC to be reset (based on last instruction)
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemRead CT16B1: TC (address was computed as *(uint32_t*)0x10000050 + 0x00000008)
					// Compute 0x00000000 - 0x00000000 for compare
					if (*(uint32_t*)0x40010008 - 0x00000000) is Not equal, Z == 0
					{
						// UNKOWN PATH execute 0x000045f2
					}

					// Reestablish previous state of TCR (i.e. take counter out of reset)
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemRead CT16B1: TCR (address was computed as *(uint32_t*)0x10000050 + 0x00000004)
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: TCR (address was computed as *(uint32_t*)0x10000050 + 0x00000004)
					*(uint32_t*)0x40010004 = tcr_prev; // = 0x00000000 (modified bits = 0x00000002)

					// At 0x000045fa branching to 0x000073c3 (reg14)

					// Enable Timer Counter and Prescale Counter
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemRead CT16B1: TCR (address was computed as *(uint32_t*)0x10000050 + 0x00000004)
					// 0x00000001 = 0x00000000 | 0x00000001;
					// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000c)
					// MemWrite CT16B1: TCR (address was computed as *(uint32_t*)0x10000050 + 0x00000004)
					*(uint32_t*)0x40010004 = *(uint32_t*)0x40010004 | 0x00000001; // = 0x00000001 (modified bits = 0x00000001)

					// Branch from 0x000073ce to 0x0000a010 (Set LR to 0x000073d3)

					{
						// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x10000044)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000073d3)
						// Stack Pointer updated to 0x10001fa0

						// MemRead 8 kB SRAM0 (address was computed as 0x00000001 + 0x0000000c)
						// Compute 0x40010000 - 0x4000c000 for compare
						if (*(uint32_t*)0x10000050 - 0x4000c000) is NOT Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x0000a01a
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x00000001 + 0x0000000c)
						// Compute 0x40010000 - 0x40010000 for compare
						if (*(uint32_t*)0x10000050 - 0x40010000) is Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x0000a052
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x00000001 + 0x00000001)
						// Compute 0x00000000 - 0x00000000 for compare
						if ((int32_t)(*(int8_t*)0x10000045) - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x0000a042
						}

						// Branching from PC = 0x0000a050 to PC = 0x0000a09c

						// Branch from 0x0000a0bc to 0x000043a4 (Set LR to 0x0000a0c1)

						// Set PIO0_21 pin function CT16B1_MAT0
						// MemWrite IOCON: PIO0_21 (address was computed as 0x40044000 + 0x00000054)
						*(uint32_t*)0x40044054 = 0x00000001 (modified bits = 0x00000091)

						// At 0x000043b2 branching to 0x0000a0c1 (reg14)

					}
					// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x10000044)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000073d3)
					// Stack Pointer updated to 0x10001fa8

				}
				// Restore reg4 from Stack at 0x10001fa8 (Value saved was 0x00000001)
				// Restore reg5 from Stack at 0x10001fac (Value saved was 0x00000001)
				// Restore reg6 from Stack at 0x10001fb0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fb4 (Value saved was 0x000098cd)
				// Stack Pointer updated to 0x10001fb8

				// Branch from 0x000098ce to 0x000073f8 (Set LR to 0x000098d3)

				// MemWrite 8 kB SRAM0 (address was computed as  0x10000044 + 0x00000010)
				*(uint32_t*)0x10000054 = 0x0000a435; // = 0x0000a435 (modified bits = 0x0000a435)

				// At 0x000073fc branching to 0x000098d3 (reg14)

				// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000001)
				*(uint8_t*)0x10000003 = 0x00 (modified bits = 0x00)

				// Branch from 0x000098d8 to 0x0000a434 (Set LR to 0x000098dd)

				{
					// Save reg3 to Stack at 0x10001fa8 (Value saved is 0x00000001)
					// Save reg4 to Stack at 0x10001fac (Value saved is 0x00000001)
					// Save reg5 to Stack at 0x10001fb0 (Value saved is 0x00000001)
					// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x000098dd)
					// Stack Pointer updated to 0x10001fa8

					// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000003)
					*(uint8_t*)0x10000005 = 0x01 (modified bits = 0x01)

					// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000003)
					*(uint8_t*)0x10000005 = 0x00 (modified bits = 0x01)

					// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000000)
					*(uint8_t*)0x10000002 = 0x01 (modified bits = 0x01)

					// MemWrite 8 kB SRAM0 (address was computed as 0x10001fa8 + 0x00000000)
					*(uint16_t*)0x10001fa8 = 0x0000 (modified bits = 0x0001)

					// Branch from 0x0000a484 to 0x00007368 (Set LR to 0x0000a489)

					{
						// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x000001f4)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x0000a489)
						// Stack Pointer updated to 0x10001fa0

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000006)
						*(uint16_t*)0x1000004a = 0x0000 (modified bits = 0x0000)

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x0000000a)
						*(uint16_t*)0x1000004e = 0x0000 (modified bits = 0x0000)

						// Branch from 0x00007370 to 0x0000e65c (Set LR to 0x00007375)

						// Function for calculating MR0 value. Input arg is *(uint8_t*)0x10001fa8
						{
							// Save reg4 to Stack at 0x10001f90 (Value saved is 0x10000044)
							// Save reg5 to Stack at 0x10001f94 (Value saved is 0x00000001)
							// Save reg6 to Stack at 0x10001f98 (Value saved is 0x00010074)
							// Save reg14 to Stack at 0x10001f9c (Value saved is 0x00007375)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x0000e662 to 0x00004ec4 (Set LR to 0x0000e667)

							// MemRead 2 kB SRAM1 (address was computed as reg1 + reg0)
							reg0 = *(uint16_t*)0x200002a0; // = 0x00000064

							// Branch from 0x0000e666 to 0x00002672 (Set LR to 0x0000e66b)

							{
								// Save reg4 to Stack at 0x10001f88 (Value saved is 0x10000044)
								// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000e66b)
								// Stack Pointer updated to 0x10001f88

								// Branch from 0x0000267a to 0x0000281a (Set LR to 0x0000267f)

								{
									// Save reg4 to Stack at 0x10001f7c (Value saved is 0x10000044)
									// Save reg5 to Stack at 0x10001f80 (Value saved is 0x00000001)
									// Save reg6 to Stack at 0x10001f84 (Value saved is 0x00000000)
									// Stack Pointer updated to 0x10001f7c

								}
								// Restore reg4 from Stack at 0x10001f7c (Value saved was 0x10000044)
								// Restore reg5 from Stack at 0x10001f80 (Value saved was 0x00000001)
								// Restore reg6 from Stack at 0x10001f84 (Value saved was 0x00000000)
								// Stack Pointer updated to 0x10001f88

								// At 0x00002874 branching to 0x0000267f (reg14)

							}
							// Restore reg4 from Stack at 0x10001f88 (Value saved was 0x10000044)
							// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000e66b)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x0000e66e to 0x00002394 (Set LR to 0x0000e673)

							{
								// Save reg4 to Stack at 0x10001f80 (Value saved is 0x10000044)
								// Save reg5 to Stack at 0x10001f84 (Value saved is 0x42c80000)
								// Save reg6 to Stack at 0x10001f88 (Value saved is 0x00000000)
								// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000e673)
								// Stack Pointer updated to 0x10001f80

								// Branching from PC = 0x000023cc to PC = 0x000023d0

								// Branch from 0x0000240a to 0x0000280a (Set LR to 0x0000240f)

								// At 0x00002818 branching to 0x0000240f (reg14)

							}
							// Restore reg4 from Stack at 0x10001f80 (Value saved was 0x10000044)
							// Restore reg5 from Stack at 0x10001f84 (Value saved was 0x42c80000)
							// Restore reg6 from Stack at 0x10001f88 (Value saved was 0x00000000)
							// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000e673)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x0000e676 to 0x00004ec4 (Set LR to 0x0000e67b)

							// MemRead 2 kB SRAM1 (address was computed as reg1 + reg0)
							reg0 = *(uint16_t*)0x200002a2; // = 0x00000064

							// At 0x00004ece branching to 0x0000e67b (reg14)

							// Branch from 0x0000e67a to 0x00002672 (Set LR to 0x0000e67f)

							{
								// Save reg4 to Stack at 0x10001f88 (Value saved is 0x3f800000)
								// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000e67f)
								// Stack Pointer updated to 0x10001f88

								// Branch from 0x0000267a to 0x0000281a (Set LR to 0x0000267f)

								{
									// Save reg4 to Stack at 0x10001f7c (Value saved is 0x3f800000)
									// Save reg5 to Stack at 0x10001f80 (Value saved is 0x42c80000)
									// Save reg6 to Stack at 0x10001f84 (Value saved is 0x00000000)
									// Stack Pointer updated to 0x10001f7c

								}
								// Restore reg4 from Stack at 0x10001f7c (Value saved was 0x3f800000)
								// Restore reg5 from Stack at 0x10001f80 (Value saved was 0x42c80000)
								// Restore reg6 from Stack at 0x10001f84 (Value saved was 0x00000000)
								// Stack Pointer updated to 0x10001f88

								// At 0x00002874 branching to 0x0000267f (reg14)

							}
							// Restore reg4 from Stack at 0x10001f88 (Value saved was 0x3f800000)
							// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000e67f)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x0000e680 to 0x00002394 (Set LR to 0x0000e685)

							{
								// Save reg4 to Stack at 0x10001f80 (Value saved is 0x3f800000)
								// Save reg5 to Stack at 0x10001f84 (Value saved is 0x42c80000)
								// Save reg6 to Stack at 0x10001f88 (Value saved is 0x00000000)
								// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000e685)
								// Stack Pointer updated to 0x10001f80

								// Branching from PC = 0x000023cc to PC = 0x000023d0

								// Branch from 0x0000240a to 0x0000280a (Set LR to 0x0000240f)

								// At 0x00002818 branching to 0x0000240f (reg14)

							}
							// Restore reg4 from Stack at 0x10001f80 (Value saved was 0x3f800000)
							// Restore reg5 from Stack at 0x10001f84 (Value saved was 0x42c80000)
							// Restore reg6 from Stack at 0x10001f88 (Value saved was 0x00000000)
							// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000e685)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x0000e688 to 0x00002672 (Set LR to 0x0000e68d)

							{
								// Save reg4 to Stack at 0x10001f88 (Value saved is 0x3f800000)
								// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000e68d)
								// Stack Pointer updated to 0x10001f88

								// Branch from 0x0000267a to 0x0000281a (Set LR to 0x0000267f)

								{
									// Save reg4 to Stack at 0x10001f7c (Value saved is 0x3f800000)
									// Save reg5 to Stack at 0x10001f80 (Value saved is 0x3f800000)
									// Save reg6 to Stack at 0x10001f84 (Value saved is 0x00000000)
									// Stack Pointer updated to 0x10001f7c

								}
								// Restore reg4 from Stack at 0x10001f7c (Value saved was 0x3f800000)
								// Restore reg5 from Stack at 0x10001f80 (Value saved was 0x3f800000)
								// Restore reg6 from Stack at 0x10001f84 (Value saved was 0x00000000)
								// Stack Pointer updated to 0x10001f88

								// At 0x00002874 branching to 0x0000267f (reg14)

							}
							// Restore reg4 from Stack at 0x10001f88 (Value saved was 0x3f800000)
							// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000e68d)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x0000e68e to 0x0000231a (Set LR to 0x0000e693)

							{
								// Save reg4 to Stack at 0x10001f80 (Value saved is 0x3f800000)
								// Save reg5 to Stack at 0x10001f84 (Value saved is 0x3f800000)
								// Save reg6 to Stack at 0x10001f88 (Value saved is 0x00000000)
								// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000e693)
								// Stack Pointer updated to 0x10001f80

							}
							// Restore reg4 from Stack at 0x10001f80 (Value saved was 0x3f800000)
							// Restore reg5 from Stack at 0x10001f84 (Value saved was 0x3f800000)
							// Restore reg6 from Stack at 0x10001f88 (Value saved was 0x00000000)
							// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000e693)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x0000e694 to 0x0000231a (Set LR to 0x0000e699)

							{
								// Save reg4 to Stack at 0x10001f80 (Value saved is 0x3f800000)
								// Save reg5 to Stack at 0x10001f84 (Value saved is 0x3f800000)
								// Save reg6 to Stack at 0x10001f88 (Value saved is 0x00000000)
								// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000e699)
								// Stack Pointer updated to 0x10001f80

							}
							// Restore reg4 from Stack at 0x10001f80 (Value saved was 0x3f800000)
							// Restore reg5 from Stack at 0x10001f84 (Value saved was 0x3f800000)
							// Restore reg6 from Stack at 0x10001f88 (Value saved was 0x00000000)
							// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000e699)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x0000e698 to 0x00002680 (Set LR to 0x0000e69d)


							// MemRead 8 kB SRAM0 (address was computed as reg2 + 0x00000003)
							reg2 = *(uint8_t*)0x10000047; // = 0x00000001

						}
						// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x10000044)
						// Restore reg5 from Stack at 0x10001f94 (Value saved was 0x00000001)
						// Restore reg6 from Stack at 0x10001f98 (Value saved was 0x00010074)
						// Restore PC from Stack at 0x10001f9c (Value saved was 0x00007375)
						// Stack Pointer updated to 0x10001fa0

						// MemRead 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000001)
						// MemRead 8 kB SRAM0 (address was computed as 0x10000044 + 0x0000000c)
						// 0x40010000 = 0x00000000 + 0x40010000
						// MemWrite CT16B1: MR0 (address was computed as (uint32_t)(int32_t)(*(int8_t*)0x10000045 << 2 + *(uint32_t*)0x10000050 + 0x00000018)
						*(uint32_t*)0x40010018 = reg0; // = 0x00000000 (modified bits = 0x00001000)

					}
					// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x000001f4)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x0000a489)
					// Stack Pointer updated to 0x10001fa8

					// Branch from 0x0000a48a to 0x00007430 (Set LR to 0x0000a48f)

					// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000004)
					*(uint16_t*)0x10000048 = 0x01f4 (modified bits = 0x0000)

					// At 0x00007434 branching to 0x0000a48f (reg14)

					// Branch from 0x0000a494 to 0x00007404 (Set LR to 0x0000a499)
					// fnc(uint8_t arg0 = *(uint8_t*)0x10001fa9, uint32_t arg1 = 0x00000001)
					{
						// Save reg4 to Stack at 0x10001f98 (Value saved is 0x000001f4)
						// Save reg5 to Stack at 0x10001f9c (Value saved is 0x00000001)
						// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x0000a499)
						// Stack Pointer updated to 0x10001f98

						// MemRead 8 kB SRAM0 (address was computed as 0x10000044 + 0x0000000a)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000008)
						*(uint16_t*)0x1000004c = *(uint16_t*)0x1000004e; // = 0x0000 (modified bits = 0x0000)

						// Read value off stack
						// MemRead 8 kB SRAM0 (address was computed as 0x10001fa8 + 0x00000001)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000006)
						*(uint16_t*)0x1000004a = *(uint8_t*)0x10001fa9; // = 0x0000 (modified bits = 0x0000) arg0

						// Branch from 0x00007410 to 0x00009aac (Set LR to 0x00007415)

						// At 0x00009ab0 branching to 0x00007415 (reg14)

						// MemRead 8 kB SRAM0 (address was computed as 0x10000324 + 0x0000000c)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000014)
						*(uint32_t*)0x10000058 = *(uint32_t*)0x10000330; // = 0x00000000 (modified bits = 0x00000000)

						// MemRead 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000004)
						// MemRead 8 kB SRAM0 (address was computed as 0x10000324 + 0x0000000c)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000018)
						*(uint32_t*)0x1000005c = *(uint32_t*)0x10000330 + *(uint16_t*)0x10000048; // = 0x000001f4 (modified bits = 0x000001f4)

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000000)
						*(uint8_t*)0x10000044 = 0x01 (modified bits = 0x00) // arg1

					}
					// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x000001f4)
					// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x00000001)
					// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x0000a499)
					// Stack Pointer updated to 0x10001fa8

				}
				// Restore reg3 from Stack at 0x10001fa8 (Value saved was 0x00000000)
				// Restore reg4 from Stack at 0x10001fac (Value saved was 0x00000001)
				// Restore reg5 from Stack at 0x10001fb0 (Value saved was 0x00000001)
				// Restore PC from Stack at 0x10001fb4 (Value saved was 0x000098dd)
				// Stack Pointer updated to 0x10001fb8

			}
			// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005dd5)
			// Stack Pointer updated to 0x10001fc0

			// Branch from 0x00005dd6 to 0x0000a41c (Set LR to 0x00005ddb)

			// MemWrite 2 kB SRAM1 (address was computed as 0x20000000 + 0x00000002)
			*(uint8_t*)0x20000002 = 0x02 (modified bits = 0x02)

			// At 0x0000a420 branching to 0x00005ddb (reg14)

			// Branch from 0x00005dda to 0x00007b70 (Set LR to 0x00005ddf)
			// uint8_t isUsbConnected()
			{
				// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005ddf)
				// Stack Pointer updated to 0x10001fb8

				// Branch from 0x00007b7a to 0x00004214 (Set LR to 0x00007b7f)

				// MemRead GPIO: P0_3 PBYTE (address was computed as 0x50000000 + 0x00000003)
				reg0 = *(uint8_t*)0x50000003; // = 0x00000000

				// Compute 0x00000000 - 0x00000000 for compare
				if (reg0 - 0x00000000) is NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000421e
				}

				// At 0x00004220 branching to 0x00007b7f (reg14)

			}
			// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005ddf)
			// Stack Pointer updated to 0x10001fc0

			// Check if USB cable is connected
			// Compute 0x00000000 - 0x00000000 for compare
			if (isUsbConnected() - 0x00000000) is NOT Equal, Z == 1
			{
				// execute 0x00005e00

				// This is a recovery path attempting to make sure the controller is properly powered
				//  Changing GPIOs and reactions from IRQs are expected, or we just end up in  infinite wfi loop

				// Branch from 0x00005e00 to 0x00002cf0 (Set LR to 0x00005e05)
				// ... fnc()
				{
					// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005e05)
					// Stack Pointer updated to 0x10001fb8

					// MemWrite 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000001)
					*(uint8_t*)0x10000011 = 0x01 (modified bits = 0x01)

					// Branch from 0x00002cf8 to 0x00002d4c (Set LR to 0x00002cfd)
					// void fnc()
					{
						// Save reg4 to Stack at 0x10001fa8 (Value saved is 0x10000010)
						// Save reg5 to Stack at 0x10001fac (Value saved is 0x00000001)
						// Save reg6 to Stack at 0x10001fb0 (Value saved is 0x00010074)
						// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x00002cfd)
						// Stack Pointer updated to 0x10001fa8

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000000)
						*(uint8_t*)0x10000010 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000008)
						*(uint32_t*)0x10000018 = 0x00000000 (modified bits = 0x00000000)

						// Branch from 0x00002d5a to 0x000021be (Set LR to 0x00002d5f)

						// Branching from PC = 0x000021c0 to PC = 0x000021b0

						// Branching from PC = 0x000021b2 to PC = 0x000021b8

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000f80 + 0x00000000)
						*(uint8_t*)0x10000f80 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000f81 + 0x00000000)
						*(uint8_t*)0x10000f81 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f82 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f83 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f84 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f85 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f86 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f87 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f88 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f89 = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f8a = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f8b = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f8c = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f8d = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f8e = 0x00 (modified bits = 0x00)

						// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
						*(uint8_t*)0x10000f8f = 0x00 (modified bits = 0x00)

						// At 0x000021bc branching to 0x00002d5f (reg14)

						// Branch from 0x00002d60 to 0x000040f4 (Set LR to 0x00002d65)

						// Ensure that ADC clock is enabled
						// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | 0x00002000; // = 0x0c09617f (modified bits = 0x00000000)

						// At 0x00004100 branching to 0x00002d65 (reg14)

						// Branch from 0x00002d64 to 0x00004cbc (Set LR to 0x00002d69)

						/**
						 * Read all ADC Data Registers to clear DONE bits.
						 */
						// void clrAllAdcDataRegs()
						{
							// Save reg3 to Stack at 0x10001fa0 (Value saved is 0x00002000)
							// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00002d69)
							// Stack Pointer updated to 0x10001fa0

							// MemRead ADC: DR0 (address was computed as 0x4001c000 + 0x00000010)
							// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
							*(uint16_t*)SP = *(uint32_t*)0x4001c010; // = 0x0000 (modified bits = 0x2000)

							// MemRead ADC: DR1 (address was computed as 0x4001c004 + 0x00000010)
							// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
							*(uint16_t*)SP = *(uint32_t*)0x4001c014; // = 0x0000 (modified bits = 0x0000)

							// MemRead ADC: DR2 (address was computed as 0x4001c008 + 0x00000010)
							// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
							*(uint16_t*)SP = *(uint32_t*)0x4001c018; // = 0x0000 (modified bits = 0x0000)

							// MemRead ADC: DR3 (address was computed as 0x4001c00c + 0x00000010)
							// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
							*(uint16_t*)SP = *(uint32_t*)0x4001c01c; // = 0x0000 (modified bits = 0x0000)

							// MemRead ADC: DR4 (address was computed as 0x4001c010 + 0x00000010)
							// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
							*(uint16_t*)SP = *(uint32_t*)0x4001c020; // = 0x0000 (modified bits = 0x0000)

							// MemRead ADC: DR5 (address was computed as 0x4001c014 + 0x00000010)
							// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
							*(uint16_t*)SP = *(uint32_t*)0x4001c024; // = 0x0000 (modified bits = 0x0000)

							// MemRead ADC: DR6 (address was computed as 0x4001c018 + 0x00000010)
							// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
							*(uint16_t*)SP = *(uint32_t*)0x4001c028; // = 0x0000 (modified bits = 0x0000)

							// MemRead ADC: DR7 (address was computed as 0x4001c01c + 0x00000010)
							// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
							*(uint16_t*)SP = *(uint32_t*)0x4001c02c; // = 0x0000 (modified bits = 0x0000)
						}
						// Restore reg3 from Stack at 0x10001fa0 (Value saved was 0x00000000)
						// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00002d69)
						// Stack Pointer updated to 0x10001fa8

						// MemRead 8 kB SRAM0 (address was computed as 0x10000fb0 + 0x00000000)
						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fb0 - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d76
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000fb0 + 0x00000004)
						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fb4 - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d76
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000fb0 + 0x00000008)
						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fb8 - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d76
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000fb0 + 0x0000000c)
						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fbc - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d76
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000fb0 + 0x00000010)
						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fc0 - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d76
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000fb0 + 0x00000014)
						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fc4 - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d76
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000fb0 + 0x00000018)
						// Compute 0x00003bf5 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fc8 - 0x00000000) is Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d7a
						}

						// At 0x00002d78 branching to 0x00003bf5 (*(uint32_t*)0x10000fc8). LR set to 0x00002d7a
						// void fnc()
						{
							// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000006)
							// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00002d7b)
							// Stack Pointer updated to 0x10001fa0

							// Branch from 0x00003bf8 to 0x0000705c (Set LR to 0x00003bfd)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000203 + 0x00000000)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000205 + 0x00000000)
							// MemRead GPIO: P1_12 PBYTE (address was computed as (uint32_t)*(uint8_t*)0x10000203 << 5 + 0x50000000 + *(uint8_t*)0x10000205)
							// Compute 0x00000000 - 0x00000000 for compare
							if (*(uint8_t*)0x5000002c - 0x00000000) is NOT Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00007074
							}

							// At 0x00007076 branching to 0x00003bfd (reg14)

							// MemRead 128 kB on-chip flash (address encoded in instruction)
							reg4 = *(uint32_t*)0x00003c14; // = 0x100002ac

							// MemRead 8 kB SRAM0 (address was computed as 0x10000203 + 0x00000000)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000205 + 0x00000000)
							// MemRead GPIO: P1_12 PBYTE (address was computed as (uint32_t)*(uint8_t*)0x10000203 << 5 + 0x50000000 + *(uint8_t*)0x10000205)
							// Compute 0x00000000 - 0x00000000 for compare
							if (*(uint8_t*)0x5000002c - 0x00000000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00003c0c
							}

							// Branch from 0x00003c04 to 0x0000705c (Set LR to 0x00003c09)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000203 + 0x00000001)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000205 + 0x00000001)
							// MemRead GPIO: P0_18 PBYTE (address was computed as ((uint32_t)*(uint8_t*)0x10000204 << 5) + 0x50000000 + *(uint8_t*)0x10000206)
							// Compute 0x00000000 - 0x00000000 for compare
							if (*(uint8_t*)0x50000012 - 0x00000000) is NOT Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00007074
							}

							// At 0x00007076 branching to 0x00003c09 (reg14)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000203 + 0x00000001)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000205 + 0x00000001)
							// MemRead GPIO: P0_18 PBYTE (address was computed as ((uint32_t)*(uint8_t*)0x10000204 << 5) + 0x50000000 + *(uint8_t*)0x10000206)
							// Compute 0x00000000 - 0x00000000 for compare
							if (*(uint8_t*)0x50000012 - 0x00000000) is NOT Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00003c0c
							}

							// MemRead 8 kB SRAM0 (address was computed as 0x10000203 + 0x00000001)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000205 + 0x00000001)
							// MemRead GPIO: P0_18 PBYTE (address was computed as ((uint32_t)*(uint8_t*)0x10000204 << 5) + 0x50000000 + *(uint8_t*)0x10000206)
							// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000007)
							*(uint8_t*)0x100002b3 = *(uint8_t*)0x50000012; // = 0x00 (modified bits = 0x00)

						}
						// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000006)
						// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00002d7b)
						// Stack Pointer updated to 0x10001fa8

						// MemRead 8 kB SRAM0 (address was computed as 0x10000fb0 + 0x0000001c)
						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fcc - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d76
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
						// Compute 0x00000040 - 0x00000000 for compare
						if (*(uint8_t*)0x10000012 - 0x00000000) is Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00002d8e
						}

						// Branch from 0x00002d8a to 0x0000402c (Set LR to 0x00002d8f)
						/**
						 * \param arg0 = base address of ADC to control?
						 * \param arg1 = enable ADC (in burst mode)?
						 */
						// void startAdcConversions(uint32_t arg0 (= 0x4001c000), uint32_t arg1 (= 0x00000001))
						{
							// Save reg4 to Stack at 0x10001f9c (Value saved is 0x00000008)
							// Save reg5 to Stack at 0x10001fa0 (Value saved is 0x10000010)
							// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00002d8f)
							// Stack Pointer updated to 0x10001f9c

							// Branch from 0x00004034 to 0x0000e6e8 (Set LR to 0x00004039)

							// Make sure an A/D conversion is not started right now
							// MemRead ADC: CR (address was computed as (arg0) 0x4001c000 + 0x00000000)
							// MemWrite ADC: CR (address was computed as (arg0) 0x4001c000 + 0x00000000)
							*(uint32_t*)0x4001c000 = 0x00000000 | (*(uint32_t*)0x4001c000 & ~0x07000000); // = 0x00200a40 (modified bits = 0x00000000)

							// At 0x0000e6f6 branching to 0x00004039 (reg14)

							// Compute 0x00000001 - 0x00000000 for compare
							if (arg1 - 0x00000000) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00004048
							}

							// Set BURST to 1 and enable hardware scan mode (i.e. repeatedly start scanning AD6)
							// MemRead ADC: CR (address was computed as (arg0) 0x4001c000 + 0x00000000)
							// 0x00210a40 = 0x00200a40 | 0x00010000;
							// MemWrite ADC: CR (address was computed as (arg0) 0x4001c000 + 0x00000000)
							*(uint32_t*)0x4001c000 = *(uint32_t*)0x4001c000 | 0x00010000; // = 0x00210a40 (modified bits = 0x00010000)

						}
						// Restore reg4 from Stack at 0x10001f9c (Value saved was 0x00000008)
						// Restore reg5 from Stack at 0x10001fa0 (Value saved was 0x10000010)
						// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00002d8f)
						// Stack Pointer updated to 0x10001fa8

					}
					// Restore reg4 from Stack at 0x10001fa8 (Value saved was 0x10000010)
					// Restore reg5 from Stack at 0x10001fac (Value saved was 0x00000001)
					// Restore reg6 from Stack at 0x10001fb0 (Value saved was 0x00010074)
					// Restore PC from Stack at 0x10001fb4 (Value saved was 0x00002cfd)
					// Stack Pointer updated to 0x10001fb8

					// Branching from PC = 0x00002cfc to PC = 0x00002d00

					// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000000)
					// Compute 0x00000000 - 0x00000000 for compare
					while (*(uint8_t*)0x10000010 - 0x00000000) is Equal, Z == 1
					{
						// execute 0x00002cfe

						// Wait for interrupt (i.e. ADC interrupt has some work to do)
						__wfi();
					}

					// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000001)
					*(uint8_t*)0x10000011 = 0x00 (modified bits = 0x01)

					// Branch from 0x00002d0a to 0x00004d3c (Set LR to 0x00002d0f)
					// void fnc()
					{
						// Save reg3 to Stack at 0x10001fa0 (Value saved is 0x07000000)
						// Save reg4 to Stack at 0x10001fa4 (Value saved is 0x10000010)
						// Save reg5 to Stack at 0x10001fa8 (Value saved is 0x00000001)
						// Save reg6 to Stack at 0x10001fac (Value saved is 0x00010074)
						// Save reg7 to Stack at 0x10001fb0 (Value saved is 0x00000000)
						// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x00002d0f)
						// Stack Pointer updated to 0x10001fa0

						// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
						// Compute 0x00000001 & 0x00000040 for compare
						if (0x00000001 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d54
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
						// Compute 0x00000002 & 0x00000040 for compare
						if (0x00000002 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d54
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
						// Compute 0x00000004 & 0x00000040 for compare
						if (0x00000004 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d54
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
						// Compute 0x00000008 & 0x00000040 for compare
						if (0x00000008 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d54
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
						// Compute 0x00000010 & 0x00000040 for compare
						if (0x00000010 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d54
						}

						// Compute 0x00000020 & 0x00000040 for compare
						if (0x00000020 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d54
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
						// Compute 0x00000040 & 0x00000040 for compare
						if (0x00000040 & *(uint8_t*)0x10000012) is Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d68
						}

						// MemRead 8 kB SRAM0 (address was computed as 0x10000f80 + 0x0000000c)
						// 0x00000000 = 0x00000000 >> 3 (Carry Out = 0x00000000)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000f80 + 0x0000000c)
						*(uint16_t*)0x10000f8c = (uint32_t)(*(uint16_t*)0x10000f8c) >> 3; // = 0x0000 (modified bits = 0x0000)

						// MemRead 8 kB SRAM0 (address was computed as 0x10000f90 + 0x00000018)
						// Compute 0x00003b49 - 0x00000000 for compare
						if (*(uint32_t*)0x10000fa8 - 0x00000000) is Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d68
						}

						// At 0x00004d66 branching to 0x00003b49 (*(uint32_t*)0x10000fa8). LR set to 0x00004d68

						// void fnc(arg0 = 0x00000006 (AD#? Unused?), arg1 = (uint32_t)(*(uint16_t*)0x10000f8c) >> 3 (accumualted AD results?))
						{
							// Save reg3 to Stack at 0x10001f88 (Value saved is 0x07000000)
							// Save reg4 to Stack at 0x10001f8c (Value saved is 0x00000006)
							// Save reg5 to Stack at 0x10001f90 (Value saved is 0x10000f80)
							// Save reg6 to Stack at 0x10001f94 (Value saved is 0x00000001)
							// Save reg7 to Stack at 0x10001f98 (Value saved is 0x10000f90)
							// Save reg14 to Stack at 0x10001f9c (Value saved is 0x00004d69)
							// Stack Pointer updated to 0x10001f88

							// MemRead 8 kB SRAM0 (address was computed as 0x10000f80 + 0x0000000c)
							reg5 = arg1; // = 0x00000000

							// Branch from 0x00003b4e to 0x0000705c (Set LR to 0x00003b53)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000203 + 0x00000000)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000205 + 0x00000000)
							// MemRead GPIO: P1_12 PBYTE (address was computed as ((uint32_t)*(uint8_t*)0x10000203 << 5) + 0x50000000 + *(uint8_t*)0x10000205)
							// Compute 0x00000001 - 0x00000000 for compare
							if (*(uint8_t*)0x5000002c - 0x00000000) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00007076
							}

							// At 0x00007076 branching to 0x00003b53 (reg14)

							// Branching from PC = 0x00003b62 to PC = 0x00003b66

							// MemRead 8 kB SRAM0 (address was computed as 0x100002ac + 0x00000007)
							// 0x00000001 = 0x00000001 | 0x00000001;
							reg2 = 0x00000001 | *(uint8_t*)0x100002b3;

							NOT Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00003b6e
							}

						}
						// Restore reg3 from Stack at 0x10001f88 (Value saved was 0x07000000)
						// Restore reg4 from Stack at 0x10001f8c (Value saved was 0x00000006)
						// Restore reg5 from Stack at 0x10001f90 (Value saved was 0x10000f80)
						// Restore reg6 from Stack at 0x10001f94 (Value saved was 0x00000001)
						// Restore reg7 from Stack at 0x10001f98 (Value saved was 0x10000f90)
						// Restore PC from Stack at 0x10001f9c (Value saved was 0x00004d69)
						// Stack Pointer updated to 0x10001fa0

						// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
						// Compute 0x00000080 & 0x00000040 for compare
						if (0x00000080 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x00004d54
						}
					}
					// Restore reg3 from Stack at 0x10001fa0 (Value saved was 0x07000000)
					// Restore reg4 from Stack at 0x10001fa4 (Value saved was 0x10000010)
					// Restore reg5 from Stack at 0x10001fa8 (Value saved was 0x00000001)
					// Restore reg6 from Stack at 0x10001fac (Value saved was 0x00010074)
					// Restore reg7 from Stack at 0x10001fb0 (Value saved was 0x00000000)
					// Restore PC from Stack at 0x10001fb4 (Value saved was 0x00002d0f)
					// Stack Pointer updated to 0x10001fb8

				}
				// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005e05)
				// Stack Pointer updated to 0x10001fc0

				// Branch from 0x00005e04 to 0x00007b70 (Set LR to 0x00005e09)
				// int checkUsbVBus()
				{
					// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005e09)
					// Stack Pointer updated to 0x10001fb8

					// Branch from 0x00007b7a to 0x00004214 (Set LR to 0x00007b7f)

					// MemRead GPIO: P0_3 PBYTE (address was computed as 0x50000000 + 0x00000003)
					ret = *(uint8_t*)0x50000003; // = 0x00000000

					// Compute 0x00000000 - 0x00000000 for compare
					if (ret - 0x00000000) is NOT Equal, Z == 1
					{
						// UNKOWN PATH execute 0x0000421e
					}

					// At 0x00004220 branching to 0x00007b7f (reg14)

				}
				// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005e09)
				// Stack Pointer updated to 0x10001fc0

				// Compute 0x00000000 - 0x00000000 for compare
				if (ret - 0x00000000) is Not equal, Z == 0
				{
					// UNKOWN PATH execute 0x00005e68
				}

				// Branch from 0x00005e0c to 0x00007ad8 (Set LR to 0x00005e11)

				// At 0x00007adc branching to 0x00005e11 (reg14)

				// MemRead 8 kB SRAM0 (address was computed as 0x100002ac + 0x00000006)
				// Compute 0x00000001 - 0x00000000 for compare
				if (*(uint8_t*)0x100002b2 - 0x00000000) is NOT Not equal, Z == 0
				{
					// UNKOWN PATH execute 0x00005e14
				}

				// Branch from 0x00005e1e to 0x00007d52 (Set LR to 0x00005e23)

				// Branch from 0x00007d52 to 0x00009b4c (Set LR to 0x00007d57)

				// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				*(uint8_t*)0x10000340 = *(uint8_t*)0x10000340 + 0x00000001; // = 0x01 (modified bits = 0x01)

				// At 0x00009b56 branching to 0x00007d57 (reg14)

				// Branch from 0x00007d58 to 0x00006f60 (Set LR to 0x00007d5d)
				// void fnc(arg0 = 0)
				{
					// Save reg4 to Stack at 0x10001fb0 (Value saved is 0x00010074)
					// Save reg5 to Stack at 0x10001fb4 (Value saved is 0x00000001)
					// Save reg6 to Stack at 0x10001fb8 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00007d5d)
					// Stack Pointer updated to 0x10001fb0

					// Branch from 0x00006f64 to 0x00009b4c (Set LR to 0x00006f69)

					// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
					// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
					*(uint8_t*)0x10000340 = *(uint8_t*)0x10000340 + 0x00000001; // = 0x02 (modified bits = 0x03)

					// At 0x00009b56 branching to 0x00006f69 (reg14)

					// MemRead 8 kB SRAM0 (address was computed as 0x10000200 + 0x00000002)
					// Compute 0x00000000 - 0x00000000 for compare
					if (arg0 - *(uint8_t*)0x10000202) is NOT Equal, Z == 1
					{
						// UNKOWN PATH execute 0x00006f70
					}

					// Branch from 0x00006f80 to 0x00009b70 (Set LR to 0x00006f85)

					// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
					// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
					*(uint8_t*)0x10000340 = (uint32_t)((uint32_t)(*(uint8_t*)0x10000340 - 0x00000001) << 24) >> 24;; // = 0x01 (modified bits = 0x03)

					NOT Not equal, Z == 0
					{
						// UNKOWN PATH execute 0x00009b7e
					}

					// At 0x00009b80 branching to 0x00006f85 (reg14)

				}
				// Restore reg4 from Stack at 0x10001fb0 (Value saved was 0x00010074)
				// Restore reg5 from Stack at 0x10001fb4 (Value saved was 0x00000001)
				// Restore reg6 from Stack at 0x10001fb8 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fbc (Value saved was 0x00007d5d)
				// Stack Pointer updated to 0x10001fc0

				// Branch from 0x00007d5e to 0x00007b98 (Set LR to 0x00007d63)
				// void fnc(arg0 = 0)
				{
					// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00007d63)
					// Stack Pointer updated to 0x10001fb8

					// MemRead 8 kB SRAM0 (address was computed as 0x100002ac + 0x00000002)
					// Compute 0x00000001 - 0x00000000 for compare
					if (*(uint8_t*)0x100002ae - 0x00000000) is Equal, Z == 1
					{
						// UNKOWN PATH execute 0x00007bae
					}

					// MemRead 8 kB SRAM0 (address was computed as 0x100002ac + 0x00000000)
					// MemRead 8 kB SRAM0 (address was computed as 0x100002ac + 0x00000001)
					// MemWrite GPIO: P1_10 PBYTE (address was computed as (uint32_t)*(uint8_t*)0x100002ac << 5 + 0x50000000 + *(uint8_t*)0x100002ad)
					*(uint8_t*)0x5000002a = arg0 ^ 0x00000001; // = 0x01 (modified bits = 0x01)

				}
				// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fbc (Value saved was 0x00007d63)
				// Stack Pointer updated to 0x10001fc0

				// Branch from 0x00007d62 to 0x0000521c (Set LR to 0x00007d67)
				// void fnc()
				{
					// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00007d67)
					// Stack Pointer updated to 0x10001fb8

					// Branch from 0x00005220 to 0x0000452c (Set LR to 0x00005225)

					// Make sure BOD is powered
					// MemRead system control: PDRUNCFG (address was computed as 0x40048200 + 0x00000038)
					// MemWrite system control: PDRUNCFG (address was computed as 0x40048200 + 0x00000038)
					*(uint32_t*)0x40048238 = ((*(uint32_t*)0x40048238 & 0x000005ff) & ~0x00000008) | 0x0000e800; // = 0x0000e840 (modified bits = 0x00000000)

					// At 0x00004540 branching to 0x00005225 (reg14)

					// MemWrite system control: BODCTRL (address was computed as 0x40048140 + 0x00000010)
					*(uint32_t*)0x40048150 = 0x00000006; // = 0x00000006 (modified bits = 0x00000010)

					// MemWrite system control: SYSRSTSTAT (address was computed as 0x40048000 + 0x00000030)
					*(uint32_t*)0x40048030 = 0x00000008 (modified bits = 0x00000000)

					// MemRead system control: BODCTRL (address was computed as 0x40048140 + 0x00000010)
					// MemWrite system control: BODCTRL (address was computed as 0x40048140 + 0x00000010)
					*(uint32_t*)0x40048150 = *(uint32_t*)0x40048150 | 0x00000010; // = 0x00000016 (modified bits = 0x00000010)

				}
				// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fbc (Value saved was 0x00007d67)
				// Stack Pointer updated to 0x10001fc0

				// Just loop on wfi... Will an ISR change anything at this point?
				// Or are we just waiting for system to power down because something 
				//  key related to powered the controller has failed?
				while(1) {
					__wfi();
				}
			}

			// Branch from 0x00005de4 to 0x0000a934 (Set LR to 0x00005de9)

			{
				// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005de9)
				// Stack Pointer updated to 0x10001fb8

				// Branch from 0x0000a938 to 0x00009b5c (Set LR to 0x0000a93d)

				// MemRead 128 kB on-chip flash (address encoded in instruction)
				// MemRead 8 kB SRAM0 (address was computed as 0x100000a4 + 0x00000000)
				reg0 = *(uint32_t*)0x100000a4; // = 0x02dc6c00

				// At 0x00009b60 branching to 0x0000a93d (reg14)

				reg1 = 0x000f4240

				// Branch from 0x0000a93e to 0x000020ec (Set LR to 0x0000a943)
				// int fnc(arg0 = System Clock Frequency (0x02dc6c00), arg1 = ?? (0x000f4240))
				{
					// Save reg4 to Stack at 0x10001fac (Value saved is 0x00000064)
					// Save reg5 to Stack at 0x10001fb0 (Value saved is 0x00000001)
					// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x0000a943)
					// Stack Pointer updated to 0x10001fac

					// Branching from PC = 0x000020f8 to PC = 0x0000210e

					// Compute 0x00000000 - 0x000f4240 for compare
					if (((uint32_t)arg0 >> 0x0000001f) - arg1) is NOT Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x00002102
					}

					// Compute 0x00000000 - 0x000f4240 for compare
					if (((uint32_t)arg0 >> 0x0000001e) - arg1) is NOT Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x00002102
					}

					...

					// Compute 0x0016e360 - 0x000f4240 for compare
					if ((uint32_t()arg0 >> 0x00000005) - arg1) is Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x0000210e
					}

					// Compute 0x000f4240 - 0x000f4240 for compare
					if (((uint32_t)(arg0 - ((uint32_t)arg1 << 0x00000005)) >> 0x00000004) - arg1) is Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x0000210e
					}

					ret = 0x00000030

					// Compute 0x00000000 - 0x000f4240 for compare
					if (((uint32_t)((arg0 - ((uint32_t)arg1 << 0x00000005)) - ((uint32_t)arg1 << 0x00000004)) >> 0x00000003) - arg1) is NOT Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x00002102
					}

					// Compute 0x00000000 - 0x000f4240 for compare
					if (((uint32_t)((arg0 - ((uint32_t)arg1 << 0x00000005)) - ((uint32_t)arg1 << 0x00000004)) >> 0x00000002) - arg1) is NOT Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x00002102
					}

					// Compute 0x00000000 - 0x000f4240 for compare
					if (((uint32_t)((arg0 - ((uint32_t)arg1 << 0x00000005)) - ((uint32_t)arg1 << 0x00000004)) >> 0x00000001) - arg1) is NOT Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x00002102
					}

					// Compute 0x00000000 - 0x000f4240 for compare
					if (((uint32_t)((arg0 - ((uint32_t)arg1 << 0x00000005)) - ((uint32_t)arg1 << 0x00000004)) >> 0x00000000) - arg1) is NOT Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x00002102
					}
				}
				// Restore reg4 from Stack at 0x10001fac (Value saved was 0x00000064)
				// Restore reg5 from Stack at 0x10001fb0 (Value saved was 0x00000001)
				// Restore PC from Stack at 0x10001fb4 (Value saved was 0x0000a943)
				// Stack Pointer updated to 0x10001fb8

				// Compute something with return value, but then just destroy it???
				// 0x000012c0 = 0x00000064 * 0x00000030;
				reg0 = 0x00000064 * ret;

				reg1 = 0x000012c0; // = zeroExtend16(fields.m)

				reg0 = 0x00000000; // (fields.imm)

				// Branch from 0x0000a948 to 0x00005174 (Set LR to 0x0000a94d)
				// ?? fnc(arg0 ??, arg1 = (0x000012c0)
				{
					// Save reg0 to Stack at 0x10001f9c (Value saved is 0x00000000)
					// Save reg1 to Stack at 0x10001fa0 (Value saved is 0x000012c0)
					// Save reg4 to Stack at 0x10001fa4 (Value saved is 0x00000064)
					// Save reg5 to Stack at 0x10001fa8 (Value saved is 0x00000001)
					// Save reg6 to Stack at 0x10001fac (Value saved is 0x00010074)
					// Save reg7 to Stack at 0x10001fb0 (Value saved is 0x00000000)
					// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x0000a94d)
					// Stack Pointer updated to 0x10001f9c

					reg13 = 0x10001f98; // = SP - 0x00000004

					// MemRead 8 kB SRAM0 (address was computed as 0x10000000 + 0x00000000)
					// Compute 0x00000000 - 0x00000000 for compare
					if (*(uint8_t*)0x10000000 - 0x00000000) is Not equal, Z == 0
					{
						// UNKOWN PATH execute 0x0000518a
					}

					// MemWrite 8 kB SRAM0 (address was computed as 0x10000000 + 0x00000000)
					*(uint8_t*)0x10000000 = 0x01 (modified bits = 0x01)

					// Branch from 0x00005186 to 0x0000600c (Set LR to 0x0000518b)

					{
						// Save reg4 to Stack at 0x10001f90 (Value saved is 0x10000000)
						// Save reg14 to Stack at 0x10001f94 (Value saved is 0x0000518b)
						// Stack Pointer updated to 0x10001f90

						// Branch from 0x00006012 to 0x000045bc (Set LR to 0x00006017)

						{
							// Save reg4 to Stack at 0x10001f88 (Value saved is 0x4000c000)
							// Save reg14 to Stack at 0x10001f8c (Value saved is 0x00006017)
							// Stack Pointer updated to 0x10001f88

							// Branch from 0x000045be to 0x0000458c (Set LR to 0x000045c3)

							// At 0x0000459e branching to 0x000045c3 (reg14)

							// Enables clock for 16-bit counter/timer 0
							// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | 0x00000080; // = 0x0c0961ff (modified bits = 0x00000080)

						}
						// Restore reg4 from Stack at 0x10001f88 (Value saved was 0x4000c000)
						// Restore PC from Stack at 0x10001f8c (Value saved was 0x00006017)
						// Stack Pointer updated to 0x10001f90

						// Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches 0 the TC.
						// MemRead CT16B0: MCR (address was computed as 0x4000c000 + 0x00000014)
						// MemWrite CT16B0: MCR (address was computed as 0x4000c000 + 0x00000014)
						*(uint32_t*)0x4000c014 = *(uint32_t*)0x4000c014 | 0x00000004; // = 0x00000004 (modified bits = 0x00000004)

						// Clear interrupt pending for CT16B0
						// MemWrite NVIC: ICPR0 (address was computed as = 0xe000e280 + 0x00000000)
						*(uint32_t*)0xe000e280 = 0x00010000; // = 0x00010000 (modified bits = 0x00010002)

						// Enable interrupt for CT16B0
						// MemWrite NVIC: ISER0 (address was computed as 0xe000e100 + 0x00000000)
						*(uint32_t*)0xe000e100 = 0x00010000; // = 0x00010000 (modified bits = 0x01010000)

						// Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.
						// MemRead CT16B0: MCR (address was computed as 0x4000c000 + 0x00000014)
						// MemWrite CT16B0: MCR (address was computed as 0x4000c000 + 0x00000014)
						*(uint32_t*)0x4000c014 = *(uint32_t*)0x4000c014 | 0x00000001; // = 0x00000005 (modified bits = 0x00000001)

						reg3 = 0x00000000

						reg2 = 0x00009621

						reg1 = 0x00000000

						reg0 = 0x4000c000

						// Branch from 0x00006038 to 0x0000a0fc (Set LR to 0x0000603d)
						// void fnc(arg0, arg1, arg2, arg3)
						{
							// Save reg4 to Stack at 0x10001f80 (Value saved is 0x4000c000)
							// Save reg5 to Stack at 0x10001f84 (Value saved is 0x00000001)
							// Save reg6 to Stack at 0x10001f88 (Value saved is 0x00000001)
							// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000603d)
							// Stack Pointer updated to 0x10001f80

							// Branch from 0x0000a104 to 0x000056fc (Set LR to 0x0000a109)

							// Compute 0x4000c000 - 0x4000c000 for compare
							if (arg0 - 0x4000c000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00005706
							}

							// At 0x00005704 branching to 0x0000a109 (reg14)

							// MemWrite 8 kB SRAM0 (address was computed as 0x10000818 + ((uint32_t)arg1 << 2))
							*(uint32_t*)0x10000818 = arg2; // = 0x00009621 (modified bits = 0x00009621)

							// MemWrite 8 kB SRAM0 (address was computed as 0x100007e8 + 0x00000000)
							*(uint32_t*)0x100007e8 = arg3; // = 0x00000000 (modified bits = 0x00000000)

						}
						// Restore reg4 from Stack at 0x10001f80 (Value saved was 0x4000c000)
						// Restore reg5 from Stack at 0x10001f84 (Value saved was 0x00000001)
						// Restore reg6 from Stack at 0x10001f88 (Value saved was 0x00000001)
						// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000603d)
						// Stack Pointer updated to 0x10001f90

						// Make sure counters are disabled
						// MemRead CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
						// MemWrite CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
						*(uint32_t*)0x4000c004 = ((uint32_t)((uint32_t)(*(uint32_t*)0x4000c004) >> 1) << 1); // = 0x00000000 (modified bits = 0x00000000)

					}
					// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x10000000)
					// Restore PC from Stack at 0x10001f94 (Value saved was 0x0000518b)
					// Stack Pointer updated to 0x10001f98

					// MemWrite 8 kB SRAM0 (address was computed as 0x10000000 + 0x00000001)
					*(uint8_t*)0x10000001 = 0x00 (modified bits = 0x00)

					reg0 = 0x4000c000

					// Branch from 0x00005192 to 0x000045bc (Set LR to 0x00005197)
					// void fnc(arg0 = Ctrl register base)
					{
						// Save reg4 to Stack at 0x10001f90 (Value saved is 0x10000000)
						// Save reg14 to Stack at 0x10001f94 (Value saved is 0x00005197)
						// Stack Pointer updated to 0x10001f90

						// Branch from 0x000045be to 0x0000458c (Set LR to 0x000045c3)

						// At 0x0000459e branching to 0x000045c3 (reg14)

						// Ensure clock for 16-bit counter/timer 0 is enabled
						// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | 0x00000080; // = 0x0c0961ff (modified bits = 0x00000000)

					}
					// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x10000000)
					// Restore PC from Stack at 0x10001f94 (Value saved was 0x00005197)
					// Stack Pointer updated to 0x10001f98

					// Set Match register 0 (defines when CT16B0 interrupt will occur)
					// MemWrite CT16B0: MR0 (address was computed as 0x4000c000 + 0x00000018)
					*(uint32_t*)0x4000c018 = arg1; // = 0x000012c0 (modified bits = 0x000012c0)

					// Some stack value (returned from function maybe?) defines Prescale Register value
					// MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000004)
					// MemWrite CT16B0: PR (address was computed as 0x4000c000 + 0x0000000c)
					*(uint32_t*)0x4000c00c = *(uint32_t*)0x10001f9c; // = 0x00000000 (modified bits = 0x00000000)

					// Branch from 0x0000519e to 0x000045e4 (Set LR to 0x000051a3)

					// Save TCR
					// MemRead CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
					tcr = *(uint32_t*)0x4000c004; // = 0x00000000

					// Disable counters 
					// MemWrite CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
					*(uint32_t*)0x4000c004 = 0x00000000; // = 0x00000000 (modified bits = 0x00000000)

					// Set timer counter to 1
					// MemWrite CT16B0: TC (address was computed as 0x4000c000 + 0x00000008)
					*(uint32_t*)0x4000c008 = 0x00000001 (modified bits = 0x00000001)

					// Reset timer counter and prescale counter
					// MemWrite CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
					*(uint32_t*)0x4000c004 = 0x00000002 (modified bits = 0x00000002)

					// Wait for timer counter to be reset
					// MemRead CT16B0: TC (address was computed as 0x4000c000 + 0x00000008)
					// Compute 0x00000000 - 0x00000000 for compare
					if (*(uint32_t*)0x4000c008 - 0x00000000) is Not equal, Z == 0
					{
						// UNKOWN PATH execute 0x000045f2
					}

					// Resestablish TCR 
					// MemWrite CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
					*(uint32_t*)0x4000c004 = tcr ; // = 0x00000000 (modified bits = 0x00000002)

					// At 0x000045fa branching to 0x000051a3 (reg14)

					// Enable counters
					// MemRead CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
					// MemWrite CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
					*(uint32_t*)0x4000c004 = *(uint32_t*)0x4000c004 | 0x00000001; // = 0x00000001 (modified bits = 0x00000001)

					// Branching from PC = 0x000051a8 to PC = 0x000051ac

					// Wait for CT16B0 IRQ to fire with match on channel 0
					// MemRead 8 kB SRAM0 (address was computed as 0x10000000 + 0x00000001)
					// Compute 0x00000001 - 0x00000000 for compare
					while (*(uint8_t*)0x10000001 - 0x00000000) is Equal, Z == 1
					{
						// execute 0x000051aa
						__wfi();
					}

					reg0 = 0x4000c000

					// Branch from 0x000051b4 to 0x00004574 (Set LR to 0x000051b9)
					// void fnc(arg0 = base address)
					{
						// Save reg4 to Stack at 0x10001f90 (Value saved is 0x10000000)
						// Save reg14 to Stack at 0x10001f94 (Value saved is 0x000051b9)
						// Stack Pointer updated to 0x10001f90

						// Branch from 0x00004576 to 0x0000458c (Set LR to 0x0000457b)

						// Compute 0x4000c000 - 0x40018000 for compare
						if (arg0 - 0x40018000) is NOT Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x00004592
						}

						// Compute 0x4000c000 - 0x4000c000 for compare
						if (arg0 - 0x4000c000) is Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x000045a0
						}

						// At 0x0000459e branching to 0x0000457b (reg14)

						// Disable clock for CT16B0
						// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 & ~0x00000080; // = 0x0c09617f (modified bits = 0x00000080)

					}
					// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x10000000)
					// Restore PC from Stack at 0x10001f94 (Value saved was 0x000051b9)
					// Stack Pointer updated to 0x10001f98

				}
				// Restore reg1 from Stack at 0x10001f98 (Value saved was 0x000001f4)
				// Restore reg2 from Stack at 0x10001f9c (Value saved was 0x00000000)
				// Restore reg3 from Stack at 0x10001fa0 (Value saved was 0x000012c0)
				// Restore reg4 from Stack at 0x10001fa4 (Value saved was 0x00000064)
				// Restore reg5 from Stack at 0x10001fa8 (Value saved was 0x00000001)
				// Restore reg6 from Stack at 0x10001fac (Value saved was 0x00010074)
				// Restore reg7 from Stack at 0x10001fb0 (Value saved was 0x00000000)
				// Restore PC from Stack at 0x10001fb4 (Value saved was 0x0000a94d)
				// Stack Pointer updated to 0x10001fb8

			}
			// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005de9)
			// Stack Pointer updated to 0x10001fc0

			// Branch from 0x00005de8 to 0x0000a388 (Set LR to 0x00005ded)
			// void ConfigHapticsComms()
			{
				// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005ded)
				// Stack Pointer updated to 0x10001fb8

				// MemRead 2 kB SRAM1 (address was computed as 0x20000000 + 0x00000002)
				// Compute 0x00000002 - 0x00000000 for compare
				if (*(uint8_t*)0x20000002 - 0x00000000) is Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000a3ae
				}

				// MemRead 2 kB SRAM1 (address was computed as 0x20000000 + 0x00000000)
				// 0x00000000 = 0xffffffff + 0x00000001
				if ((int32_t)(*(int8_t*)0x20000000) + 0x00000001) is NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000a39a
				}

				// Branch from 0x0000a3aa to 0x000048bc (Set LR to 0x0000a3af)
				// void ConfigLeftAndRightHapticsComms()
				{
					// Save reg4 to Stack at 0x10001fa8 (Value saved is 0x00010074)
					// Save reg5 to Stack at 0x10001fac (Value saved is 0x00000001)
					// Save reg6 to Stack at 0x10001fb0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x0000a3af)
					// Stack Pointer updated to 0x10001fa8

					// MemRead 2 kB SRAM1 (address was computed as 0x20000000 + 0x00000002)
					// Compute 0x00000002 - 0x00000000 for compare
					if (*(uint8_t*)0x20000002 - 0x00000000) is 

					// MemRead 2 kB SRAM1 (address was computed as 0x20000000 + 0x00000002)
					// MemWrite 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000000)
					*(uint8_t*)0x10000234 = *(uint8_t*)0x20000002; // = 0x02 (modified bits = 0x02)

					Equal, Z == 1
					{
						// UNKOWN PATH execute 0x000048e6
					}

					// Branch from 0x000048c6 to 0x00008f50 (Set LR to 0x000048cb)
					// void setupSpiComms() (SSP/SPI0 setup for haptics comms?)
					{
						// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00010074)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000048cb)
						// Stack Pointer updated to 0x10001fa0

						// Branch from 0x00008f5c to 0x000043a4 (Set LR to 0x00008f61)

						// Set pin function to SCK0
						// MemWrite IOCON: PIO1_29 (address was computed as 0x40044074 + 0x00000060)
						*(uint32_t*)0x400440d4 = 0x00000001 (modified bits = 0x00000091)

						// At 0x000043ae branching to 0x00008f61 (reg14)

						// Branch from 0x00008f68 to 0x000043a4 (Set LR to 0x00008f6d)

						// Set pin function to MIS0
						// MemWrite IOCON: PIO0_8 (address was computed as 0x40044000 + 0x00000020)
						*(uint32_t*)0x40044020 = 0x00000001 (modified bits = 0x00000091)

						// At 0x000043b2 branching to 0x00008f6d (reg14)

						// Branch from 0x00008f74 to 0x000043a4 (Set LR to 0x00008f79)

						// Set pin function to MOSI0
						// MemWrite IOCON: PIO0_9 (address was computed as 0x40044000 + 0x00000024)
						*(uint32_t*)0x40044024 = 0x00000001 (modified bits = 0x00000091)

						// At 0x000043b2 branching to 0x00008f79 (reg14)

						// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
						// Branch from 0x00008f7c to 0x000043f4 (Set LR to 0x00008f81)
						// void cfgSpi(arg0 = sspCtrlRegBase (*(uint32_t*)0x10000254; // = 0x40040000))
						{
							// Save reg4 to Stack at 0x10001f90 (Value saved is 0x10000234)
							// Save reg5 to Stack at 0x10001f94 (Value saved is 0x10000234)
							// Save reg6 to Stack at 0x10001f98 (Value saved is 0x00010074)
							// Save reg14 to Stack at 0x10001f9c (Value saved is 0x00008f81)
							// Stack Pointer updated to 0x10001f90

							// Branch from 0x000043f8 to 0x000043d4 (Set LR to 0x000043fd)

							// Compute 0x40040000 - 0x40040000 for compare
							if (sspCtrlRegBase - 0x40040000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x000043de
							}

							// At 0x000043dc branching to 0x000043fd (reg14)

							// Enable clock for SSP0
							// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							// 0x0c09697f = 0x0c09617f | 0x00000800;
							// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | 0x00000800; // = 0x0c09697f (modified bits = 0x00000800)

							// Branch from 0x0000440e to 0x000044e0 (Set LR to 0x00004413)

							// Compute 0x40040000 - 0x40040000 for compare
							if (sspCtrlRegBase - 0x40040000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x000044ec
							}

							// Set SPI0_PCLK divider to 1 
							// MemWrite system control: SSP0CLKDIV (address was computed as 0x40048080 + 0x00000014)
							*(uint32_t*)0x40048094 = 0x00000001 (modified bits = 0x00000001)

							// At 0x000044ea branching to 0x00004413 (reg14)

							// Compute 0x40040000 - 0x40040000 for compare
							if (sspCtrlRegBase - 0x40040000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x0000441c
							}

							// Branching from PC = 0x0000441a to PC = 0x0000441e

							// Place SSP0 in reset
							// MemRead system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
							// 0x00000000 = 0x00000000 & ~0x00000001;
							// MemWrite system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
							*(uint32_t*)0x40048004 = *(uint32_t*)0x40048004 & ~0x00000001; // = 0x00000000 (modified bits = 0x00000000)

							// Remove SSP0 from reset
							// MemRead system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
							// 0x00000001 = 0x00000000 | 0x00000001;
							// MemWrite system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
							*(uint32_t*)0x40048004 = *(uint32_t*)0x40048004 | 0x00000001; // = 0x00000001 (modified bits = 0x00000001)

							// Set SPI controler to act as master on the bus
							// MemRead SSP/SPI0: Ctrl Reg 1 (address was computed as sspCtrlRegBase + 0x00000004)
							// 0x00000000 = 0x00000000 & ~0x00000004;
							// MemWrite SSP/SPI0: Ctrl Reg 1 (address was computed as sspCtrlRegBase + 0x00000004)
							*(uint32_t*)0x40040004 = *(uint32_t*)0x40040004 & ~0x00000004; // = 0x00000000 (modified bits = 0x00000000)

							// Set SPI data size to 8-bit word transfer size
							// MemRead SSP/SPI0: Ctrl Reg 0 (address was computed as sspCtrlRegBase + 0x00000000)
							// 0x00000000 = 0x00000000 >> 8 (Carry Out = 0x00000000)
							// 0x00000000 = 0x00000000 << 8 (Carry Out = 0x00000000)
							// 0x00000007 = 0x00000000 | 0x00000007;
							// MemWrite SSP/SPI0: Ctrl Reg 0 (address was computed as sspCtrlRegBase + 0x00000000)
							*(uint32_t*)0x40040000 = ((uint32_t)((uint32_t)(*(uint32_t*)0x40040000) >> 8) << 8) | 0x00000007; // = 0x00000007 (modified bits = 0x00000007)

							// Branch from 0x00004448 to 0x0000445c (Set LR to 0x0000444d)
							// void setSpiClkRate(arg0 = sspCtrlRegBase (0x40040000), arg1 = SPI clock rate? (0x000186a0))
							{
								// Save reg3 to Stack at 0x10001f78 (Value saved is 0x40040000)
								// Save reg4 to Stack at 0x10001f7c (Value saved is 0x40040000)
								// Save reg5 to Stack at 0x10001f80 (Value saved is 0x00000001)
								// Save reg6 to Stack at 0x10001f84 (Value saved is 0x00010074)
								// Save reg7 to Stack at 0x10001f88 (Value saved is 0x00000000)
								// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000444d)
								// Stack Pointer updated to 0x10001f78

								// Branch from 0x00004462 to 0x00004130 (Set LR to 0x00004467)
								// int getSysClkFreq()
								{
									// Save reg4 to Stack at 0x10001f70 (Value saved is 0x40040000)
									// Save reg14 to Stack at 0x10001f74 (Value saved is 0x00004467)
									// Stack Pointer updated to 0x10001f70

									// Check if main source clock is IRC Oscillator
									// MemRead system control: MAINCLKSEL (address was computed as 0x40048040 + 0x00000030)
									// 0xc0000000 = 0x00000003 << 30 (Carry Out = 0x00000000)
									// 0x00000003 = 0xc0000000 >> 30 (Carry Out = 0x00000000)
									if ((uint32_t)((uint32_t)*(uint32_t*)0x40048070 << 30) >> 30) Equal, Z == 1
									{
										// UNKOWN PATH execute 0x00004150
									}

									// Check if main source clock is PLL input
									// MemRead system control: MAINCLKSEL (address was computed as 0x40048040 + 0x00000030)
									// 0xc0000000 = 0x00000003 << 30 (Carry Out = 0x00000000)
									// 0x00000003 = 0xc0000000 >> 30 (Carry Out = 0x00000000)
									// Compute 0x00000003 - 0x00000001 for compare
									if (((uint32_t)((uint32_t)*(uint32_t*)0x40048070 << 30) >> 30) - 0x00000001) is Equal, Z == 1
									{
										// UNKOWN PATH execute 0x00004154
									}

									// Check if main source clock is Watchdog oscillator
									// MemRead system control: MAINCLKSEL (address was computed as 0x40048040 + 0x00000030)
									// 0xc0000000 = 0x00000003 << 30 (Carry Out = 0x00000000)
									// 0x00000003 = 0xc0000000 >> 30 (Carry Out = 0x00000000)
									// Compute 0x00000003 - 0x00000002 for compare
									if (((uint32_t)((uint32_t)*(uint32_t*)0x40048070 << 30) >> 30) - 0x00000002) is Equal, Z == 1
									{
										// UNKOWN PATH execute 0x0000415a
									}

									// Check if main source clock is Not PLL output
									// MemRead system control: MAINCLKSEL (address was computed as 0x40048040 + 0x00000030)
									// 0xc0000000 = 0x00000003 << 30 (Carry Out = 0x00000000)
									// 0x00000003 = 0xc0000000 >> 30 (Carry Out = 0x00000000)
									// Compute 0x00000003 - 0x00000003 for compare
									if (((uint32_t)((uint32_t)*(uint32_t*)0x40048070 << 30) >> 30) - 0x00000003) is Not equal, Z == 0
									{
										// UNKOWN PATH execute 0x0000414e
									}

									// Branch from 0x0000414a to 0x000041b0 (Set LR to 0x0000414f)
									// int calcSysClkFreq()	
									{
										// Save reg4 to Stack at 0x10001f68 (Value saved is 0x40040000)
										// Save reg14 to Stack at 0x10001f6c (Value saved is 0x0000414f)
										// Stack Pointer updated to 0x10001f68

										// Branch from 0x000041b2 to 0x00004188 (Set LR to 0x000041b7)

										// Check if System PLL clock source is IRC
										// MemRead system control: SYSPLLCLKSEL (address was computed as 0x40048040 + 0x00000000)
										// 0x40000000 = 0x00000001 << 30 (Carry Out = 0x00000000)
										// 0x00000001 = 0x40000000 >> 30 (Carry Out = 0x00000000)
										if ((uint32_t)((uint32_t)*(uint32_t*)0x40048040 << 30) >> 30) Equal, Z == 1
										{
											// UNKOWN PATH execute 0x0000419a
										}

										// Check if System PLL clock source is not Crystal Oscillator (SYSOSC)
										// MemRead system control: SYSPLLCLKSEL (address was computed as 0x40048040 + 0x00000000)
										// 0x40000000 = 0x00000001 << 30 (Carry Out = 0x00000000)
										// 0x00000001 = 0x40000000 >> 30 (Carry Out = 0x00000000)
										// Compute 0x00000001 - 0x00000001 for compare
										if (((uint32_t)((uint32_t)*(uint32_t*)0x40048040 << 30) >> 30) - 0x00000001) is NOT Equal, Z == 1
										{
											// UNKOWN PATH execute 0x00004196
										}

										// At 0x000041a2 branching to 0x000041b7 (reg14)


										// Branch from 0x000041bc to 0x00004168 (Set LR to 0x000041c1)

										// MemRead system control: SYSPLLCTRL (address was computed as 0x40048000 + 0x00000008)
										// 0x18000000 = 0x00000023 << 27 (Carry Out = 0x00000020)
										// 0x00000003 = 0x18000000 >> 27 (Carry Out = 0x00000000)
										// 0x00000004 = 0x00000003 + 0x00000001
										// 0x02dc6c00 = 0x00000004 * 0x00b71b00;
										sysClkFreq = (((uint32_t)((uint32_t)*(uint32_t*)0x40048008 << 27) >> 27) + 0x00000001) * 0x00b71b00;

										// At 0x00004172 branching to 0x000041c1 (reg14)

									}
									// Restore reg4 from Stack at 0x10001f68 (Value saved was 0x40040000)
									// Restore PC from Stack at 0x10001f6c (Value saved was 0x0000414f)
									// Stack Pointer updated to 0x10001f70

								}
								// Restore reg4 from Stack at 0x10001f70 (Value saved was 0x40040000)
								// Restore PC from Stack at 0x10001f74 (Value saved was 0x00004467)
								// Stack Pointer updated to 0x10001f78

								// Check if we are dealing with SSP0
								// Compute 0x40040000 - 0x40040000 for compare
								if (sspCtrlRegBase - 0x40040000) is Not equal, Z == 0
								{
									// UNKOWN PATH execute 0x00004472
								}

								// MemRead system control: SSP0CLKDIV (address was computed as 0x40048080 + 0x00000014)
								reg1 = *(uint32_t*)0x40048094; // = 0x00000001

								// Branching from PC = 0x00004470 to PC = 0x00004474

								// Some big loop for calculating clock register values. Not going to bother to convert to C any more than this...
								for (...) {
									// Branch from 0x00004474 to 0x000020ec (Set LR to 0x00004479)
									//  fnc(arg0 = sysClkFreq, arg1 = SSP0CLKDIV)
									{
										// Save reg4 to Stack at 0x10001f6c (Value saved is 0x40040000)
										// Save reg5 to Stack at 0x10001f70 (Value saved is 0x00000001)
										// Save reg14 to Stack at 0x10001f74 (Value saved is 0x00004479)
										// Stack Pointer updated to 0x10001f6c

										sys_clk_freq = sysClkFreq;

										retval = 0;
									
										for (int cnt = 0x20; cnt > 0; cnt--) {
											if (((uint32_t)sys_clk_freq >> (cnt-1)) - SSP0CLKDIV) is NOT Carry clear, C == 0
											{
												sys_clk_freq -= ((uint32_t)SSP0CLKDIV << (cnt-1));

												retval += ((uint32_t)0x00000001 << (cnt-1));
											}
										}
									}
									// Restore reg4 from Stack at 0x10001f6c (Value saved was 0x40040000)
									// Restore reg5 from Stack at 0x10001f70 (Value saved was 0x00000001)
									// Restore PC from Stack at 0x10001f74 (Value saved was 0x00004479)
									// Stack Pointer updated to 0x10001f78

									...
								}

								// Branch from 0x000044a4 to 0x000044b4 (Set LR to 0x000044a9)
								// void setSspClockRegs(arg0 = sspCtrlRegBase (0x40040000), arg1 = scr (0x000000ef), arg2 = clkPrescale (0x00000002))
								{
									// Save reg4 to Stack at 0x10001f70 (Value saved is 0x000000ef)
									// Save reg14 to Stack at 0x10001f74 (Value saved is 0x000044a9)
									// Stack Pointer updated to 0x10001f70

									// Set the Serial Clock Rate (SCR)
									// MemRead SSP/SPI0: Ctrl Reg 0 (address was computed as sspCtrlRegBase + 0x00000000)
									// 0xef000000 = 0x000000ef << 24 (Carry Out = 0x00000000)
									// 0x0000ef00 = 0xef000000 >> 16 (Carry Out = 0x00000000)
									// 0x00000007 = 0x00000007 & ~0x0000ff00;
									// 0x0000ef07 = 0x0000ef00 | 0x00000007;
									// MemWrite SSP/SPI0: Ctrl Reg 0 (address was computed as sspCtrlRegBase + 0x00000000)
									*(uint32_t*)0x40040000 = ((uint32_t)((uint32_t)scr << 24) >> 16) | (*(uint32_t*)0x40040000 & ~0x0000ff00); // = 0x0000ef07 (modified bits = 0x0000ef00)

									// Set the Clock Prescale Register
									// MemWrite SSP/SPI0: Clk Prescale Reg (address was computed as sspCtrlRegBase + 0x00000010)
									*(uint32_t*)0x40040010 = clkPrescale; // = 0x00000002 (modified bits = 0x00000002)

								}
								// Restore reg4 from Stack at 0x10001f70 (Value saved was 0x000000ef)
								// Restore PC from Stack at 0x10001f74 (Value saved was 0x000044a9)
								// Stack Pointer updated to 0x10001f78

							}
							// Restore reg3 from Stack at 0x10001f78 (Value saved was 0x02dc6c00)
							// Restore reg4 from Stack at 0x10001f7c (Value saved was 0x40040000)
							// Restore reg5 from Stack at 0x10001f80 (Value saved was 0x00000001)
							// Restore reg6 from Stack at 0x10001f84 (Value saved was 0x00010074)
							// Restore reg7 from Stack at 0x10001f88 (Value saved was 0x00000000)
							// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000444d)
							// Stack Pointer updated to 0x10001f90

						}
						// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x10000234)
						// Restore reg5 from Stack at 0x10001f94 (Value saved was 0x10000234)
						// Restore reg6 from Stack at 0x10001f98 (Value saved was 0x00010074)
						// Restore PC from Stack at 0x10001f9c (Value saved was 0x00008f81)
						// Stack Pointer updated to 0x10001fa0

						// Set SPI Clock Out Phase (CPHA) configuration option to 1
						// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
						// MemRead SSP/SPI0: Ctrl Reg 0 (address was computed as *(uint32_t*)0x10000254 + 0x00000000)
						// 0x000000ef = 0x0000ef07 >> 8 (Carry Out = 0x00000000)
						// 0x0000ef00 = 0x000000ef << 8 (Carry Out = 0x00000000)
						// 0x0000ef07 = 0x0000ef00 | 0x00000007;
						// 0x0000ef87 = 0x0000ef07 | 0x00000080;
						// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
						// MemWrite SSP/SPI0: Ctrl Reg 0 (address was computed as *(uint32_t*)0x10000254 + 0x00000000)
						*(uint32_t*)0x40040000 = (((uint32_t)((uint32_t)*(uint32_t*)0x40040000 >> 8) << 8) | 0x00000007) | 0x00000080; // = 0x0000ef87 (modified bits = 0x00000080)

						// Branch from 0x00008f94 to 0x000044ca (Set LR to 0x00008f99)

						// Branching from PC = 0x000044d4 to PC = 0x000044da

						// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
						// 0x00000000 = 0x00000000 & ~0x00000004;
						// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
						// MemWrite SSP/SPI0: Ctrl Reg 1 (address was computed as *(uint32_t*)0x10000254 + 0x00000004)
						*(uint32_t*)0x40040004 = *(uint32_t*)0x40040004 & ~0x00000004; // = 0x00000000 (modified bits = 0x00000000)

						// At 0x000044dc branching to 0x00008f99 (reg14)

						arg1 = 0x005b8d80

						// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
						arg0 = *(uint32_t*)0x10000254; // = 0x40040000

						// Branch from 0x00008f9c to 0x0000445c (Set LR to 0x00008fa1)
						// void setSpiClkRate(arg0 = sspCtrlRegBase (0x40040000), arg1 = SPI clock rate? (0x005b8d80))
						{
							// Save reg3 to Stack at 0x10001f88 (Value saved is 0x00000007)
							// Save reg4 to Stack at 0x10001f8c (Value saved is 0x10000234)
							// Save reg5 to Stack at 0x10001f90 (Value saved is 0x10000234)
							// Save reg6 to Stack at 0x10001f94 (Value saved is 0x00010074)
							// Save reg7 to Stack at 0x10001f98 (Value saved is 0x00000000)
							// Save reg14 to Stack at 0x10001f9c (Value saved is 0x00008fa1)
							// Stack Pointer updated to 0x10001f88

							// Branch from 0x00004462 to 0x00004130 (Set LR to 0x00004467)
							// int getSysClkFreq()
							{
								// Save reg4 to Stack at 0x10001f80 (Value saved is 0x10000234)
								// Save reg14 to Stack at 0x10001f84 (Value saved is 0x00004467)
								// Stack Pointer updated to 0x10001f80

								// Check if main source clock is IRC Oscillator
								// MemRead system control: MAINCLKSEL (address was computed as 0x40048040 + 0x00000030)
								// 0xc0000000 = 0x00000003 << 30 (Carry Out = 0x00000000)
								// 0x00000003 = 0xc0000000 >> 30 (Carry Out = 0x00000000)
								if ((uint32_t)((uint32_t)*(uint32_t*)0x40048070 << 30) >> 30) Equal, Z == 1
								{
									// UNKOWN PATH execute 0x00004150
								}

								// Check if main source clock is PLL input
								// MemRead system control: MAINCLKSEL (address was computed as 0x40048040 + 0x00000030)
								// 0xc0000000 = 0x00000003 << 30 (Carry Out = 0x00000000)
								// 0x00000003 = 0xc0000000 >> 30 (Carry Out = 0x00000000)
								// Compute 0x00000003 - 0x00000001 for compare
								if (((uint32_t)((uint32_t)*(uint32_t*)0x40048070 << 30) >> 30) - 0x00000001) is Equal, Z == 1
								{
									// UNKOWN PATH execute 0x00004154
								}

								// Check if main source clock is Watchdog oscillator
								// MemRead system control: MAINCLKSEL (address was computed as 0x40048040 + 0x00000030)
								// 0xc0000000 = 0x00000003 << 30 (Carry Out = 0x00000000)
								// 0x00000003 = 0xc0000000 >> 30 (Carry Out = 0x00000000)
								// Compute 0x00000003 - 0x00000002 for compare
								if (((uint32_t)((uint32_t)*(uint32_t*)0x40048070 << 30) >> 30) - 0x00000002) is Equal, Z == 1
								{
									// UNKOWN PATH execute 0x0000415a
								}

								// Check if main source clock is Not PLL output
								// MemRead system control: MAINCLKSEL (address was computed as 0x40048040 + 0x00000030)
								// 0xc0000000 = 0x00000003 << 30 (Carry Out = 0x00000000)
								// 0x00000003 = 0xc0000000 >> 30 (Carry Out = 0x00000000)
								// Compute 0x00000003 - 0x00000003 for compare
								if (((uint32_t)((uint32_t)*(uint32_t*)0x40048070 << 30) >> 30) - 0x00000003) is Not equal, Z == 0
								{
									// UNKOWN PATH execute 0x0000414e
								}


								// Branch from 0x0000414a to 0x000041b0 (Set LR to 0x0000414f)
								// int calcSysClkFreq()	
								{
									// Save reg4 to Stack at 0x10001f78 (Value saved is 0x10000234)
									// Save reg14 to Stack at 0x10001f7c (Value saved is 0x0000414f)
									// Stack Pointer updated to 0x10001f78

									// Branch from 0x000041b2 to 0x00004188 (Set LR to 0x000041b7)

									// Check if System PLL clock source is IRC
									// MemRead system control: SYSPLLCLKSEL (address was computed as 0x40048040 + 0x00000000)
									// 0x40000000 = 0x00000001 << 30 (Carry Out = 0x00000000)
									// 0x00000001 = 0x40000000 >> 30 (Carry Out = 0x00000000)
									if ((uint32_t)((uint32_t)*(uint32_t*)0x40048040 << 30) >> 30) Equal, Z == 1
									{
										// UNKOWN PATH execute 0x0000419a
									}

									// Check if System PLL clock source is not Crystal Oscillator (SYSOSC)
									// MemRead system control: SYSPLLCLKSEL (address was computed as 0x40048040 + 0x00000000)
									// 0x40000000 = 0x00000001 << 30 (Carry Out = 0x00000000)
									// 0x00000001 = 0x40000000 >> 30 (Carry Out = 0x00000000)
									// Compute 0x00000001 - 0x00000001 for compare
									if (((uint32_t)((uint32_t)*(uint32_t*)0x40048040 << 30) >> 30) - 0x00000001) is NOT Equal, Z == 1
									{
										// UNKOWN PATH execute 0x00004196
									}

									// At 0x000041a2 branching to 0x000041b7 (reg14)

									// Branch from 0x000041bc to 0x00004168 (Set LR to 0x000041c1)

									// MemRead system control: SYSPLLCTRL (address was computed as 0x40048000 + 0x00000008)
									// 0x18000000 = 0x00000023 << 27 (Carry Out = 0x00000020)
									// 0x00000003 = 0x18000000 >> 27 (Carry Out = 0x00000000)
									// 0x00000004 = 0x00000003 + 0x00000001
									// 0x02dc6c00 = 0x00000004 * 0x00b71b00;
									sysClkFreq = (((uint32_t)((uint32_t)*(uint32_t*)0x40048008 << 27) >> 27) + 0x00000001) * 0x00b71b00;

									// At 0x00004172 branching to 0x000041c1 (reg14)

								}
								// Restore reg4 from Stack at 0x10001f78 (Value saved was 0x10000234)
								// Restore PC from Stack at 0x10001f7c (Value saved was 0x0000414f)
								// Stack Pointer updated to 0x10001f80

							}
							// Restore reg4 from Stack at 0x10001f80 (Value saved was 0x10000234)
							// Restore PC from Stack at 0x10001f84 (Value saved was 0x00004467)
							// Stack Pointer updated to 0x10001f88

							// Check if we are dealing with SSP0
							// Compute 0x40040000 - 0x40040000 for compare
							if (sspCtrlRegBase - 0x40040000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00004472
							}

							// MemRead system control: SSP0CLKDIV (address was computed as reg1 + 0x00000014)
							reg1 = *(uint32_t*)0x40048094; // = 0x00000001

							// Branching from PC = 0x00004470 to PC = 0x00004474

							// Some big loop for calculating clock register values. Not going to bother to convert to C any more than this...
							for (...) {
								// Branch from 0x00004474 to 0x000020ec (Set LR to 0x00004479)
								// int calcPeriodInClkCycles(arg0 = sysClkFreq, arg1 = SSP0CLKDIV)
								{
									// Save reg4 to Stack at 0x10001f6c (Value saved is 0x40040000)
									// Save reg5 to Stack at 0x10001f70 (Value saved is 0x00000001)
									// Save reg14 to Stack at 0x10001f74 (Value saved is 0x00004479)
									// Stack Pointer updated to 0x10001f6c

									sys_clk_freq = sysClkFreq;

									retval = 0;
								
									for (int cnt = 0x20; cnt > 0; cnt--) {
										if (((uint32_t)sys_clk_freq >> (cnt-1)) - SSP0CLKDIV) is NOT Carry clear, C == 0
										{
											sys_clk_freq -= ((uint32_t)SSP0CLKDIV << (cnt-1));

											retval += ((uint32_t)0x00000001 << (cnt-1));
										}
									}
								}
								// Restore reg4 from Stack at 0x10001f6c (Value saved was 0x40040000)
								// Restore reg5 from Stack at 0x10001f70 (Value saved was 0x00000001)
								// Restore PC from Stack at 0x10001f74 (Value saved was 0x00004479)
								// Stack Pointer updated to 0x10001f78

								...
							}

							// Branch from 0x000044a4 to 0x000044b4 (Set LR to 0x000044a9)
							// void setSspClockRegs(arg0 = sspCtrlRegBase (0x40040000), arg1 = scr (0x00000003), arg2 = clkPrescale (0x00000002))
							{
								// Save reg4 to Stack at 0x10001f80 (Value saved is 0x00000003)
								// Save reg14 to Stack at 0x10001f84 (Value saved is 0x000044a9)
								// Stack Pointer updated to 0x10001f80

								// Set the Serial Clock Rate (SCR)
								// MemRead SSP/SPI0: Ctrl Reg 0 (address was computed as sspCtrlRegBase + 0x00000000)
								// 0x03000000 = 0x00000003 << 24 (Carry Out = 0x00000000)
								// 0x00000300 = 0x03000000 >> 16 (Carry Out = 0x00000000)
								// 0x00000087 = 0x0000ef87 & ~0x0000ff00;
								// 0x00000387 = 0x00000300 | 0x00000087;
								// MemWrite SSP/SPI0: Ctrl Reg 0 (address was computed as sspCtrlRegBase + 0x00000000)
								*(uint32_t*)0x40040000 = ((uint32_t)((uint32_t)scr << 24) >> 16) | (*(uint32_t*)0x40040000 & ~0x0000ff00); // = 0x00000387 (modified bits = 0x0000ec00)

								// Set the Clock Prescale Register
								// MemWrite SSP/SPI0: Clk Prescale Reg (address was computed as sspCtrlRegBase + 0x00000010)
								*(uint32_t*)0x40040010 = clkPrescale; // = 0x00000002 (modified bits = 0x00000000)

							}
							// Restore reg4 from Stack at 0x10001f80 (Value saved was 0x00000003)
							// Restore PC from Stack at 0x10001f84 (Value saved was 0x000044a9)
							// Stack Pointer updated to 0x10001f88

						}
						// Restore reg3 from Stack at 0x10001f88 (Value saved was 0x02dc6c00)
						// Restore reg4 from Stack at 0x10001f8c (Value saved was 0x10000234)
						// Restore reg5 from Stack at 0x10001f90 (Value saved was 0x10000234)
						// Restore reg6 from Stack at 0x10001f94 (Value saved was 0x00010074)
						// Restore reg7 from Stack at 0x10001f98 (Value saved was 0x00000000)
						// Restore PC from Stack at 0x10001f9c (Value saved was 0x00008fa1)
						// Stack Pointer updated to 0x10001fa0

						// Enable the SPI controller
						// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
						// MemRead SSP/SPI0: Ctrl Reg 1 (address was computed as *(uint32_t*)0x10000254 + 0x00000004)
						// 0x00000002 = 0x00000000 | 0x00000002;
						// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
						// MemWrite SSP/SPI0: Ctrl Reg 1 (address was computed as *(uint32_t*)0x10000254 + 0x00000004)
						*(uint32_t*)0x40040004 = *(uint32_t*)0x40040004 | 0x00000002; // = 0x00000002 (modified bits = 0x00000002)

					}
					// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00010074)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000048cb)
					// Stack Pointer updated to 0x10001fa8

					// Branching from PC = 0x000048cc to PC = 0x000048e0

					// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000000)
					// Compute 0x00000000 - 0x00000002 for compare
					if (0x00000000 - *(uint8_t*)0x10000234) is NOT Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x000048e6
					}

					hapticSel = 0x00000000

					// Branch from 0x000048d0 to 0x00007498 (Set LR to 0x000048d5)
					// void HapticSpiCsDrGpioConfig(arg0 = hapticSel (0x00000000))
					{
						// Save reg4 to Stack at 0x10001f98 (Value saved is 0x00000000)
						// Save reg5 to Stack at 0x10001f9c (Value saved is 0x10000234)
						// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000048d5)
						// Stack Pointer updated to 0x10001f98

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
						// 0x00000020 = 0x00000001 << 5 (Carry Out = 0x00000000)
						// 0x50000020 = 0x00000020 + 0x50000000
						// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
						// MemWrite GPIO: P1_15 PBYTE (address was computed as (((uint32_t)(*(uint8_t*)0x1000023a) << 5) + 0x50000000) + *(uint8_t*)0x1000023c)
						*(uint8_t*)0x5000002f = 0x01 (modified bits = 0x01)

						// Set PIO1_15 to output mode
						// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
						// 0x00000004 = 0x00000001 << 2 (Carry Out = 0x00000000)
						// 0x50000004 = 0x00000004 + 0x50000000
						// 0x50002004 = 0x50000004 + 0x00002000
						// MemRead GPIO: DIR1 (address was computed as ((((uint32_t)*(uint8_t*)0x1000023a << 2) + 0x50000000) + 0x00002000) + 0x00000000)
						// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
						// 0x00008000 = 0x00000001 << 0x0000000f (Carry Out = 0x00000000)
						// 0x10008482 = 0x10000482 | 0x00008000;
						// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
						// 0x00000004 = 0x00000001 << 2 (Carry Out = 0x00000000)
						// 0x50000004 = 0x00000004 + 0x50000000
						// 0x50002004 = 0x50000004 + 0x00002000
						// MemWrite GPIO: DIR1 (address was computed as ((((uint32_t)*(uint8_t*)0x1000023a << 2) + 0x50000000) + 0x00002000) + 0x00000000)
						*(uint32_t*)0x50002004 = *(uint32_t*)0x50002004 | ((uint32_t)0x00000001 << *(uint8_t*)0x1000023c); // = 0x10008482 (modified bits = 0x00008000)

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
						gpioBase = *(uint8_t*)0x1000023a; // = 0x00000001

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
						gpioNum = *(uint8_t*)0x1000023c; // = 0x0000000f

						gpioFunc = 0x00000000; // (fields.imm)

						// Branch from 0x000074ce to 0x00005508 (Set LR to 0x000074d3)
						// void setGpioFunc(arg0 = gpioBase (*(uint8_t*)0x1000023a), arg1 = gpioNum (*(uint8_t*)0x1000023c), arg2 = gpioFunc (0))
						{
							// Save reg4 to Stack at 0x10001f90 (Value saved is 0x00000000)
							// Save reg14 to Stack at 0x10001f94 (Value saved is 0x000074d3)
							// Stack Pointer updated to 0x10001f90

							// Compute 0x00000001 - 0x00000000 for compare
							if (gpioBase - 0x00000000) is NOT Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00005510
							}

							// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

							// Compute 0x00000001 - 0x00000000 for compare
							if (gpioBase - 0x00000000) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043b0
							}

							// Set PIO1_15 to function as PIO1_15
							// MemWrite IOCON: PIO1_15 (address was computed as (((uint32_t)gpioNum << 2) + 0x40044000) + 0x00000060)
							*(uint32_t*)0x4004409c = 0x00000080 | gpioFunc; // = 0x00000080 (modified bits = 0x00000010)

							// At 0x000043ae branching to 0x0000553f (reg14)

						}
						// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x00000000)
						// Restore PC from Stack at 0x10001f94 (Value saved was 0x000074d3)
						// Stack Pointer updated to 0x10001f98

						gpioFunc = 0x00000008; 

						// MemRead 8 kB SRAM0 (address was computed as 0x10000240 + hapticSel)
						gpioNum = *(uint8_t*)0x10000240; // = 0x00000017

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023e + hapticSel)
						gpioBase = *(uint8_t*)0x1000023e; // = 0x00000000

						// Branch from 0x000074de to 0x00005508 (Set LR to 0x000074e3)
						// void setGpioFunc(arg0 = gpioBase (*(uint8_t*)0x1000023e), arg1 = gpioNum (*(uint8_t*)0x10000240), arg2 = gpioFunc (8))
						{
							// Save reg4 to Stack at 0x10001f90 (Value saved is 0x00000000)
							// Save reg14 to Stack at 0x10001f94 (Value saved is 0x000074e3)
							// Stack Pointer updated to 0x10001f90

							// Compute 0x00000000 - 0x00000000 for compare
							if (gpioBase - 0x00000000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00005532
							}

							// Compute 0x00000017 - 0x0000000c for compare
							if (gpioNum - 0x0000000c) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00005530
							}

							NOT Signed greater than, Z == 0 && N == V
							{
								// UNKOWN PATH execute 0x00005516
							}

							// Compute 0x00000017 - 0x0000000d for compare
							if (gpioNum - 0x0000000d) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00005530
							}

							// Compute 0x00000017 - 0x0000000e for compare
							if (gpioNum - 0x0000000e) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00005530
							}

							// Compute 0x00000017 - 0x0000000f for compare
							if (gpioNum - 0x0000000f) is NOT Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00005530
							}

							// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

							// Compute 0x00000000 - 0x00000000 for compare
							if (gpioBase - 0x00000000) is NOT Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043aa
							}

							// Enable pull-down resister on PIO0_23
							// MemWrite IOCON: PIO0_23 (address was computed as 0x40044000 + (uint32_t)gpioNum << 2)
							*(uint32_t*)0x4004405c = 0x00000088; // = 0x00000088 (modified bits = 0x00000018)

							// At 0x000043b2 branching to 0x0000553f (reg14)

						}
						// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x00000000)
						// Restore PC from Stack at 0x10001f94 (Value saved was 0x000074e3)
						// Stack Pointer updated to 0x10001f98

					}
					// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x00000000)
					// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x10000234)
					// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000048d5)
					// Stack Pointer updated to 0x10001fa8

					// What value to write to register via SPI
					wrVal = 0x00000002; // (fields.imm)

					// Which register to write to via SPI
					regAddr = 0x00000003; // (fields.imm)

					// Which haptic to write too (0 = right, 1 = left)
					hapticSel = 0x00000000

					// Branch from 0x000048da to 0x00004c7e (Set LR to 0x000048df)
					// void wrHapticReg(arg0 = hapticSel (0 = right, 1 = left) (0x00000000), arg1 = regAddr (0x00000003), arg2 = wrVal (0x00000002))
					{
						// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000000)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000048df)
						// Stack Pointer updated to 0x10001fa0

						// numBytes in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as reg16 + 0x00000010)
						*(uint32_t*)0x10001f90 = 0x00000002 (modified bits = 0x00000002)

						// txBuff (pointer) in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
						*(uint32_t*)0x10001f80 = 0x10001f94 (modified bits = 0x10001f97)

						// rxBuff (pointer) in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as reg16 + 0x00000008)
						*(uint32_t*)0x10001f88 = 0x10001f98 (modified bits = 0x12dc7398)

						// txBuff[0] in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as (SP - 0x00000020) + 0x00000014)
						*(uint8_t*)0x10001f94 = regAddr | 0x00000080; // = 0x83 (modified bits = 0x60)

						// txBuff[1] in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as (SP - 0x00000020) + 0x00000015)
						*(uint8_t*)0x10001f95 = wrVal; // = 0x02 (modified bits = 0x76)

						hapticSel = hapticSel; // = 0x00000000

						// Branch from 0x00004c9c to 0x00009840 (Set LR to 0x00004ca1)
						// void enableHapticCs(arg0 = hapticSel (0x00000000))
						{
							// Save reg4 to Stack at 0x10001f78 (Value saved is 0x00000000)
							// Save reg14 to Stack at 0x10001f7c (Value saved is 0x00004ca1)
							// Stack Pointer updated to 0x10001f78

							// mrs

							// Compute 0x00000000 - 0x00000000 for compare
							if (hapticSel - 0x00000000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00009850
							}

							// Branch from 0x0000984c to 0x00009b4c (Set LR to 0x00009851)

							// Increment lock/mutex
							// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
							// 0x00000001 = 0x00000000 + 0x00000001
							// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
							*(uint8_t*)0x10000340 = *(uint8_t*)0x10000340 + 0x00000001; // = 0x01 (modified bits = 0x01)

							// At 0x00009b56 branching to 0x00009851 (reg14)

							// Make sure SSP0 clock is enabled
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000002)
							// 0x00000800 = 0x00000001 << 0x0000000b (Carry Out = 0x00000000)
							// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							// 0x0c09697f = 0x0c09697f | 0x00000800;
							// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | (uint32_t)0x00000001 << *(uint8_t*)0x10000236; // = 0x0c09697f (modified bits = 0x00000000)

							// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
							// 0x00000020 = 0x00000001 << 5 (Carry Out = 0x00000000)
							// 0x50000020 = 0x00000020 + 0x50000000
							// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
							// MemWrite GPIO: P1_15 PBYTE (address was computed as (((uint32_t)(*(uint8_t*)0x1000023a) << 5) + 0x50000000) + *(uint8_t*)0x1000023c)
							*(uint8_t*)0x5000002f = 0x00 (modified bits = 0x01)

						}
						// Restore reg4 from Stack at 0x10001f78 (Value saved was 0x00000000)
						// Restore PC from Stack at 0x10001f7c (Value saved was 0x00004ca1)
						// Stack Pointer updated to 0x10001f80

						SpiTxRxStruct* txRxStructPtr = (SP - 0x00000020); // = 0x10001f80

						// Branch from 0x00004ca2 to 0x00008efc (Set LR to 0x00004ca7)
						// struct TxRxStruct {
						//	uint32_t* txBuff;
						//	uint32_t* rxBuff;
						//	uint32_t numBytes;
						// };
						// \return Num bytes received
						// int sendSpiData(arg0 = SpiTxRxStruct* txRxStructPtr (SP - 0x00000020 (= 0x10001f80)))
						{
							// Save reg3 to Stack at 0x10001f68 (Value saved is 0x50000000)
							// Save reg4 to Stack at 0x10001f6c (Value saved is 0x00000000)
							// Save reg5 to Stack at 0x10001f70 (Value saved is 0x10000234)
							// Save reg6 to Stack at 0x10001f74 (Value saved is 0x00010074)
							// Save reg7 to Stack at 0x10001f78 (Value saved is 0x00000000)
							// Save reg14 to Stack at 0x10001f7c (Value saved is 0x00004ca7)
							// Stack Pointer updated to 0x10001f68

							// numBytes: MemWrite 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							*(uint32_t*)0x10001f68 = *(uint32_t*)(txRxStructPtr + 0x10); // = 0x00000002 (modified bits = 0x50000002)

							// Branching from PC = 0x00008f0a to PC = 0x00008f40

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000000 - 0x00000002 for compare
							if (0x00000000 - *(uint32_t*)0x10001f68) is NOT Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f46
							}

							// Branch from 0x00008f1a to 0x000043e8 (Set LR to 0x00008f1f)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000002 = 0x00000003 & 0x00000002
							if (*(uint32_t*)0x4004000c & 0x00000002) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f1f (reg14)

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000000 - 0x00000002 for compare
							if (0x00000000 - *(uint32_t*)0x10001f68) is NOT Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f28
							}

							// txBuff: MemRead 8 kB SRAM0 (address was computed as txRxStructPtr + 0x00000000)
							// txBuff[0]: MemRead 8 kB SRAM0 (address was computed as *(uint32_t*)0x10001f80 + 0x00000000)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemWrite SSP/SPI0: Data Reg (address was computed as *(uint32_t*)0x10000254 + 0x00000008)
							*(uint32_t*)0x40040008 = *(uint8_t*)0x10001f94; // = 0x00000083 (modified bits = 0x00000083)

							// Branch from 0x00008f1a to 0x000043e8 (Set LR to 0x00008f1f)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000002 = 0x00000003 & 0x00000002
							if (*(uint32_t*)0x4004000c & 0x00000002) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f1f (reg14)

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000001 - 0x00000002 for compare
							if (0x00000001 - *(uint32_t*)0x10001f68) is NOT Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f28
							}

							// txBuff: MemRead 8 kB SRAM0 (address was computed as txRxStructPtr + 0x00000000)
							// txBuff[1]: MemRead 8 kB SRAM0 (address was computed as *(uint32_t*)0x10001f80 + 0x00000001)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemWrite SSP/SPI0: Data Reg (address was computed as *(uint32_t*)0x10000254 + 0x00000008)
							*(uint32_t*)0x40040008 = *(uint8_t*)0x10001f95; // = 0x00000002 (modified bits = 0x00000081)

							// Branch from 0x00008f1a to 0x000043e8 (Set LR to 0x00008f1f)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000002 = 0x00000003 & 0x00000002
							if (*(uint32_t*)0x4004000c & 0x00000002) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f1f (reg14)

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000002 - 0x00000002 for compare
							if (0x00000002 - *(uint32_t*)0x10001f68) is Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f0c
							}

							// Branching from PC = 0x00008f28 to PC = 0x00008f34

							// Branch from 0x00008f38 to 0x000043e8 (Set LR to 0x00008f3d)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000004 = 0x00000007 & 0x00000004
							if (*(uint32_t*)0x4004000c & 0x00000004) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f3d (reg14)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Data Reg (address was computed as *(uint32_t*)0x10000254 + 0x00000008)
							// rxBuff: MemRead 8 kB SRAM0 (address was computed as txRxStructPtr + 0x00000008)
							// rxBuff[0]: MemWrite 8 kB SRAM0 (address was computed as *(uint32_t*)0x10001f88 + 0x00000000)
							*(uint8_t*)0x10001f98 = *(uint32_t*)0x40040008; // = 0xfb (modified bits = 0xfb)

							// Branch from 0x00008f38 to 0x000043e8 (Set LR to 0x00008f3d)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000004 = 0x00000007 & 0x00000004
							if (*(uint32_t*)0x4004000c & 0x00000004) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f3d (reg14)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Data Reg (address was computed as *(uint32_t*)0x10000254 + 0x00000008)
							// rxBuff: MemRead 8 kB SRAM0 (address was computed as txRxStructPtr + 0x00000008)
							// rxBuff[1]: MemWrite 8 kB SRAM0 (address was computed as *(uint32_t*)0x10001f88 + 0x00000001)
							*(uint8_t*)0x10001f99 = *(uint32_t*)0x40040008; // = 0xfb (modified bits = 0xfb)

							// Branch from 0x00008f38 to 0x000043e8 (Set LR to 0x00008f3d)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000000 = 0x00000003 & 0x00000004
							if (*(uint32_t*)0x4004000c & 0x00000004) NOT Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043ee
							}

							// At 0x000043f0 branching to 0x00008f3d (reg14)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000000 = 0x00000003 & 0x00000004
							// Compute 0x00000000 - 0x00000001 for compare
							if (*(uint32_t*)0x4004000c & 0x00000004 - 0x00000001) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00008f2a
							}

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000002 - 0x00000002 for compare
							if (0x00000002 - *(uint32_t*)0x10001f68) is Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f16
							}

							reg0 = 0x00000002; // = 0x00000002

						}
						// Restore reg3 from Stack at 0x10001f68 (Value saved was 0x00000002)
						// Restore reg4 from Stack at 0x10001f6c (Value saved was 0x00000000)
						// Restore reg5 from Stack at 0x10001f70 (Value saved was 0x10000234)
						// Restore reg6 from Stack at 0x10001f74 (Value saved was 0x00010074)
						// Restore reg7 from Stack at 0x10001f78 (Value saved was 0x00000000)
						// Restore PC from Stack at 0x10001f7c (Value saved was 0x00004ca7)
						// Stack Pointer updated to 0x10001f80

						hapticSel = hapticSel; // = 0x00000000

						// Branch from 0x00004ca8 to 0x0000991c (Set LR to 0x00004cad)
						// void disableHapticCs(arg0 = hapticSel (0x00000000))
						{
							// Save reg4 to Stack at 0x10001f78 (Value saved is 0x00000000)
							// Save reg14 to Stack at 0x10001f7c (Value saved is 0x00004cad)
							// Stack Pointer updated to 0x10001f78

							// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + 0x00000001)
							// 0x00000020 = 0x00000001 << 5 (Carry Out = 0x00000000)
							// 0x50000020 = 0x00000020 + 0x50000000
							// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
							// MemWrite GPIO: P1_15 PBYTE (address was computed as (((uint32_t)*(uint8_t*)0x1000023a << 5) + 0x50000000) + *(uint8_t*)0x1000023c)
							*(uint8_t*)0x5000002f = 0x01 (modified bits = 0x01)

							// Disable clock for SSP/SPI0
							// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000002)
							// 0x00000800 = 0x00000001 << 0x0000000b (Carry Out = 0x00000000)
							// 0x0c09617f = 0x0c09697f & ~0x00000800;
							// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 & ~((uint32_t)0x00000001 << *(uint8_t*)0x10000236); // = 0x0c09617f (modified bits = 0x00000800)

							// mrs

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000002)
							// Compute 0x00000000 - 0x00000000 for compare
							if (*(uint8_t*)0x10000236 - 0x00000000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00009952
							}

							// Branch from 0x0000994e to 0x00009b70 (Set LR to 0x00009953)

							// Decrement mutex/lock
							// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
							// 0x00000000 = 0x00000001 - 0x00000001
							// 0x00000000 = 0x00000000 << 24 (Carry Out = 0x00000000)
							// 0x00000000 = 0x00000000 >> 24 (Carry Out = 0x00000000)
							// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
							*(uint8_t*)0x10000340 = ((uint32_t)((uint32_t)(*(uint8_t*)0x10000340 - 0x00000001) << 24) >> 24); // = 0x00 (modified bits = 0x01)

							Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00009b80
							}

							// At 0x00009b80 branching to 0x00009953 (reg14)

						}
						// Restore reg4 from Stack at 0x10001f78 (Value saved was 0x00000000)
						// Restore PC from Stack at 0x10001f7c (Value saved was 0x00004cad)
						// Stack Pointer updated to 0x10001f80

						// Restore SP
						reg13 = 0x10001fa0; // = SP + 0x00000020

					}
					// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000000)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000048df)
					// Stack Pointer updated to 0x10001fa8

					// MemRead 8 kB SRAM0 (address was computed as reg5 + 0x00000000)
					// Compute 0x00000001 - 0x00000002 for compare
					if (0x00000001 - *(uint8_t*)0x10000234) is NOT Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x000048e6
					}

					hapticSel = 0x00000001

					// Branch from 0x000048d0 to 0x00007498 (Set LR to 0x000048d5)
					// void HapticSpiCsDrGpioConfig(arg0 = hapticSel (0x00000001))
					{
						// Save reg4 to Stack at 0x10001f98 (Value saved is 0x00000001)
						// Save reg5 to Stack at 0x10001f9c (Value saved is 0x10000234)
						// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000048d5)
						// Stack Pointer updated to 0x10001f98

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
						// 0x00000020 = 0x00000001 << 5 (Carry Out = 0x00000000)
						// 0x50000020 = 0x00000020 + 0x50000000
						// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
						// MemWrite GPIO: P1_6 PBYTE (address was computed as (((uint32_t)(*(uint8_t*)0x1000023b) << 5) + 0x50000000) + *(uint8_t*)0x1000023d)
						*(uint8_t*)0x50000026 = 0x01 (modified bits = 0x01)

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
						// 0x00000040 = 0x00000001 << 0x00000006 (Carry Out = 0x00000000)
						// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
						// 0x00000004 = 0x00000001 << 2 (Carry Out = 0x00000000)
						// 0x50000004 = 0x00000004 + 0x50000000
						// 0x50002004 = 0x50000004 + 0x00002000
						// MemRead GPIO: DIR1 (address was computed as ((((uint32_t)(*(uint8_t*)0x1000023b) << 2) + 0x50000000) + 0x00002000) + 0x00000000)
						// 0x100084c2 = 0x10008482 | 0x00000040;
						// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
						// 0x00000004 = 0x00000001 << 2 (Carry Out = 0x00000000)
						// 0x50000004 = 0x00000004 + 0x50000000
						// 0x50002004 = 0x50000004 + 0x00002000
						// MemWrite GPIO: DIR1 (address was computed as ((((uint32_t)(*(uint8_t*)0x1000023b) << 2) + 0x50000000) + 0x00002000) + 0x00000000) + 0x00000000)
						*(uint32_t*)0x50002004 = *(uint32_t*)0x50002004 | ((uint32_t)0x00000001 << *(uint8_t*)0x1000023d); // = 0x100084c2 (modified bits = 0x00000040)

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
						gpioBase = *(uint8_t*)0x1000023b; // = 0x00000001

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
						gpioNum = *(uint8_t*)0x1000023d; // = 0x00000006

						gpioFunc = 0x00000000; // (fields.imm)

						// Branch from 0x000074ce to 0x00005508 (Set LR to 0x000074d3)
						// void setGpioFunc(arg0 = gpioBase (*(uint8_t*)0x1000023b), arg1 = gpioNum (*(uint8_t*)0x1000023d), arg2 = gpioFunc (0))
						{
							// Save reg4 to Stack at 0x10001f90 (Value saved is 0x00000001)
							// Save reg14 to Stack at 0x10001f94 (Value saved is 0x000074d3)
							// Stack Pointer updated to 0x10001f90

							// Compute 0x00000001 - 0x00000000 for compare
							if (gpioBase - 0x00000000) is NOT Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00005510
							}

							// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

							// Compute 0x00000001 - 0x00000000 for compare
							if (gpioBase - 0x00000000) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043b0
							}

							// MemWrite IOCON: PIO1_6 (address was computed as (((uint32_t)gpioNum << 2) + 0x40044000) + 0x00000060)
							*(uint32_t*)0x40044078 = 0x00000080 | gpioFunc; // = 0x00000080 (modified bits = 0x00000010)

							// At 0x000043ae branching to 0x0000553f (reg14)

						}
						// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x00000001)
						// Restore PC from Stack at 0x10001f94 (Value saved was 0x000074d3)
						// Stack Pointer updated to 0x10001f98

						gpioFunc = 0x00000008; // (fields.imm)

						// MemRead 8 kB SRAM0 (address was computed as 0x10000240 + hapticSel)
						gpioNum = *(uint8_t*)0x10000241; // = 0x00000010

						// MemRead 8 kB SRAM0 (address was computed as 0x1000023e + hapticSel)
						gpioBase = *(uint8_t*)0x1000023f; // = 0x00000001

						// Branch from 0x000074de to 0x00005508 (Set LR to 0x000074e3)
						// void setGpioFunc(arg0 = gpioBase (*(uint8_t*)0x1000023f), arg1 = gpioNum (*(uint8_t*)0x10000241), arg2 = gpioFunc (8))
						{
							// Save reg4 to Stack at 0x10001f90 (Value saved is 0x00000001)
							// Save reg14 to Stack at 0x10001f94 (Value saved is 0x000074e3)
							// Stack Pointer updated to 0x10001f90

							// Compute 0x00000001 - 0x00000000 for compare
							if (gpioBase - 0x00000000) is NOT Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00005510
							}

							// Branch from 0x0000553a to 0x000043a4 (Set LR to 0x0000553f)

							// Compute 0x00000001 - 0x00000000 for compare
							if (gpioBase - 0x00000000) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043b0
							}

							// MemWrite IOCON: PIO1_16 (address was computed as (((uint32_t)gpioNum << 2) + 0x40044000) + 0x00000060)
							*(uint32_t*)0x400440a0 = 0x00000080 | gpioFunc; // = 0x00000088 (modified bits = 0x00000018)

							// At 0x000043ae branching to 0x0000553f (reg14)

						}
						// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x00000001)
						// Restore PC from Stack at 0x10001f94 (Value saved was 0x000074e3)
						// Stack Pointer updated to 0x10001f98

					}
					// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x00000001)
					// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x10000234)
					// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000048d5)
					// Stack Pointer updated to 0x10001fa8

					wrVal = 0x00000002; // (fields.imm)

					regAddr = 0x00000003; // (fields.imm)

					hapticSel = 0x00000001

					// Branch from 0x000048da to 0x00004c7e (Set LR to 0x000048df)
					// void wrHapticReg(arg0 = hapticSel (0 = right, 1 = left) (0x00000000), arg1 = regAddr (0x00000003), arg2 = wrVal (0x00000002))
					{
						// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000001)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000048df)
						// Stack Pointer updated to 0x10001fa0

						// numBytes in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as reg16 + 0x00000010)
						*(uint32_t*)0x10001f90 = 0x00000002 (modified bits = 0x00000002)

						// txBuff (pointer) in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
						*(uint32_t*)0x10001f80 = 0x10001f94 (modified bits = 0x10001f97)

						// rxBuff (pointer) in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as reg16 + 0x00000008)
						*(uint32_t*)0x10001f88 = 0x10001f98 (modified bits = 0x12dc7398)

						// txBuff[0] in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as (SP - 0x00000020) + 0x00000014)
						*(uint8_t*)0x10001f94 = regAddr | 0x00000080; // = 0x83 (modified bits = 0x60)

						// txBuff[1] in SpiTxRxStruct
						// MemWrite 8 kB SRAM0 (address was computed as (SP - 0x00000020) + 0x00000015)
						*(uint8_t*)0x10001f95 = wrVal; // = 0x02 (modified bits = 0x76)

						hapticSel = hapticSel; // = 0x00000000

						// Branch from 0x00004c9c to 0x00009840 (Set LR to 0x00004ca1)
						// void enableHapticCs(arg0 = hapticSel (0x00000001))
						{
							// Save reg4 to Stack at 0x10001f78 (Value saved is 0x00000001)
							// Save reg14 to Stack at 0x10001f7c (Value saved is 0x00004ca1)
							// Stack Pointer updated to 0x10001f78

							// mrs

							// Compute 0x00000000 - 0x00000000 for compare
							if (hapticSel - 0x00000000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00009850
							}

							// Branch from 0x0000984c to 0x00009b4c (Set LR to 0x00009851)

							// Increment lock/mutex
							// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
							// 0x00000001 = 0x00000000 + 0x00000001
							// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
							*(uint8_t*)0x10000340 = *(uint8_t*)0x10000340 + 0x00000001; // = 0x01 (modified bits = 0x01)

							// At 0x00009b56 branching to 0x00009851 (reg14)

							// Make sure SSP0 clock is enabled
							// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000002)
							// 0x00000800 = 0x00000001 << 0x0000000b (Carry Out = 0x00000000)
							// 0x0c09697f = 0x0c09617f | 0x00000800;
							// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | ((uint32_t)0x00000001 << *(uint8_t*)0x10000236); // = 0x0c09697f (modified bits = 0x00000800)

							// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
							// 0x00000020 = 0x00000001 << 5 (Carry Out = 0x00000000)
							// 0x50000020 = 0x00000020 + 0x50000000
							// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
							// MemWrite GPIO: P1_6 PBYTE (address was computed as (((uint32_t)(*(uint8_t*)0x1000023b) << 5) + 0x50000000) + *(uint8_t*)0x1000023d)
							*(uint8_t*)0x50000026 = 0x00 (modified bits = 0x01)

						}
						// Restore reg4 from Stack at 0x10001f78 (Value saved was 0x00000001)
						// Restore PC from Stack at 0x10001f7c (Value saved was 0x00004ca1)
						// Stack Pointer updated to 0x10001f80

						SpiTxRxStruct* txRxStructPtr = (SP - 0x00000020); // = 0x10001f80

						// Branch from 0x00004ca2 to 0x00008efc (Set LR to 0x00004ca7)
						// struct TxRxStruct {
						//	uint32_t* txBuff;
						//	uint32_t* rxBuff;
						//	uint32_t numBytes;
						// };
						// \return Num bytes received
						// int sendSpiData(arg0 = SpiTxRxStruct* txRxStructPtr (SP - 0x00000020 (= 0x10001f80)))
						{
							// Save reg3 to Stack at 0x10001f68 (Value saved is 0x50000000)
							// Save reg4 to Stack at 0x10001f6c (Value saved is 0x00000001)
							// Save reg5 to Stack at 0x10001f70 (Value saved is 0x10000234)
							// Save reg6 to Stack at 0x10001f74 (Value saved is 0x00010074)
							// Save reg7 to Stack at 0x10001f78 (Value saved is 0x00000000)
							// Save reg14 to Stack at 0x10001f7c (Value saved is 0x00004ca7)
							// Stack Pointer updated to 0x10001f68

							// numBytes: MemWrite 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							*(uint32_t*)0x10001f68 = *(uint32_t*)(txRxStructPtr + 0x10); // = 0x00000002 (modified bits = 0x50000002)

							// Branching from PC = 0x00008f0a to PC = 0x00008f40

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000000 - 0x00000002 for compare
							if (0x00000000 - *(uint32_t*)0x10001f68) is NOT Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f46
							}

							// Branch from 0x00008f1a to 0x000043e8 (Set LR to 0x00008f1f)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000002 = 0x00000003 & 0x00000002
							if (*(uint32_t*)0x4004000c & 0x00000002) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f1f (reg14)

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000000 - 0x00000002 for compare
							if (0x00000000 - *(uint32_t*)0x10001f68) is NOT Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f28
							}

							// txBuff: MemRead 8 kB SRAM0 (address was computed as txRxStructPtr + 0x00000000)
							// txBuff[0]: MemRead 8 kB SRAM0 (address was computed as *(uint32_t*)0x10001f80 + 0x00000000)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemWrite SSP/SPI0: Data Reg (address was computed as *(uint32_t*)0x10000254 + 0x00000008)
							*(uint32_t*)0x40040008 = *(uint8_t*)0x10001f94; // = 0x00000083 (modified bits = 0x00000083)

							// Branch from 0x00008f1a to 0x000043e8 (Set LR to 0x00008f1f)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000002 = 0x00000003 & 0x00000002
							if (*(uint32_t*)0x4004000c & 0x00000002) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f1f (reg14)

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000001 - 0x00000002 for compare
							if (0x00000001 - *(uint32_t*)0x10001f68) is NOT Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f28
							}

							// txBuff: MemRead 8 kB SRAM0 (address was computed as txRxStructPtr + 0x00000000)
							// txBuff[1]: MemRead 8 kB SRAM0 (address was computed as *(uint32_t*)0x10001f80 + 0x00000001)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemWrite SSP/SPI0: Data Reg (address was computed as *(uint32_t*)0x10000254 + 0x00000008)
							*(uint32_t*)0x40040008 = *(uint8_t*)0x10001f95; // = 0x00000002 (modified bits = 0x00000081)

							// Branch from 0x00008f1a to 0x000043e8 (Set LR to 0x00008f1f)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000002 = 0x00000003 & 0x00000002
							if (*(uint32_t*)0x4004000c & 0x00000002) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f1f (reg14)

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000002 - 0x00000002 for compare
							if (0x00000002 - *(uint32_t*)0x10001f68) is Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f0c
							}

							// Branching from PC = 0x00008f28 to PC = 0x00008f34

							// Branch from 0x00008f38 to 0x000043e8 (Set LR to 0x00008f3d)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000004 = 0x00000007 & 0x00000004
							if (*(uint32_t*)0x4004000c & 0x00000004) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f3d (reg14)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Data Reg (address was computed as *(uint32_t*)0x10000254 + 0x00000008)
							// rxBuff: MemRead 8 kB SRAM0 (address was computed as txRxStructPtr + 0x00000008)
							// rxBuff[0]: MemWrite 8 kB SRAM0 (address was computed as *(uint32_t*)0x10001f88 + 0x00000000)
							*(uint8_t*)0x10001f98 = *(uint32_t*)0x40040008; // = 0xfb (modified bits = 0xfb)

							// Branch from 0x00008f38 to 0x000043e8 (Set LR to 0x00008f3d)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000004 = 0x00000007 & 0x00000004
							if (*(uint32_t*)0x4004000c & 0x00000004) Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043f0
							}

							// At 0x000043f0 branching to 0x00008f3d (reg14)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Data Reg (address was computed as *(uint32_t*)0x10000254 + 0x00000008)
							// rxBuff: MemRead 8 kB SRAM0 (address was computed as txRxStructPtr + 0x00000008)
							// rxBuff[1]: MemWrite 8 kB SRAM0 (address was computed as *(uint32_t*)0x10001f88 + 0x00000001)
							*(uint8_t*)0x10001f99 = *(uint32_t*)0x40040008; // = 0xfb (modified bits = 0xfb)

							// Branch from 0x00008f38 to 0x000043e8 (Set LR to 0x00008f3d)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000000 = 0x00000003 & 0x00000004
							if (*(uint32_t*)0x4004000c & 0x00000004) NOT Equal, Z == 1
							{
								// UNKOWN PATH execute 0x000043ee
							}

							// At 0x000043f0 branching to 0x00008f3d (reg14)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000020)
							// MemRead SSP/SPI0: Status Reg (address was computed as *(uint32_t*)0x10000254 + 0x0000000c)
							// 0x00000000 = 0x00000003 & 0x00000004
							// Compute 0x00000000 - 0x00000001 for compare
							if (*(uint32_t*)0x4004000c & 0x00000004 - 0x00000001) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x00008f2a
							}

							// numBytes: MemRead 8 kB SRAM0 (address was computed as reg16 + 0x00000000)
							// Compute 0x00000002 - 0x00000002 for compare
							if (0x00000002 - *(uint32_t*)0x10001f68) is Carry clear, C == 0
							{
								// UNKOWN PATH execute 0x00008f16
							}

							reg0 = 0x00000002; // = 0x00000002

						}
						// Restore reg3 from Stack at 0x10001f68 (Value saved was 0x00000002)
						// Restore reg4 from Stack at 0x10001f6c (Value saved was 0x00000001)
						// Restore reg5 from Stack at 0x10001f70 (Value saved was 0x10000234)
						// Restore reg6 from Stack at 0x10001f74 (Value saved was 0x00010074)
						// Restore reg7 from Stack at 0x10001f78 (Value saved was 0x00000000)
						// Restore PC from Stack at 0x10001f7c (Value saved was 0x00004ca7)
						// Stack Pointer updated to 0x10001f80

						hapticSel = hapticSel; // = 0x00000000

						// Branch from 0x00004ca8 to 0x0000991c (Set LR to 0x00004cad)
						// void disableHapticCs(arg0 = hapticSel (0x00000001))
						{
							// Save reg4 to Stack at 0x10001f78 (Value saved is 0x00000001)
							// Save reg14 to Stack at 0x10001f7c (Value saved is 0x00004cad)
							// Stack Pointer updated to 0x10001f78

							// MemRead 8 kB SRAM0 (address was computed as 0x1000023a + hapticSel)
							// 0x00000020 = 0x00000001 << 5 (Carry Out = 0x00000000)
							// 0x50000020 = 0x00000020 + 0x50000000
							// MemRead 8 kB SRAM0 (address was computed as 0x1000023c + hapticSel)
							// MemWrite GPIO: P1_6 PBYTE (address was computed as (((uint32_t)(*(uint8_t*)0x1000023b) << 5) + 0x50000000) + (*(uint8_t*)0x1000023d))
							*(uint8_t*)0x50000026 = 0x01 (modified bits = 0x01)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000002)
							// 0x00000800 = 0x00000001 << 0x0000000b (Carry Out = 0x00000000)
							// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							// 0x0c09617f = 0x0c09697f & ~0x00000800;
							// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 & ~((uint32_t)0x00000001 << *(uint8_t*)0x10000236); // = 0x0c09617f (modified bits = 0x00000800)

							// mrs

							// MemRead 8 kB SRAM0 (address was computed as 0x10000234 + 0x00000002)
							// Compute 0x00000000 - 0x00000000 for compare
							if (*(uint8_t*)0x10000236 - 0x00000000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00009952
							}

							// Branch from 0x0000994e to 0x00009b70 (Set LR to 0x00009953)

							// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
							// 0x00000000 = 0x00000001 - 0x00000001
							// 0x00000000 = 0x00000000 << 24 (Carry Out = 0x00000000)
							// 0x00000000 = 0x00000000 >> 24 (Carry Out = 0x00000000)
							// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
							*(uint8_t*)0x10000340 = ((uint32_t)((uint32_t)(*(uint8_t*)0x10000340 - 0x00000001) << 24) >> 24); // = 0x00 (modified bits = 0x01)

							Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00009b80
							}

							// At 0x00009b80 branching to 0x00009953 (reg14)

						}
						// Restore reg4 from Stack at 0x10001f78 (Value saved was 0x00000001)
						// Restore PC from Stack at 0x10001f7c (Value saved was 0x00004cad)
						// Stack Pointer updated to 0x10001f80

						reg13 = 0x10001fa0; // = SP + 0x00000020

					}
					// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000001)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000048df)
					// Stack Pointer updated to 0x10001fa8

					// MemRead 8 kB SRAM0 (address was computed as reg5 + 0x00000000)
					// Compute 0x00000002 - 0x00000002 for compare
					if (0x00000002 - *(uint8_t*)0x10000234) is Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x000048ce
					}

				}
				// Restore reg4 from Stack at 0x10001fa8 (Value saved was 0x00010074)
				// Restore reg5 from Stack at 0x10001fac (Value saved was 0x00000001)
				// Restore reg6 from Stack at 0x10001fb0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fb4 (Value saved was 0x0000a3af)
				// Stack Pointer updated to 0x10001fb8

			}
			// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005ded)
			// Stack Pointer updated to 0x10001fc0

			reg0 = 0x00000001; // (fields.imm)

			// Branch from 0x00005dee to 0x00005fbc (Set LR to 0x00005df3)
			// Setup I2C communications to MPU-6500 and put device in sleep mode
			// void i2CSetupSleep(arg0 ?? = 0x00000001)
			{
				// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005df3)
				// Stack Pointer updated to 0x10001fb8

				// Branch from 0x00005fc0 to 0x000056f0 (Set LR to 0x00005fc5)

				// At 0x000056f4 branching to 0x00005fc5 (reg14)

				// Cherk Hardware/Board Revision
				// MemRead 8 kB SRAM0 (address was computed as 0x10000090 + 0x00000004)
				// Compute 0x0000000a - 0x0000000a for compare
				if (*(uint8_t*)0x10000094 - 0x0000000a) is Carry clear, C == 0
				{
					// UNKOWN PATH execute 0x00005fcc
				}

				// Branching from PC = 0x00005fca to PC = 0x00005fce

				// Compute 0x00000001 - 0x00000000 for compare
				if (reg0 - 0x00000000) is Equal, Z == 1
				{
					// UNKOWN PATH execute 0x00005fd8
				}

				i2cSlaveAddr = 0x00000069; // (fields.imm)

				// Branch from 0x00005fd2 to 0x00006a10 (Set LR to 0x00005fd7)
				// ?? fnc(i2cSlaveAddr = 0x69)
				{
					// Save reg4 to Stack at 0x10001fb0 (Value saved is 0x00010074)
					// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x00005fd7)
					// Stack Pointer updated to 0x10001fb0

					// Branch from 0x00006a12 to 0x00005c8c (Set LR to 0x00006a17)
					// void setupI2C(i2cSlaveAddr = 0x69)
					{
						// Save reg4 to Stack at 0x10001fa8 (Value saved is 0x00010074)
						// Save reg14 to Stack at 0x10001fac (Value saved is 0x00006a17)
						// Stack Pointer updated to 0x10001fa8

						// Branch from 0x00005c94 to 0x000021be (Set LR to 0x00005c99)

						// Branching from PC = 0x000021c0 to PC = 0x000021b0

						// Branching from PC = 0x000021b2 to PC = 0x000021b8

						// Clear out struct I2C_XFER_T:
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d80 + 0x00000000)
						*(uint8_t*)0x10000d80 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d81 + 0x00000000)
						*(uint8_t*)0x10000d81 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d82 + 0x00000000)
						*(uint8_t*)0x10000d82 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d83 + 0x00000000)
						*(uint8_t*)0x10000d83 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d84 + 0x00000000)
						*(uint8_t*)0x10000d84 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d85 + 0x00000000)
						*(uint8_t*)0x10000d85 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d86 + 0x00000000)
						*(uint8_t*)0x10000d86 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d87 + 0x00000000)
						*(uint8_t*)0x10000d87 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d88 + 0x00000000)
						*(uint8_t*)0x10000d88 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d89 + 0x00000000)
						*(uint8_t*)0x10000d89 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d8a + 0x00000000)
						*(uint8_t*)0x10000d8a = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d8b + 0x00000000)
						*(uint8_t*)0x10000d8b = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d8c + 0x00000000)
						*(uint8_t*)0x10000d8c = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d8d + 0x00000000)
						*(uint8_t*)0x10000d8d = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d8e + 0x00000000)
						*(uint8_t*)0x10000d8e = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d8f + 0x00000000)
						*(uint8_t*)0x10000d8f = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d90 + 0x00000000)
						*(uint8_t*)0x10000d90 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d91 + 0x00000000)
						*(uint8_t*)0x10000d91 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d92 + 0x00000000)
						*(uint8_t*)0x10000d92 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d93 + 0x00000000)
						*(uint8_t*)0x10000d93 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d94 + 0x00000000)
						*(uint8_t*)0x10000d94 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d95 + 0x00000000)
						*(uint8_t*)0x10000d95 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d96 + 0x00000000)
						*(uint8_t*)0x10000d96 = 0x00 (modified bits = 0x00)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d97 + 0x00000000)
						*(uint8_t*)0x10000d97 = 0x00 (modified bits = 0x00)

						// At 0x000021bc branching to 0x00005c99 (reg14)

						// Set I2C slave address in I2C_XFER_T for communicating with MPU-6500 Motion Tracking Device
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d80 + 0x00000000)
						*(uint8_t*)0x10000d80 = i2cSlaveAddr; // = 0x69 (modified bits = 0x69)

						// De-assert reset for I2C
						// MemRead system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
						// 0x00000003 = 0x00000001 | 0x00000002;
						// MemWrite system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
						*(uint32_t*)0x40048004 = *(uint32_t*)0x40048004 | 0x00000002; // = 0x00000003 (modified bits = 0x00000002)

						// Enable clock for I2C
						// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						// 0x0c09617f = 0x0c09617f | 0x00000020;
						// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | 0x00000020; // = 0x0c09617f (modified bits = 0x00000000)

						// Reset the I2C peripheral
						// MemRead system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
						// 0x00000001 = 0x00000003 & ~0x00000002;
						// MemWrite system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
						*(uint32_t*)0x40048004 = *(uint32_t*)0x40048004 & ~0x00000002; // = 0x00000001 (modified bits = 0x00000002)

						// De-assert reset for I2C
						// MemRead system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
						// 0x00000003 = 0x00000001 | 0x00000002;
						// MemWrite system control: PRESETCTRL (address was computed as 0x40048000 + 0x00000004)
						*(uint32_t*)0x40048004 = *(uint32_t*)0x40048004 | 0x00000002; // = 0x00000003 (modified bits = 0x00000002)

						// Branch from 0x00005cc8 to 0x000043a4 (Set LR to 0x00005ccd)

						// Set PIO0_4 Function to I2C SCL (open-drain pin)
						// MemWrite IOCON: PIO0_4 (address was computed as 0x40044000 + 0x00000010)
						*(uint32_t*)0x40044010 = 0x00000001 (modified bits = 0x00000081)

						// At 0x000043b2 branching to 0x00005ccd (reg14)

						// Branch from 0x00005cd4 to 0x000043a4 (Set LR to 0x00005cd9)

						// Set PIO0_5 Function to I2C SDA (open-drain pin)
						// MemWrite IOCON: PIO0_5 (address was computed as 0x40044000 + 0x00000014)
						*(uint32_t*)0x40044014 = 0x00000001 (modified bits = 0x00000081)

						// At 0x000043b2 branching to 0x00005cd9 (reg14)

						reg0 = 0x00000000; // (fields.imm)

						// Branch from 0x00005cda to 0x00004268 (Set LR to 0x00005cdf)

						{
							// Save reg4 to Stack at 0x10001f9c (Value saved is 0x40044000)
							// Save reg5 to Stack at 0x10001fa0 (Value saved is 0x00000001)
							// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00005cdf)
							// Stack Pointer updated to 0x10001f9c

							// Make sure I2C clock is enabled
							// MemRead 8 kB SRAM0 (address was computed as ((0x0000001c * reg0) + 0x100000a8) + 0x00000004)
							// 0x00000020 = 0x00000001 << 0x00000005 (Carry Out = 0x00000000)
							// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							// 0x0c09617f = 0x0c09617f | 0x00000020;
							// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
							*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | ((uint32_t)0x00000001 << *(uint8_t*)0x100000ac); // = 0x0c09617f (modified bits = 0x00000000)

							// Clear I2C interrupt bit and start flag. And disable I2C interface
							// MemRead 8 kB SRAM0 (address was computed as 0x100000a8 + (0x0000001c * reg0))
							// MemWrite I2C: CONCLR (address was computed as *(uint32_t*)0x100000a8 + 0x00000018)
							*(uint32_t*)0x40000018 = 0x0000006c (modified bits = 0x0000006c)

						}
						// Restore reg4 from Stack at 0x10001f9c (Value saved was 0x40044000)
						// Restore reg5 from Stack at 0x10001fa0 (Value saved was 0x00000001)
						// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00005cdf)
						// Stack Pointer updated to 0x10001fa8

						baudRate = 0x00061a80; //400000

						reg0 = 0x00000000; // (fields.imm)

						// Branch from 0x00005ce2 to 0x00004354 (Set LR to 0x00005ce7)
						// void setI2CDataRate(arg0 = deviceSel?? (0), arg1 = baudRate (400000))
						{
							// Save reg4 to Stack at 0x10001f98 (Value saved is 0x40044000)
							// Save reg5 to Stack at 0x10001f9c (Value saved is 0x00000001)
							// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
							// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x00005ce7)
							// Stack Pointer updated to 0x10001f98

							reg4 = reg0; // = 0x00000000

							// Branch from 0x0000435a to 0x00004130 (Set LR to 0x0000435f)
							// int getSysClkFreq()
							{
								// Save reg4 to Stack at 0x10001f90 (Value saved is 0x00000000)
								// Save reg14 to Stack at 0x10001f94 (Value saved is 0x0000435f)
								// Stack Pointer updated to 0x10001f90

								// Trimmed. See previous jump to 0x00004130 for details.

								sys_clk_freq = 0x02dc6c00; // 48000000
							}
							// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x00000000)
							// Restore PC from Stack at 0x10001f94 (Value saved was 0x0000435f)
							// Stack Pointer updated to 0x10001f98

							reg1 = baudRate; // = 0x00061a80

							// Branch from 0x00004360 to 0x000020ec (Set LR to 0x00004365)
							// int calcPeriodInClkCycles(arg0 = sysClkFreq, arg1 = desiredRate (400000))
							{
								// Save reg4 to Stack at 0x10001f8c (Value saved is 0x00000000)
								// Save reg5 to Stack at 0x10001f90 (Value saved is 0x00061a80)
								// Save reg14 to Stack at 0x10001f94 (Value saved is 0x00004365)
								// Stack Pointer updated to 0x10001f8c
								
								// Trimmed. See previous converion of jump to 0x000020ec for details.
							}
							// Restore reg4 from Stack at 0x10001f8c (Value saved was 0x00000000)
							// Restore reg5 from Stack at 0x10001f90 (Value saved was 0x00061a80)
							// Restore PC from Stack at 0x10001f94 (Value saved was 0x00004365)
							// Stack Pointer updated to 0x10001f98

							// 0x00000000 = 0x0000001c * 0x00000000;
							reg4 = 0x0000001c * reg4;

							// MemRead 8 kB SRAM0 (address was computed as 0x100000a8 + reg4)
							// MemWrite I2C: SCLH (address was computed as *(uint32_t*)0x100000a8 + 0x00000010)
							*(uint32_t*)0x40000010 = ((uint32_t)period_in_cycles/2); // = 0x0000003c (modified bits = 0x00000038)

							// MemRead 8 kB SRAM0 (address was computed as 0x100000a8 + reg4)
							// MemRead I2C: SCLH (address was computed as *(uint32_t*)0x100000a8 + 0x00000010)
							// 0x0000003c = 0x00000078 - 0x0000003c
							// MemRead 8 kB SRAM0 (address was computed as 0x100000a8 + reg4)
							// MemWrite I2C: SCLL (address was computed as *(uint32_t*)0x100000a8 + 0x00000014)
							*(uint32_t*)0x40000014 = period_in_cycles - *(uint32_t*)0x40000010; // = 0x0000003c (modified bits = 0x00000038)

						}
						// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x40044000)
						// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x00000001)
						// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
						// Restore PC from Stack at 0x10001fa4 (Value saved was 0x00005ce7)
						// Stack Pointer updated to 0x10001fa8

						// Branch from 0x00005cea to 0x00004380 (Set LR to 0x00005cef)

						// MemRead 8 kB SRAM0 (address was computed as 0x100000a8 + 0x00000010)
						// Compute 0x00000000 - 0x00000000 for compare
						if (*(uint32_t*)0x100000b8 - 0x00000000) is Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x00004390
						}

						// MemWrite 8 kB SRAM0 (address was computed as 0x100000a8 + 0x00000008)
						*(uint32_t*)0x100000b0 = 0x0000424d (modified bits = 0x00000000)

						// MemRead 8 kB SRAM0 (address was computed as 0x100000a8 + 0x00000008)
						// Compute 0x0000424d - 0x0000424d for compare
						if (*(uint32_t*)0x100000b0 - 0x0000424d) is Not equal, Z == 0
						{
							// UNKOWN PATH execute 0x0000439a
						}

						// At 0x00004398 branching to 0x00005cef (reg14)

						// Enable interrupt for I2C
						// MemWrite NVIC: ISER0 (address was computed as 0xe000e100 + 0x00000000)
						*(uint32_t*)0xe000e100 = 0x00008000; // = 0x00008000 (modified bits = 0x00018000)

					}
					// Restore reg4 from Stack at 0x10001fa8 (Value saved was 0x00010074)
					// Restore PC from Stack at 0x10001fac (Value saved was 0x00006a17)
					// Stack Pointer updated to 0x10001fb0

					// Branching from PC = 0x00006a18 to PC = 0x00006a20

					// 0x00000009 = 0x0000000a - 0x00000001
					reg4 = 0x0000000a - 0x00000001;

					Carry clear, C == 0
					{
						// UNKOWN PATH execute 0x00006a34
					}

					reg3 = 0x0000e980

					reg2 = 0x00000001; // (fields.imm)

					reg1 = 0x0000006b; // (fields.imm)

					reg0 = 0x00000000; // (fields.imm)

					// Branch from 0x00006a2c to 0x0000d6c4 (Set LR to 0x00006a31)
					// int writeMpu6500Reg??(arg0 = ?? (ignored if arg2 is <0x3f) (0), i2cRegAddr = 0x6b, arg2 = ?? (1), arg3 = ?? (0x0000e980))	
					{
						// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x00000009)
						// Save reg5 to Stack at 0x10001fa4 (Value saved is 0x00000001)
						// Save reg6 to Stack at 0x10001fa8 (Value saved is 0x00010074)
						// Save reg14 to Stack at 0x10001fac (Value saved is 0x00006a31)
						// Stack Pointer updated to 0x10001fa0

						reg6 = 0xffffffff;

						// Compute 0x00000001 - 0x0000003f for compare
						if (arg2 - 0x0000003f) is Carry set, C == 1
						{
							// UNKOWN PATH execute 0x0000d710
						}

						// Set I2C_XFER_T.rxSz to 0, indicating only transmission will be carried out
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d80 + 0x00000010)
						*(uint32_t*)0x10000d90 = 0x00000000 (modified bits = 0x00000000)

						// Set I2C_XFER_T.txSz 
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d80 + 0x00000008)
						*(uint32_t*)0x10000d88 = arg2 + 0x00000001; // = 0x00000002 (modified bits = 0x00000002)
						
						// Set I2C_XFER_T.txBuff
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d80 + 0x00000004)
						*(uint32_t*)0x10000d84 = 0x10000d98 (modified bits = 0x10000d98)

						// I2C_XFER_T.txBuff[0] = 0x6b (Write to reg PWR_MGMT_1)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d98 + 0x00000000)
						*(uint8_t*)0x10000d98 = i2cRegAddr; // = 0x6b (modified bits = 0x6b)

						// Branch from 0x0000d6e4 to 0x0000218c (Set LR to 0x0000d6e9)

						// 0x40000000 = 0x1000ed99 << 30 (Carry Out = 0x00000000)
						if (((uint32_t)(0x10000d99 | arg3) << 30)) Equal, Z == 1
						{
							// UNKOWN PATH execute 0x0000219c
						}

						// Branching from PC = 0x00002194 to PC = 0x000021aa

						// 0x00000000 = 0x00000001 - 0x00000001
						if (arg2 - 0x00000001) NOT Carry set, C == 1
						{
							// UNKOWN PATH execute 0x000021ae
						}

						// Set I2C_XFER_T.txBuff[1] = 0x40 (Put the MPU6500 into sleep mode)
						// MemWrite 8 kB SRAM0 (address was computed as 0x10000d99 + 0x00000000)
						*(uint8_t*)0x10000d99 = 0x40 (modified bits = 0x40)

						// 0xffffffff = 0x00000000 - 0x00000001
						if ((arg2 - 0x00000001) - 0x00000001) Carry set, C == 1
						{
							// UNKOWN PATH execute 0x000021a2
						}

						// At 0x000021ae branching to 0x0000d6e9 (reg14)

						// Branch from 0x0000d6ea to 0x000040e0 (Set LR to 0x0000d6ef)

						reg3 = 0x00000020

						// Make sure clock is enabled for I2C
						// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						// 0x0c09617f = 0x0c09617f | 0x00000020;
						// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 | 0x00000020; // = 0x0c09617f (modified bits = 0x00000000)

						// At 0x000040ec branching to 0x0000d6ef (reg14)

						reg4 = 0x00000000; // (fields.imm)

						// MemRead 128 kB on-chip flash (address encoded in instruction)
						xfer = 0x10000d80

						i2cId = 0x00000000; // (fields.imm)

						// Branch from 0x0000d6f4 to 0x000042f0 (Set LR to 0x0000d6f9)
						// \return I2C_XFER_T.status
						// int Chip_I2C_MasterTransfer(I2C_ID_T i2cId = 0, I2C_XFER_T *xfer = 0x10000d80)
						{
							// Save reg4 to Stack at 0x10001f90 (Value saved is 0x00000000)
							// Save reg5 to Stack at 0x10001f94 (Value saved is 0x00000001)
							// Save reg6 to Stack at 0x10001f98 (Value saved is 0xffffffff)
							// Save reg14 to Stack at 0x10001f9c (Value saved is 0x0000d6f9)
							// Stack Pointer updated to 0x10001f90

							reg5 = xfer; // = 0x10000d80

							reg6 = i2cId; // = 0x00000000

							// 0x100000a8 = 0x00000000 + 0x100000a8
							reg4 = ((i2cId * 0x0000001c) + 0x100000a8);

							// MemRead 8 kB SRAM0 (address was computed as ((i2cId * 0x0000001c) + 0x100000a8) + 0x00000008)
							// At 0x00004304 branching to 0x0000424d (*(uint32_t*)0x100000b0). LR set to 0x00004306

							// Compute 0x00000003 - 0x00000001 for compare
							if (0x00000003 - 0x00000001) is NOT Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00004258
							}

							// At 0x00004262 branching to 0x00004307 (reg14)

							// MemWrite 8 kB SRAM0 (address was computed as xfer + 0x00000014)
							*(uint8_t*)0x10000d94 = 0x04 (modified bits = 0x04)

							// MemWrite 8 kB SRAM0 (address was computed as ((i2cId * 0x0000001c) + 0x100000a8) + 0x00000010)
							*(uint32_t*)0x100000b8 = xfer; // = 0x10000d80 (modified bits = 0x10000d80)

							// MemRead 8 kB SRAM0 (address was computed as ((i2cId * 0x0000001c) + 0x100000a8) + 0x00000014)
							// Compute 0x00000000 - 0x00000000 for compare
							if (*(uint32_t*)0x100000bc - 0x00000000) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x0000431c
							}

							// MemRead 8 kB SRAM0 (address was computed as ((i2cId * 0x0000001c) + 0x100000a8) + 0x00000000)
							// MemWrite I2C: CONCLR (address was computed as *(uint32_t*)0x100000a8 + 0x00000018)
							*(uint32_t*)0x40000018 = 0x0000003c (modified bits = 0x00000050)

							// Set START flag and I2C interface enable
							// MemRead 8 kB SRAM0 (address was computed as ((i2cId * 0x0000001c) + 0x100000a8) + 0x00000000)
							// MemWrite I2C: CONSET (address was computed as *(uint32_t*)0x100000a8 + 0x00000000)
							*(uint32_t*)0x40000000 = 0x00000060 (modified bits = 0x00000060)

							// MemRead 8 kB SRAM0 (address was computed as ((i2cId * 0x0000001c) + 0x100000a8) + 0x00000008)
							// At 0x00004322 branching to 0x0000424d (*(uint32_t*)0x100000b0). LR set to 0x00004324

							reg2 = 0x100000a8

							// Compute 0x00000001 - 0x00000001 for compare
							if (0x00000001 - 0x00000001) is Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00004262
							}

							// MemRead 8 kB SRAM0 (address was computed as ((0x0000001c * i2cId) + 0x100000a8) + 0x00000010)
							// 0x10000d94 = 0x10000d80 + 0x00000014
							reg0 = (*(uint32_t*)0x100000b8 + 0x00000014)

							// MemRead 8 kB SRAM0 (address was computed as ((0x0000001c * i2cId) + 0x100000a8) + 0x00000010)
							// MemRead 8 kB SRAM0 (address was computed as (*(uint32_t*)0x100000b8 + 0x00000014) + 0x00000000)
							reg1 = *(uint8_t*)0x10000d94; // = 0x00000004

							// Loop waiting for I2C_XFER_T.status not be I2C_STATUS_BUSY
							// MemRead 8 kB SRAM0 (address was computed as ((0x0000001c * i2cId) + 0x100000a8) + 0x00000010)
							// MemRead 8 kB SRAM0 (address was computed as (*(uint32_t*)0x100000b8 + 0x00000014) + 0x00000000)
							// Compute 0x00000004 - 0x00000004 for compare
							if (*(uint8_t*)0x10000d94 - 0x00000004) is Equal, Z == 1
							{
								// UNKOWN PATH execute 0x0000425c
							}

							// At 0x00004262 branching to 0x00004325 (reg14)

							// Clear out pointer used by ISR
							// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000010)
							*(uint32_t*)0x100000b8 = 0x00000000 (modified bits = 0x10000d80)

							// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000000)
							// MemRead I2C: CONSET (address was computed as *(uint32_t*)0x100000a8 + 0x00000000)
							// 0x00000000 = 0x00000060 << 27 (Carry Out = 0x00000020)
							// 0x00000000 = 0x00000000 >> 31 (Carry Out = 0x00000000)
							// 0x00000001 = 0x00000000 + 0x00000001
							reg0 = ((uint32_t)((uint32_t)*(uint32_t*)0x40000000 << 27) >> 31) + 0x00000001;

							Equal, Z == 1
							{
								// UNKOWN PATH execute 0x0000432a
							}

							// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000018)
							// 0x00000000 = 0x00000000 << 16 (Carry Out = 0x00000000)
							// 0x00000000 = 0x00000000 >> 24 (Carry Out = 0x00000000)
							reg0 = (uint32_t)((uint32_t)*(uint16_t*)0x100000c0 << 16) >> 24;

							NOT Equal, Z == 1
							{
								// UNKOWN PATH execute 0x0000433c
							}

							// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000008)
							// At 0x0000434a branching to 0x0000424d (*(uint32_t*)0x100000b0). LR set to 0x0000434c

							// 0x00000000 = 0x0000001c * 0x00000000;
							// 0x100000a8 = 0x00000000 + 0x100000a8
							reg0 = (0x0000001c * i2cId) + 0x100000a8;

							// Compute 0x00000004 - 0x00000001 for compare
							if (0x00000004 - 0x00000001) is NOT Not equal, Z == 0
							{
								// UNKOWN PATH execute 0x00004258
							}

							// At 0x00004262 branching to 0x0000434d (reg14)

							// MemRead 8 kB SRAM0 (address was computed as reg5 + 0x00000014)
							I2C_XFER_T.status = *(uint8_t*)0x10000d94; // = 0x00000000

						}
						// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x00000000)
						// Restore reg5 from Stack at 0x10001f94 (Value saved was 0x00000001)
						// Restore reg6 from Stack at 0x10001f98 (Value saved was 0xffffffff)
						// Restore PC from Stack at 0x10001f9c (Value saved was 0x0000d6f9)
						// Stack Pointer updated to 0x10001fa0

						// 0x00000000 = 0x00000000 << 0 (Carry Out = 0x20000000)
						reg5 = (uint32_t)I2C_XFER_T.status << 0;

						NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x0000d6fc
						}

						// Branch from 0x0000d708 to 0x000040a4 (Set LR to 0x0000d70d)

						// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						// 0x0c09615f = 0x0c09617f & ~0x00000020;
						// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
						*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 & ~0x00000020; // = 0x0c09615f (modified bits = 0x00000020)

						// At 0x000040b0 branching to 0x0000d70d (reg14)

						// Compute 0x00000000 - 0x00000000 for compare
						if (((uint32_t)I2C_XFER_T.status << 0) - 0x00000000) is NOT Equal, Z == 1
						{
							// UNKOWN PATH execute 0x0000d710
						}

						reg0 = 0x00000000; // (fields.imm)

					}
					// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x00000009)
					// Restore reg5 from Stack at 0x10001fa4 (Value saved was 0x00000001)
					// Restore reg6 from Stack at 0x10001fa8 (Value saved was 0x00010074)
					// Restore PC from Stack at 0x10001fac (Value saved was 0x00006a31)
					// Stack Pointer updated to 0x10001fb0

					// Compute 0x00000000 - 0x00000000 for compare
					if (reg0 - 0x00000000) is Not equal, Z == 0
					{
						// UNKOWN PATH execute 0x00006a1a
					}

				}
				// Restore reg4 from Stack at 0x10001fb0 (Value saved was 0x00010074)
				// Restore PC from Stack at 0x10001fb4 (Value saved was 0x00005fd7)
				// Stack Pointer updated to 0x10001fb8

			}
			// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005df3)
			// Stack Pointer updated to 0x10001fc0

			// Branch from 0x00005df4 to 0x00002fcc (Set LR to 0x00005df9)

			// MemWrite 8 kB SRAM0 (address was computed as 0x10000344 + 0x00000004)
			*(uint32_t*)0x10000348 = 0x0000a895 (modified bits = 0x0000a895)

			// At 0x00002fd0 branching to 0x00005df9 (reg14)

			reg1 = 0x00000001; // (fields.imm)

			reg0 = 0x00000006; // (fields.imm)

			// Branch from 0x00005dfc to 0x000098f0 (Set LR to 0x00005e01)
			// void fnc(uint8_t arg0 ??, arg1 ??)
			{
				// Save reg4 to Stack at 0x10001fb8 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fbc (Value saved is 0x00005e01)
				// Stack Pointer updated to 0x10001fb8

				// MemRead 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000001)
				// Compute 0x00000006 - 0x00000000 for compare
				if (reg0 - *(uint8_t*)0x10000003) is Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000990e
				}

				// MemRead 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000001)
				// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000002)
				*(uint8_t*)0x10000004 = *(uint8_t*)0x10000003; // = 0x00 (modified bits = 0x00)

				// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000000)
				*(uint8_t*)0x10000002 = 0x00 (modified bits = 0x01)

				// Compute 0x00000001 - 0x00000000 for compare
				if (reg1 - 0x00000000) is Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000990e
				}

				// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000001)
				*(uint8_t*)0x10000003 = reg0; // = 0x06 (modified bits = 0x06)

				// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000003)
				*(uint8_t*)0x10000005 = 0xff (modified bits = 0xff)

				// Branch from 0x0000990a to 0x0000a434 (Set LR to 0x0000990f)
				// void fnc()
				{
					// Save reg3 to Stack at 0x10001fa8 (Value saved is 0x10000002)
					// Save reg4 to Stack at 0x10001fac (Value saved is 0x00010074)
					// Save reg5 to Stack at 0x10001fb0 (Value saved is 0x00000001)
					// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x0000990f)
					// Stack Pointer updated to 0x10001fa8

					// MemWrite 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000003)
					*(uint8_t*)0x10000005 = 0x00 (modified bits = 0xff)

					// MemRead 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000001)
					// MemRead 128 kB on-chip flash (address was computed as 0x0000e9ca + (0x00000012 * (*(uint8_t*)0x10000003)))
					// Compute 0x00000001 - 0x00000000 for compare
					if (*(uint8_t*)0x0000ea36 - 0x00000000) is NOT Not equal, Z == 0
					{
						// UNKOWN PATH execute 0x0000a452
					}

					// MemRead 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000001)
					// 0x0000ea36 = 0x0000006c + 0x0000e9ca
					// 0x0000ea36 = 0x0000ea36 + 0x00000000
					// MemRead 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000003)
					// 0x00000000 = 0x00000000 << 2 (Carry Out = 0x00000000)
					// MemRead 128 kB on-chip flash (address was computed as ((0x00000012 * (*(uint8_t*)0x10000003)) + 0x0000e9ca + ((uint32_t)(int32_t)(*(int8_t*)0x10000005) << 2)) + 0x00000002)
					// MemWrite 8 kB SRAM0 (address was computed as reg13 + 0x00000000)
					*(uint16_t*)0x10001fa8 = *(uint16_t*)0x0000ea38; // = 0xd2d2 (modified bits = 0xd2d0)

					// MemRead 8 kB SRAM0 (address was computed as reg13 + 0x00000000)
					reg0 = *(uint8_t*)0x10001fa8; // = 0x000000d2

					// Branch from 0x0000a484 to 0x00007368 (Set LR to 0x0000a489)
					// void fnc(uint16_t arg0 ??)
					{
						// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x000001f4)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x0000a489)
						// Stack Pointer updated to 0x10001fa0

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000006)
						*(uint16_t*)0x1000004a = reg0; // = 0x00d2 (modified bits = 0x00d2)

						// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x0000000a)
						*(uint16_t*)0x1000004e = reg0; // = 0x00d2 (modified bits = 0x00d2)

						// Branch from 0x00007370 to 0x0000e65c (Set LR to 0x00007375)

						// Function for calculating MR0 value. Input arg is *(uint8_t*)0x10001fa8
						{
							//... See earlier rundown of this function for details

							// 0x000009d9 = 0x00001000 - 0x00000627
							reg0 = reg1 - reg0;

						}
						// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x10000044)
						// Restore reg5 from Stack at 0x10001f94 (Value saved was 0x00000001)
						// Restore reg6 from Stack at 0x10001f98 (Value saved was 0x00010074)
						// Restore PC from Stack at 0x10001f9c (Value saved was 0x00007375)
						// Stack Pointer updated to 0x10001fa0

						// MemRead 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000001)

						// MemRead 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000001)
						// 0x00000000 = 0x00000000 << 2 (Carry Out = 0x00000000)
						// 0x40010000 = 0x00000000 + 0x40010000
						// MemRead 8 kB SRAM0 (address was computed as 0x10000044 + 0x0000000c)
						reg1 = ((uint32_t)(int32_t)(*(int8_t*)0x10000045) << 2) + *(uint32_t*)0x10000050;

						// MemWrite CT16B1: MR0 (address was computed as reg1 + 0x00000018)
						*(uint32_t*)0x40010018 = reg0; // = 0x000009d9 (modified bits = 0x000009d9)

					}
					// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x000001f4)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x0000a489)
					// Stack Pointer updated to 0x10001fa8

					// Branch from 0x0000a48a to 0x00007430 (Set LR to 0x0000a48f)

					// MemRead 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000001)
					// 0x0000ea36 = 0x0000006c + 0x0000e9ca
					// 0x0000ea36 = 0x0000ea36 + 0x00000000
					// MemRead 8 kB SRAM0 (address was computed as 0x10000002 + 0x00000003)
					// 0x00000000 = 0x00000000 << 2 (Carry Out = 0x00000000)
					// MemRead 128 kB on-chip flash (address was computed as ((0x00000012 * (*(uint8_t*)0x10000003)) + 0x0000e9ca + ((uint32_t)(int32_t)(*(int8_t*)0x10000005) << 2)) + 0x00000004)
					// MemWrite 8 kB SRAM0 (address was computed as 0x10000044 + 0x00000004)
					*(uint16_t*)0x10000048 = *(uint16_t*)0x0000ea3a; // = 0x01f4 (modified bits = 0x0000)

					// At 0x00007434 branching to 0x0000a48f (reg14)

					// MemRead 8 kB SRAM0 (address was computed as reg13 + 0x00000001)
					reg0 = *(uint8_t*)0x10001fa9; // = 0x000000d2

					reg1 = 0x00000001; // (fields.imm)

					// Branch from 0x0000a494 to 0x00007404 (Set LR to 0x0000a499)
					// fnc(uint8_t arg0 = *(uint8_t*)0x10001fa9, uint32_t arg1 = 0x00000001)
					{
						// Save reg4 to Stack at 0x10001f98 (Value saved is 0x000001f4)
						// Save reg5 to Stack at 0x10001f9c (Value saved is 0x00000001)
						// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
						// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x0000a499)
						// Stack Pointer updated to 0x10001f98

						// MemRead 128 kB on-chip flash (address encoded in instruction)
						reg4 = *(uint32_t*)0x00007420; // = 0x10000044

						reg5 = reg1; // = 0x00000001

						// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x0000000a)
						reg1 = *(uint16_t*)0x1000004e; // = 0x000000d2

						// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000008)
						*(uint16_t*)0x1000004c = reg1; // = 0x00d2 (modified bits = 0x00d2)

						// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000006)
						*(uint16_t*)0x1000004a = reg0; // = 0x00d2 (modified bits = 0x0000)

						// Branch from 0x00007410 to 0x00009aac (Set LR to 0x00007415)

						// MemRead 128 kB on-chip flash (address encoded in instruction)
						reg0 = *(uint32_t*)0x00009ab4; // = 0x10000324

						// MemRead 8 kB SRAM0 (address was computed as reg0 + 0x0000000c)
						reg0 = *(uint32_t*)0x10000330; // = 0x00000000

						// At 0x00009ab0 branching to 0x00007415 (reg14)

						// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000014)
						*(uint32_t*)0x10000058 = reg0; // = 0x00000000 (modified bits = 0x00000000)

						// MemRead 8 kB SRAM0 (address was computed as reg4 + 0x00000004)
						reg1 = *(uint16_t*)0x10000048; // = 0x000001f4

						// 0x000001f4 = 0x00000000 + 0x000001f4
						reg0 = reg0 + reg1;

						// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000018)
						*(uint32_t*)0x1000005c = reg0; // = 0x000001f4 (modified bits = 0x00000000)

						// MemWrite 8 kB SRAM0 (address was computed as reg4 + 0x00000000)
						*(uint8_t*)0x10000044 = reg5; // = 0x01 (modified bits = 0x00)

					}
					// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x000001f4)
					// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x00000001)
					// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
					// Restore PC from Stack at 0x10001fa4 (Value saved was 0x0000a499)
					// Stack Pointer updated to 0x10001fa8

				}
				// Restore reg3 from Stack at 0x10001fa8 (Value saved was 0x1000d2d2)
				// Restore reg4 from Stack at 0x10001fac (Value saved was 0x00010074)
				// Restore reg5 from Stack at 0x10001fb0 (Value saved was 0x00000001)
				// Restore PC from Stack at 0x10001fb4 (Value saved was 0x0000990f)
				// Stack Pointer updated to 0x10001fb8

			}
			// Restore reg4 from Stack at 0x10001fb8 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fbc (Value saved was 0x00005e01)
			// Stack Pointer updated to 0x10001fc0

// This path seems to be going to a route of giving up? (i.e. checking if power is OK)
//	Are we waiting for some other interrupt to occur at this point? Or did we already go down a path that is leading to waiting for the controller to power down?

			// Branch from 0x00005e00 to 0x00002cf0 (Set LR to 0x00005e05)

}

/**
 * There reaches a point in the init code (i.e. execution starting from the RESET
 *  entry point as defined in the Vector Table) in which the hw version read 
 *  from EEPROM causes a significant branch in the code. I am calling everything
 *  after this branch point phase2, and creating different functions to 
 *  encapsulate what has been decomposed depending on what hw version was read.
 *
 * This function captures the path of reading a hw version of 0.
 *
 * This path I decomposed before properly aquiring EEPROM data. This is kept 
 *  mostly for the sake of having already put the work in. It most likely will 
 *  not actually be useful at this point.
 *
 * \return None.
 */
void init_phase2_hw_0() 
{
        // Entry Num: 60118 - 60140
        // Step Num: 46409 - 46423
	// Firmware Offset(s): 
	//	0x00001618 - 0x00001618
	//	0x00000f28 - 0x00000f28
	//	0x00000a78 - 0x00000a80
	//	0x00000534 - 0x00000542

	// Select USB PLL out via USB clock source select register
	reg32 = (volatile uint32_t*)0x400480c0;
	*reg32 = 0;
	// Clear USB clock source update enable register
	reg32 = (volatile uint32_t*)0x400480c4;
	*reg32 = 0;
	// Update clock source via USB clock source update enable register
	reg32 = (volatile uint32_t*)0x400480c4;
	*reg32 = 1;
	// Set divide by 1 for USB clock divider register
	reg32 = (volatile uint32_t*)0x400480c8;
	*reg32 = 1;


        // Entry Num: 60141 - 60152
        // Step Num: 46424 - 46432
	// Firmware Offset(s): 
	//	0x00000a84 - 0x00000a86
	//	0x0000043c - 0x00000448

	// Enables clock to the USB register interface via System clock control register
	reg32 = (volatile uint32_t*)0x40048080;
	val = *reg32;
	val |= 0x00004000;
	*reg32 = val;


        // Entry Num: 60153 - 60164
        // Step Num: 46433 - 46441
	// Firmware Offset(s): 
	//	0x00000a8a - 0x00000a8c
	//	0x0000043c - 0x00000448

	// Enables USB SRAM block at address 0x2000 4000 via System clock control register 
	reg32 = (volatile uint32_t*)0x40048080;
	val = *reg32;
	val |= 0x08000000;
	*reg32 = val;


        // Entry Num: 60165 - 60177
        // Step Num: 46442 - 46449
	// Firmware Offset(s): 
	//	0x00000a90 - 0x00000a9e

	// Write 0x1fff1f24 to RAM address 0x10000230, which was read from boot ROM
	// 0x1fff1f24 is pointer to USBD_HW_API_T
	*0x10000230 = 0x1fff1f24;


        // Entry Num: 60178 - 60524
        // Step Num: 46450 - 46728
	// Firmware Offset(s): 
	//	0x0000035e - 0x00000360
	//	0x00000350 - 0x00000352
	//	0x00000354 - 0x0000035c

	// Write 0's (byte by byte) SRAM0 for range 0x10001ba0 - 0x10001be3


        // Entry Num: 60525 - 60564
        // Step Num: 46729 - 46752
	// Firmware Offset(s): 
	//	0x00000aa2 - 0x00000ad0

	// Fill in USBD_API_INIT_PARAM_T
	*0x10001ba0 = 0x40080000; // usb_reg_base - USB device controller's base register address
	*0x10001ba4 = 0x20004000; // mem_base - Base memory location from where the stack can allocate
                      // data and buffers. \note The memory address set in this field
                      // should be accessible by USB DMA controller. Also this value
                      // should be aligned on 2048 byte boundary
	*0x10001ba8 = 0x00000800; // mem_size - The size of memory buffer which stack can use.       
                      // \note The \em mem_size should be greater than the size    
                      // returned by USBD_HW_API::GetMemSize() routine
	*0x10001bac = 0x00000003; // max_num_ep - max number of endpoints supported by the USB device  
                      // controller instance (specified by \em usb_reg_base field) 
                      // to which this instance of stack is attached.

	*0x10001bb0 = 0x00000000; // USB_Reset_Event - USB Device Events Callback Function
	*0x10001bb4 = 0x00000000; // USB_Suspend_Event - USB Device Events Callback Function
	*0x10001bb8 = 0x00000000; // USB_Resume_Event - USB Device Events Callback Function
	*0x10001bbc = 0x00000000; // reserved_sbz 

	*0x10001bc0 = 0x00000000; // USB_SOF_Event - USB Device Events Callback Function
	*0x10001bc4 = 0x00000000; // USB_WakeUpCfg 
	*0x10001bc8 = 0x00000000; // USB_Power_Event
	*0x10001bcc = 0x00000000; // USB_Error_Event

	*0x10001bd0 = 0x00000000; // USB_Configure_Event
	*0x10001bd4 = 0x00000000; // USB_Interface_Event
	*0x10001bd8 = 0x00000000; // USB_Feature_Event
	*0x10001bdc = 0x00000000; // Reserved for future use, should be set to 0

	*0x10001be0 = 0x00000000; // Reserved for future use, should be set to 0

	// Fill in USB_CORE_DESCS_T
	*0x10001be4 = 0x00001670; // device_desc - Pointer to USB device descriptor
	*0x10001be8 = 0x00001682; // string_desc - Pointer to array of USB string descriptors
	*0x10001bec = 0x10000208; // full_speed_desc - Pointer to USB device configuration descriptor 
                            // when device is operating in full speed mode
	*0x10001bf0 = 0x10000208; // high_speed_desc - Pointer to USB device configuration descriptor 
                            // when device is operating in high speed mode. For  
                            // full-speed only implementation this pointer should
                            // be same as full_speed_desc.
	*0x10001bf4 = 0x00000000; // device_qualifier; /**< Pointer to USB device qualifier descriptor. For
                            // full-speed only implementation this pointer should
                            // be set to null (0).
	

        // Entry Num: 60565 - 64185 
        // Step Num: 46753 - 49528
	// Firmware Offset(s): 
	//	0x1fff351c - 0x1fff3562
	//	... 

	USBD_HW_API->Init(USBD_HANDLE_T* phUsb = 0x1000022c, USB_CORE_DESCS_T* pDesc = 0x10001be4, USBD_API_INIT_PARAM_T* param = 0x10001ba0)
	// \param[in,out] phUsb Pointer to the USB device stack handle of type USBD_HANDLE_T.
	// \param[in]  pDesc Structure containing pointers to various descriptor arrays needed by the stack.
	// 		  These descriptors are reported to USB host as part of enumerations process.
	// \param[in]  param Structure containing USB device stack initialization parameters.
	// \return Returns \ref ErrorCode_t type to indicate success or error condition.
	// 	\retval LPC_OK(0) On success                                      
	// 	\retval ERR_USBD_BAD_MEM_BUF(0x0004000b) When insufficient memory buffer is passed or memory
        //                                    is not aligned on 2048 boundary.

	// reg32 0 = 0 -> Return code LPC_OK
	// *0x1000022c = 0x200040b8 --> USB_HANDLE_T USB device stack handle

	//TODO: Worth looking at decomp of Boot ROM call below or just rely on function description and input parameter values?

		// Clear 0x20004000 - 0x2000405f (byte-wise zero write)
		// Clear 0x200040b8 - 0x20004223 (byte-wise zero write)
		// Clear 0x20004090 - 0x200040b7 (byte-wise zero write)

		// USB EP Command/Status List:
		*0x20004000 = 0x00400109 // EP0 OUT Buffer NBytes | EP0 OUT Buffer Address Offset
		*0x20004004 = 0x0040010a // Reserved | SETUP bytes Buffer Address Offset
		*0x20004008 = 0x00400109 // EP0 IN Buffer NBytes | EP0 IN Buffer Address Offset
		*0x2000400c = 0x40000000 // Reserved | Reserved
		*0x20004010 = 0x40000000 // EP 1 OUT Buffer 0
		*0x20004014 = 0x40000000 // EP 1 OUT Buffer 1
		*0x20004018 = 0x40000000 // EP 1 IN Buffer 0
		*0x2000401c = 0x40000000 // EP 1 IN Buffer 1
		*0x20004020 = 0x40000000 // EP 2 OUT Buffer 0
		*0x20004024 = 0x40000000 // EP 2 OUT Buffer 1
		*0x20004028 = 0x40000000 // EP 2 IN Buffer 0
		*0x2000402C = 0x00000000 // EP 2 IN Buffer 1
		*0x20004030 = 0x20004240 // EP 3 OUT Buffer 0
		*0x20004034 = 0x00000040 // EP 3 OUT Buffer 1
		*0x20004038 = 0x20004280 // EP 3 IN Buffer 0
		*0x2000403c = 0x00000008 // EP 3 IN Buffer 1
		*0x20004040 = 0x20004240 // EP 4 OUT Buffer 0
		*0x20004044 = 0x00000000 // EP 4 OUT Buffer 1
		*0x20004048 = 0x00000000 // EP 4 IN Buffer 0
		*0x2000404c = 0x00000000 // EP 4 IN Buffer 1

		*0x20004090 = 0x20004000
		*0x20004094 = 0x20004030
		*0x20004098 = 0x00000000
		*0x2000409c = 0x00000000
		*0x200040a0 = 0x200042c0
		*0x200040a4 = 0x00000000
		*0x200040a8 = 0x00000000
		*0x200040aC = 0x00000000
		*0x200040b0 = 0x40080000
		*0x200040b4 = 0x200040b8

		// This is the USB device stack handle (USBD_HANDLE_T), but not sure what this means exactly...
		*0x200040b8 = 0x1fff27bf 
		*0x200040bc = 0x1fff28d1
		*0x200040c0 = 0x00000000
		*0x200040c4 = 0x1fff22ab
		*0x200040c8 = 0x1fff23f3
		*0x200040cc = 0x1fff2491
		*0x200040d0 = 0x1fff24ad
		*0x200040d4 = 0x1fff2651
		*0x200040d8 = 0x1fff268d
		*0x200040dc = 0x1fff2329
		*0x200040e0 = 0x00000000
		*0x200040e4 = 0x00000000
		*0x200040e8 = 0x00000000
		*0x200040ec = 0x00000000
		*0x200040f0 = 0x00000000
		*0x200040f4 = 0x00000000
		*0x200040f8 = 0x00000000
		*0x200040fc = 0x00000000
		*0x20004100 = 0x00000000
		*0x20004104 = 0x00000000
		*0x20004108 = 0x1fff29d3
		*0x2000410c = 0x1fff29d5
		*0x20004110 = 0x1fff293d
		*0x20004114 = 0x1fff293d
		*0x20004118 = 0x1fff2e55
		*0x2000411c = 0x1fff2e55
		*0x20004120 = 0x1fff2e55
		*0x20004124 = 0x1fff2e55
		*0x20004128 = 0x1fff2e55
		*0x2000412c = 0x1fff2e55
		*0x20004130 = 0x1fff2e55	
		*0x20004134 = 0x1fff2e55
		*0x20004138 = 0x200040b8
		*0x2000413c = 0x200040b8
		*0x200041a0 = 0x00000000
		*0x200041a4 = 0x00000000
		*0x200041a8 = 0x00001670
		*0x200041ac = 0x00001682
		*0x200041b0 = 0x10000208
		*0x200041b4 = 0x10000208
		*0x200041b8 = 0x00000000
		*0x200041bc = 0x00000000

		*0x200041d0 = 0x20004090

		// USB Device Command/Status register (DEVCMDSTAT)
		reg32 = (volatile uint32_t*)0x40080000;
		*reg32 = 0;

		// USB EP Command/Status List start address
		reg32 = (volatile uint32_t*)0x40080008;
		*reg32 = 0x20004000;
		// TODO: See how 0x20004000 has been filled out to build this

		// USB Data buffer start address (DATABUFSTART)
		reg32 = (volatile uint32_t*)0x4008000c;
		*reg32 = 0x20004240;

		// USB Endpoint Buffer in use (EPINUSE)
		reg32 = (volatile uint32_t*)0x40080018;
		*reg32 = 0x00000000;

		// USB Endpoint skip (EPSKIP)
		reg32 = (volatile uint32_t*)0x40080014;
		*reg32 = 0x00000000;

		// USB Endpoint Buffer Configuration (EPBUFCFG)
		reg32 = (volatile uint32_t*)0x4008001c;
		*reg32 = 0x000003ff;

		// USB interrupt status register (INTSTAT)
		reg32 = (volatile uint32_t*)0x40080020;
		*reg32 = 0xc00003ff;
		
		// USB interrupt enable register (INTEN)
		reg32 = (volatile uint32_t*)0x40080024;
		*reg32 = 0x800003ff;

		//TODO These are reading back register looking for hardware to set bits?
		// USB Device Command/Status register (DEVCMDSTAT)
		reg32 = (volatile uint32_t*)0x40080000;
		*reg32 = 0x00000000;
		
		// USB Device Command/Status register (DEVCMDSTAT)
		reg32 = (volatile uint32_t*)0x40080000;
		*reg32 = 0x00000080;
		// USB Device Command/Status register (DEVCMDSTAT)
		reg32 = (volatile uint32_t*)0x40080000;
		*reg32 = 0x00000080;
		// USB Device Command/Status register (DEVCMDSTAT)
		reg32 = (volatile uint32_t*)0x40080000;
		*reg32 = 0x00000080;
		// USB Device Command/Status register (DEVCMDSTAT)
		reg32 = (volatile uint32_t*)0x40080000;
		*reg32 = 0x00000080;
		// USB Device Command/Status register (DEVCMDSTAT)
		reg32 = (volatile uint32_t*)0x40080000;
		*reg32 = 0x00000080;


        // Entry Num: 64186 - 64203
        // Step Num: 49529 - 49540
	// Firmware Offset(s): 
	//	0x00000ad2 - 0x00000ae8

	// Check return value of Boot ROM code (reg32 0) is 0 (LPC_OK)
	// 	TODO: UNKNOWN PATHS Branch to 0x00000b14 if Boot ROM code does not return 0 (i.e. failure of USBD_HW_API->Init())


        // Entry Num: 64204 - 64504
        // Step Num: 49541 - 49780
	// Firmware Offset(s): 
	//	0x00000b40 - 0x00000b50
	//	0x0000035e - 0x00000360
	//	0x00000350 - 0x0000035c

	// Clear RAM (byte-wise) 0x10001b50 - 0x10001b87


        // Entry Num: 64505 - 64529
        // Step Num: 49781 - 49796
	// Firmware Offset(s): 
	//	0x00000b54 - 0x00000b72

	*(uint8_t*)0x10001b58 = 0x01
	*(uint16_t*)0x10000234 = 0x0021
	*(uint8_t*)0x10000236 = 0x00
	*0x10000238 = 0x0000164c

	// Check if reg32 4 is 0
	// 	TODO: UNKNOWN PATHS Branch to 0x00000b74 if reg32 4 is 0

	// Check if byte at RAM address 0x10000216 is 3
	// Thisis set during some init code when initially setting up RAM (instruction 0x00001532)... Not sure what this byte represents... Maybe number of USB EPs?
	// 	TODO: UNKNOWN PATHS do not branch and instead execute 0x00000b72 if this is false


        // Entry Num: 64530 - 64557
        // Step Num: 49797 - 49812
	// Firmware Offset(s): 
	//	0x00000b7c - 0x00000b9a

	// Fill in USBD_HID_INIT_PARAM_T
	*0x10001b50 = 0x20004340 // mem_base - Base memory location from where the stack can allocate
                      // data and buffers. \note The memory address set in this field
                      // should be accessible by USB DMA controller. Also this value
                      // should be aligned on 4 byte boundary
	*0x10001b54 = 0x000004c0 // mem_size - The size of memory buffer which stack can use.       
                      // \note The \em mem_size should be greater than the size    
                      // returned by USBD_HID_API::GetMemSize() routine.
	*0x10001b58 = 0x00000001 // max_reports - Number of HID reports supported by this instance    
                      // of HID class driver
	*0x10001b5c = 0x10000211 // intf_desc - Pointer to the HID interface descriptor within the   
                      // descriptor array (\em high_speed_desc) passed to Init()   
                      // through \ref USB_CORE_DESCS_T structure.
	*0x10001b60 = 0x10000234 // report_dataa - Pointer to an array of HID report descriptor
                      // data structure (\ref USB_HID_REPORT_T). The number
                      // of elements in the array should be same a \em max_reports
                      // value. The stack uses this array to respond to 
                      // requests received for various HID report descriptor
                      // information. \note This array should be of global scope
	*0x10001b64 = 0x00000961 // HID_GetReport
	*0x10001b68 = 0x0000098d // HID_SetReport


        // Entry Num: 64558 - 65051
        // Step Num: 49813 - 50172
	// Firmware Offset(s): 
	//	0x1fff2cfc - 0x1fff2d0e
	//	...

	USBD_HID_API_T->init(USBD_HANDLE_T hUsb = 0x200040b8, USBD_HID_INIT_PARAM_T* param = 0x10001b50)
	// \param[in] hUsb Handle to the USB device stack.                           
	// \param[in, out] param Structure containing HID function driver module     
	//     initialization parameters.                                            
	// \return Returns \ref ErrorCode_t type to indicate success or error condition.
	// 	\retval LPC_OK On success                                         
	// 	\retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte  
	// 	    aligned or smaller than required.                             
	// 	\retval ERR_API_INVALID_PARAM2 Either HID_GetReport() or HID_SetReport()
	// 	    callback are not defined.                                     
	// 	\retval ERR_USBD_BAD_DESC  HID_HID_DESCRIPTOR_TYPE is not defined 
	// 	    immediately after interface descriptor.                       
	// 	\retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
	// 	\retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 

	// reg32 0 = 0 -> Return code LPC_OK


        // Entry Num: 65052 - 65064
        // Step Num: 50173 - 50180
	// Firmware Offset(s): 
	//	0x00000b9c - 0x00000b9c
	//	0x00000b78 - 0x00000b7a
	//	0x00000aec - 0x00000af4

	// Check that return value of Boot ROM code (reg32 0) is 0 (LPC_OK)
	// 	TODO: UNKNOWN PATHS branching to 0x00000b14 if Boot ROM code does not return 0 (i.e. failure of USBD_HID_API_T->init())


        // Entry Num: 65065 - 65085
        // Step Num: 50181 - 50198
	// Firmware Offset(s): 
	//	0x00000d40 - 0x00000d50
	//	0x00000d6a - 0x00000d7a

	// Input argument is checked to be >= 0, however, is set by call into function, so no path to dig down here, yet

	// Set IP_USB_IRQ priority to highest via Interrupt Priority Register 5
	reg32 = (volatile uint32_t*)0xe000e414;
	val = *reg32;
	val &= ~0x00ff0000;
	*reg32 = val;


        // Entry Num: 65086 - 65094
        // Step Num: 50199 - 50205
	// Firmware Offset(s): 
	//	0x00000af8 - 0x00000b04

	// Enable interrupt 22 (USB_IRQ USB IRQ interrupt) via ISER register of NVIC
	reg32 = (volatile uint32_t*)0xe000e100;
	*reg32 = 0x00400000;


        // Entry Num: 65095 - 65115
        // Step Num: 50206 - 50223
	// Firmware Offset(s): 
	//	0x00000d40 - 0x00000d50
	//	0x00000d6a - 0x00000d7a

	// Set IP_USB_IRQ priority to 1 (one below highest) via Interrupt Priority Register 5
	reg32 = (volatile uint32_t*)0xe000e414;
	val = *reg32;
	val &= ~0x00ff0000;
	val |= 0x00400000;
	*reg32 = val;


        // Entry Num: 65116 - 65125
        // Step Num: 50224 - 50229
	// Firmware Offset(s): 
	//	0x00000b08 - 0x00000b12

	// Prep for Boot ROM code
	// reg32 0 = 0x200040b8
	// reg32 1 = 1


        // Entry Num: 65126 - 65142
        // Step Num: 50230 - 50242
	// Firmware Offset(s): 
	//	0x1fff2e92 - 0x1fff2ea6
	//	0x1fff2eaa - 0x1fff2eac

	USBD_HW_API->Connect(USBD_HANDLE_T hUsb = 0x200040b8, uint32_t con = 1);
	// \param[in] hUsb Handle to the USB device stack.                           
	// \param[in] con  States whether to connect (1) or to disconnect (0).       
	// \return Nothing.


        // Entry Num: 65143 - 65164
        // Step Num: 50243 - 50256
	// Firmware Offset(s): 
	//	0x00000b14 - 0x00000b18
	//	0x00000f2c - 0x00000f2c
	//	0x00001100 - 0x00001112

	*(uint8_t*)0x10000249 = 0x00;


        // Entry Num: 65165 - 65177
        // Step Num: 50257 - 50264
	// Firmware Offset(s): 
	//	0x00000e40 - 0x00000e4e

	*0x100006cc = 0x100005cc
	*0x100006d0 = 0x00000100
	*0x100006d4 = 0x00000001
	*0x100006d8 = 0x00000000
	*0x100006dc = 0x00000000

	int fnc(Reg0 = 0x100006cc, Reg1 = 0x100005cc, Reg2 = 0x00000001, Reg3 = 0x00000100)
	{
		uint32_t* ptr = Reg0;
		ptr[0] = Reg1;
		ptr[1] = Reg3;
		ptr[2] = Reg2;
		ptr[3] = 0;
		ptr[4] = 0;

		return 1;
	}


        // Entry Num: 65178 - 65207
        // Step Num: 50265 - 50282
	// Firmware Offset(s): 
	//	0x00001116 - 0x0000111a
	//	0x00000624 - 0x00000640

	// Enables clock for UART via System clock control register
	reg32 = (volatile uint32_t*)0x40048080;
	val = *reg32;
	val |= 0x00001000;
	*reg32 = val;

	// Set USART clock divider register to divide by 1.
	reg32 = (volatile uint32_t*)0x40048098;
	*reg32 = 0x00000001;

	// TX FIFO Reset, RX FIFO Reset and FIFO enable via USART FIFO Control Register Write only
	reg32 = (volatile uint32_t*)0x40008008;
	*reg32 = 0x00000007;

	// Set Word Length Select to 8-bit character length via USART Line Control Register
	reg32 = (volatile uint32_t*)0x4000800c;
	*reg32 = 0x00000003;

	// Set Baud rate generation pre-scaler divisor value to 0 and Baud rate pre-scaler multiplier value to 1 via USART Fractional Divider Register
	reg32 = (volatile uint32_t*)0x40008028;
	*reg32 = 0x00000010;


        // Entry Num: 65208 - 65241
        // Step Num: 50283 - 50305
	// Firmware Offset(s): 
	//	0x0000111e - 0x0000114a

	// Set RX Trigger level to 3 (14 characters or 0x0E) and FIFO enable via USART FIFO Control Register Write only
	reg32 = (volatile uint32_t*)0x40008008;
	*reg32 = 0x00000081;

	// Enable access to Divisor Latches via USART Line Control Register
	reg32 = (volatile uint32_t*)0x4000800c;
	val = *reg32;
	val |= 0x00000080;
	*reg32 = val;

	// Set the Divisor Latch LSB register to set the baud rate of the USART via the USART Divisor Latch LSB Register when DLAB = 1
	reg32 = (volatile uint32_t*)0x40008000;
	*reg32 = 0x00000003;

	// Set the Baud rate generation pre-scaler divisor value to 1 and Baud rate pre-scaler multiplier value to 0xb via the USART Fractional Divider Register
	reg32 = (volatile uint32_t*)0x40008028;
	*reg32 = 0x000000b1;

	// Disable access to Divisor Latches via USART Line Control Register
	reg32 = (volatile uint32_t*)0x4000800c;
	val = *reg32;
	val &= ~0x00000080;
	*reg32 = val;
	
	// Enable interrupt 21 (USART interrupt) via Interrupt Set-enable Register
	reg32 = (volatile uint32_t*)0xe000e100;
	*reg32 = 0x00200000;

	// Enables the Receive Data Available 0 interrupt and Enables the Receive Line Status interrupt via USART Interrupt Enable Register when DLAB = 0
	reg32 = (volatile uint32_t*)0x40008004;
	val = *reg32;
	val |= 0x00000005;
	*reg32 = val;


        // Entry Num: 65242 - 65262
        // Step Num: 50306 - 50323
	// Firmware Offset(s): 
	//	0x00000d84 - 0x00000d94
	//	0x00000dae - 0x00000dbe

	// I think this function is for changing interrupt priority

	// Check if reg32 0 is greater than or equal to 0
	//	TODO: UNKNOWN PATHS continue to execute 0x00000d96, if not
	//	However, this is impossible as reg32 0 is set to 15 before this function is called

	// Set IP_USART0 to highest interrupt priority
	reg32 = (volatile uint32_t*)0xe000e414;
	val = *reg32;
	val &= ~0x0000ff00;
	val |= 0;
	*reg32 = val;


        // Entry Num: 65263 - 65289
        // Step Num: 50324 - 50347
	// Firmware Offset(s): 
	//	0x0000114e - 0x00001152
	//	0x00000d84 - 0x00000dac

	// Set Priority of system handler 14, PendSV to 0x40 (TODO: what does this translate to?)
	reg32 = (volatile uint32_t*)0xe000ed20;
	val = *reg32;
	val &= ~0x00ff0000;
	val |= 0x00400000;
	*reg32 = val;


        // Entry Num: 65290 - 65304
        // Step Num: 50348 - 50357
	// Firmware Offset(s): 

	//TODO: what are these instructions doing?
	//	0x00001156 - 0x00001156
	//	0x00000f30 - 0x00000f30
	//	0x000012bc - 0x000012be
	//	0x00000ce8 - 0x00000cf0
	//	0x00000cf4 - 0x00000cf4

	usbConnected = usbVoltPresent();


        // Entry Num: 65305 - 265309
        // Step Num: 50358 - 250361
	// Firmware Offset(s): 
	//	0x000012c2 - 0x000012d0

	for (int cnt = 0; cnt < 0x0000c350; cnt++){}


        // Entry Num: 265310 - 265334
        // Step Num: 250362 - 250376
	// Firmware Offset(s): 
	//	0x000012ac - 0x000012b2
	//	0x00001210 - 0x00001216
	//	0x000007b0 - 0x000007ba
	//	0x0000121a - 0x0000121a

	// For marking cps state of disabling interrupts (I think)
	*0x10000250 += 1;


        // Entry Num: 265335 - 265376
        // Step Num: 250377 - 250399
	// Firmware Offset(s): 
	//	0x0000129c - 0x000012a2
	//	0x000011f8 - 0x00001202
	//	0x00000648 - 0x00000660

	// Make sure THRE is disabled via USART Interrupt Enable Register when DLAB = 0
	reg32 = (volatile uint32_t*)0x40008004;
	val = *reg32;
	val &= ~0x00000002;
	*reg32 = val;


        // Entry Num: 265377 - 265394
        // Step Num: 250400 - 250407
	// Firmware Offset(s): 
	//	0x00000e50 - 0x00000e5e

	// Copy a RAM value
	*0x10001b88 = *0x100006cc


        // Entry Num: 265395 - 265403
        // Step Num: 250408 - 250413
	// Firmware Offset(s): 
	//	0x00000ee2 - 0x00000eec

	if (*0x100006d0 <= *0x100006d8 - *0x100006dc)
	{
		// TODO: UNKNOWN PATHS execute instruction at 0x00000eee
	}


        // Entry Num: 265404 - 265407
        // Step Num: 250414 - 250417
	// Firmware Offset(s): 
	//	0x00000ef2 - 0x00000ef4
	//	0x00000e62 - 0x00000e64

	// 	TODO: UNKNOWN PATHS execute instructiont 0x00000e64 if reg32 0 is not sure, but this never happens here as we before prev branch reg32 0 is set to 0


        // Entry Num: 265408 - 265442
        // Step Num: 250418 - 250445
	// Firmware Offset(s): 
	//	0x00000e6c - 0x00000ea2

	// TODO: try to understand what this is doing...
	Reg0 = *0x100006d8	
	Reg1 = *0x100006dc
	Reg1 = Reg0 - Reg1

	Reg0 = *0x100006d0	
	Reg2 = Reg0 - Reg1

	Reg1 = *0x100006d8

	Reg3 = Reg0 - 1

	Reg5 = Reg2

	if ((Reg3 - Reg0) => Does Not Produce Carry Out)
	{
		Reg5 = Reg0 - Reg1
	}

	Reg6 = Reg2 - Reg5

	if (Reg5 >= Reg6)
	{
		Reg5 = Reg7
	}

	Reg0 = Reg7 - Reg5

	if (Reg6 >= Reg0)
	{
		Reg6 = Reg0
	}

	Reg2 = *0x100006d4	
	Reg0 = *0x10001b88
	Reg1 = Reg2 * Reg1

	Reg2 = Reg5 * Reg2

	Reg1 = *0x10001b94


        // Entry Num: 265443 - 265446
        // Step Num: 250446 - 250449
	// Firmware Offset(s): 
	//	0x0000032c - 0x00000332

	Reg3 = Reg0
	Reg3 |= Reg1
	Reg3 <<= 30;	

	if (Reg3 != 0)
	{
		Branch to 0x0000034a (i.e. skip 0x0000033c - 0x00000340)
	}


        // Entry Num: 265447 - 265482
        // Step Num: 250450 - 250477
	// Firmware Offset(s): 
	//	0x0000033c - 0x00000340
	//	0x0000034a - 0x0000034c
	//	0x00000342 - 0x0000034e
	//	0x00000ea6 - 0x00000ec4

	//TODO: bunch more RAM math and paths to check here...
	*0x100005cc = 0x00000002
	*0x100006d8 = 0x00000001


        // Entry Num: 265483 - 265487
        // Step Num: 250478 - 250482
	// Firmware Offset(s): 
	//	0x0000032c - 0x00000334

	//TODO: see previous call, but take Reg3 != 0 path


        // Entry Num: 265488 - 265497
        // Step Num: 250483 - 250490
	// Firmware Offset(s): 
	//	0x0000034a - 0x0000034e
	//	0x00000ec8 - 0x00000ed0

	*0x100006d8 = 0x00000001


        // Entry Num: 265498 - 265524
        // Step Num: 250491 - 250506
	// Firmware Offset(s): 
	//	0x00000e68 - 0x0000066a
	//	0x00000688 - 0x0000068e
	//	0x00000696 - 0x000006a0

	// USART Line Status Register Read only
	reg32 = (volatile uint32_t*)0x40008014;
	val = *reg32;

	// Check USART related status receiver data ready, and other statuts bit
	// TODO: care about this?
	//	UNKNOWN PATHS branch to 0x000006a8 if condition met


        // Entry Num: 265525 - 266718
        // Step Num: 250507 - 251315
	// Firmware Offset(s): 
	//	0x00000ef6 - 0x00000efe
	//	...

	//TODO: think this area is mostly USART related, skipping over for now. Come back and disect this later
	//TODO: bumping priority as this is communicating with Nordic Semiconductor nRF51822 Bluetooth Smart and 2.4GHz proprietary SoC (which will tell us if we connect with USB dongle, right?)

	*0x100006dc = 0x00000001

	// USART Transmitter Holding Register
	*0x40008000 = 0x00000002

	// USART Line Status Register (Read-Only)
	reg32 = (volatile uint32_t*)0x40008014;
	val = *reg32;
	// TODO: UNKNOWN PATHS check status (i.e. that transmit occurred?)

	*0x100006d8 = 0x00000001
	*0x100006d8 = 0x00000001
	
	// Enable the THRE interrupt.
	reg32 = (volatile uint32_t*)0x40008004;
	val = *reg32;
	val |= 2;
	*reg32 = val;

	// Disable the THRE interrupt.
	reg32 = (volatile uint32_t*)0x40008004;
	val = *reg32;
	val |= ~0x00000002;
	*reg32 = val;

	// USART Line Status Register (Read-Only)
	reg32 = (volatile uint32_t*)0x40008014;
	val = *reg32;
	// TODO: UNKNOWN PATHS check status (i.e. that transmit occurred?)

	//TODO: are we looping here looking for USART to react?
	//	Maybe at least map out instruction calls to see if we are looping before giving up on USART?
	//	Pay attention to RAM addresses and see if one is counting up to a timeout or something...

	//TODO: check what USART is connected to on board!


        // Entry Num: 266719 - 266735
        // Step Num: 251316 - 251326
	// Firmware Offset(s): 
	//	0x00000dd4 - 0x00000dde
	//	0x00000572 - 0x00000576
	//	0x0000057e - 0x00000580

	// Set pin function to CT16B1_MAT0 via PIO0_21 register
	// PIO0_21 is connected to button LED
	//TODO: Use scope to get timing for on and off pattern and make sure it matches settings
	// *(uint32_t*)0x40044054 = 0x00000081
	set32bitReg(uint32_t baseReg = 0x40044000, uint8_t additionalOffset = 0, regWordOffset = 0x00000015, regVal = 0x00000008);


        // Entry Num: 266736 - 266757
        // Step Num: 251327 - 251342
	// Firmware Offset(s): 
	//	0x00000de2 - 0x00000de6
	//	0x000005f4 - 0x000005f6
	//	0x000005c4 - 0x000005c8
	//	0x000005ce - 0x000005d2
	//	0x000005d8 - 0x000005e0

	// Reg0 = 0x40010000 

	// If Reg0 == 0x40018000
	// UNKNOWN PATHS 0x000005ca -- See below where Reg0 is loaded with 0x40018000
	
	// If Reg0 == 0x4000c000
	// UNKNOWN PATHS 0x000005d4

	// If Reg0 != 0x40010000
	// UNKNOWN PATHS 0x000005e2


        // Entry Num: 266758 - 266796
        // Step Num: 251343 - 251367
	// Firmware Offset(s): 
	//	0x000005fa - 0x00000606
	//	0x00000dea - 0x00000e0c

	// Set prescale value to 0 via Prescale Register for CT16B1
	reg32 = (volatile uint32_t*)0x4001000c;
	*reg32 = 0x00000000;

	//TODO: Is this the pin connected to the Steam Button LED? Ohm it out!
	// PWM mode is enabled for CT16Bn_MAT0 via PWM Control Register for CT16B1
	reg32 = (volatile uint32_t*)0x40010074;
	val = *reg32;
	val |= 0x00000001;
	*reg32 = val;

	// Match Register 3 (MR3) is set to 0xfff via Match registers for CT16B1
	reg32 = (volatile uint32_t*)0x40010024;
	*reg32 = 0x00000fff;

	// Match Register 0 (MR0) is set to 0x1000 via Match registers for CT16B1
	reg32 = (volatile uint32_t*)0x40010018;
	*reg32 = 0x00001000;

	// Reset on MR3: the TC will be reset if MR3 matches it via Match Control Register for CT16B1
	reg32 = (volatile uint32_t*)0x40010014;
	val = *reg32;
	val |= 0x00000400;
	*reg32 = val;


        // Entry Num: 266797 - 357026
        // Step Num: 251368 - 319038
	// Firmware Offset(s): 
	//	0x0000060c - 0x00000622

	// Store the Timer Control Register for CT16B1
	reg32 = (volatile uint32_t*)0x40010004;
	val = *reg32;

	// Disable the counters via the Timer Control Register for CT16B1
	reg32 = (volatile uint32_t*)0x40010004;
	*reg32 = 0x00000000;

	// Set the timer counter value for via the Timer Counter register for CT16B1
	reg32 = (volatile uint32_t*)0x40010008;
	*reg32 = 0x00000001;

	// The Timer Counter and the Prescale Counter are synchronously reset on 
	//	the next positive edge of PCLK. The counters remain reset until 
	//	TCR[1] is returned to zero via the Timer Counter register for CT16B1
	reg32 = (volatile uint32_t*)0x40010004;
	*reg32 = 0x00000002;

	// Wait for the Timer Counter to read zero, meaning the affect of the 
	//	right to CRST in the previous register access succeeded
	do{
		reg32 = (volatile uint32_t*)0x40010008;
	} while (0 != *reg32);

	// Write back value previously read from Timer Control Register
	*0x40010004 = val; 

        // Entry Num: 357027 - 357036
        // Step Num: 319039 - 319042
	// Firmware Offset(s): 
	//	0x00000e10 - 0x00000e16

	// Reset timer counter and prescalar counter on next positive edge of PCLK for CT16B1
	//  The counters remain reset until TCR[1] is returned to zero
	reg32 = (volatile uint32_t*)0x40010004;
	val = *reg32;
	val |= 1;
	*reg32 = val;

        // Entry Num: 357037 - 357053
        // Step Num: 319043 - 319053
	// Firmware Offset(s): 
	//	0x00000f38 - 0x00000f3a
	//	0x00000e24 - 0x00000e32
	//	0x00000f3e - 0x00000f3e

	// Write some RAM address
	*0x1000025e = 0x000000ff

	// Set Match Register for CT16B1 MR0 to 0xFFFF
	*0x40010018 = 0x0000ffff

        // Entry Num: 357054 - 357086
        // Step Num: 319054 - 319071
	// Firmware Offset(s): 
	//	0x000009b4 - 0x000009ba
	//	0x000005f4 - 0x000005f6
	//	0x000005c4 - 0x000005cc
	//	0x000005fa - 0x00000606

	// reg32 0 = 0x40018000

	// Enables clock for 32-bit counter/timer 1. CT32B1
	reg32 = (volatile uint32_t*)0x40048080;
	val = *reg32;
	val |= 0x00000400;
	*reg32 = val;

        // Entry Num: 357087 - 357091
        // Step Num: 319072 - 319074
	// Firmware Offset(s): 
	//	0x000009be - 0x000009be

	// Some branches and pushes to stack

        // Entry Num: 357092 - 357109 
        // Step Num: 319074 - 319088
	// Firmware Offset(s): 
	//	0x00000494 - 0x00000496	
	//	0x00000450 - 0x0000046a

	checkMainClockSourceSel();


        // Entry Num: 357109 - 357127
        // Step Num: 319088 - 319100
	// Firmware Offset(s): 
	//	0x000004d0 - 0x000004d2
	//	0x000004a8 - 0x000004b4
	//	0x000004be - 0x000004c2

	checkSysPllClockSrcSel();

        // Entry Num: 357128 - 357806
        // Step Num: 319101 - 319757
	// Firmware Offset(s): 
	//TODO: this is similar to above
	//	0x000004d6 - 0x000004dc
	//	0x00000488 - 0x00000492
	//	0x000004e0 - 0x000004e0
	//	0x0000046e - 0x0000046e
	//	0x0000049a - 0x0000049e
	//	0x00000300 - 0x0000030c
	//	0x00000322 - 0x00000328
	//	0x0000030e - 0x0000032a
	//	0x000004a2 - 0x000004a2
	//TODO: this is different than above
 	//	0x000009c2 - 0x000009c6

	// System PLL control register
	// reg32 = (volatile uint32_t*)0x40048008;
	// val = *reg32;
	// Perform calculations based on value of system PLL control register

        // Entry Num: 357807 - 357850
        // Step Num: 319758 - 319786
	//	0x000009ca - 0x00000a02

	// Set Prescale Register for CT32B1 with value calulcated based on system PLL control register
	reg32 = (volatile uint32_t*)0x4001800c;
	*reg32 = 0x0000bb7f;

	// Read Match Control Register for CT32B1
	reg32 = (volatile uint32_t*)0x40018014;
	val = *reg32;
	// Enable Reset on MR0: the TC will be reset if MR0 matches it.
	val |= 2;
	*reg32 = val;

	// Read Match Control Register for CT32B1
	reg32 = (volatile uint32_t*)0x40018014;
	val = *reg32;
	// Enable Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.
	val |= 1;
	*reg32 = val;

	// Set MR0 (Time counter match value) for CT32B1
	reg32 = (volatile uint32_t*)0x40018018;
	*reg32 = 0x0000000b;

	// Clear interrupt pending on for CT32B1
	reg32 = (volatile uint32_t*)0xe000e280;
	*reg32 = 0x00080000;

	// Enable interrupt for CT32B1
	reg32 = (volatile uint32_t*)0xe000e100;
	*reg32 = 0x00080000;
		
	// Write some values to heap space
	*0x100007e0 = 0x01
	*0x100007e1 = 0x00
	*0x100007e2 = 0x04
	*0x100007e3 = 0x0c

        // Entry Num: 357851 - 357878
        // Step Num: 319787 - 319810
	//	0x000003a2 - 0x000003b2

	// Clear out some heap space
	*0x100007e4 = 0x00
	*0x100007e5 = 0x00
	*0x100007e6 = 0x00
	*0x100007e7 = 0x00

        // Entry Num: 357879 - 357892
        // Step Num: 319811 - 319820
	//	0x00000a06 - 0x00000a18

	// Clear out some heap space
	*0x100007e8 = 0x00
	*0x100007e9 = 0x00
	*0x100007ea = 0x00
	*0x100007eb = 0x00

        // Entry Num: 357893 - 357920
        // Step Num: 319821 - 319844
	//	0x000003a2 - 0x000003b2

	// Clear out more heap space (TODO: this is same code as above, but with different start address)
	*0x100007ec = 0x00
	*0x100007ed = 0x00
	*0x100007ee = 0x00
	*0x100007ee = 0x00

        // Entry Num: 357921 - 357936
        // Step Num: 319845 - 319850
	//	0x00000a1c - 0x00000a26

	// Set a heap value (related to CT32B1 enable maybe...)
	*0x1000025d = 0x01

	// Enable CT32B1 Timer Counter and Prescale Counter for counting
	reg32 = (volatile uint32_t*)0x40018004;
	val = *reg32;
	val |= 1;
	*reg32 = val;

	while (??){
		// Entry Num: 357937 - 357943
		// Step Num: 319851 - 319855
		//	0x00000f42 - 0x00000f48
		//	0x00000f4e - 0x00000f4e

		//TODO: who else would set heap address 0x10000200??
		uint8_t reg0 = *0x10000200;
		if (reg0 != 0){
			// TODO: UNKNOWN PATH execute instruction 0x00000f4a
		}

		// Entry Num: 357944 - 357956
		// Step Num: 319856 - 319863
		//	0x00000a3c - 0x00000a4a

		uint8_t Reg1 = *0x1000025d;

		if (Reg1 == 0){
			// TODO: UNKNOWN PATH skip ahead to 0x00000a6e
		}

		// Check if CT32B1 interrupt has fired
		uint8_t Reg1 = *0x1000025c;

		if (Reg1 != 0){
			//	0x00000a4c - 0x00000a54
			*0x1000025c = 0x00000000

			//	0x0000038e - 0x000003a0
			uint8_t Reg3 = *0x100007e7
			uint32_t val = Reg3;
			val <<= 8;
			uint8_t Reg3 = *0x100007e6
			val |= Reg3;
			val <<= 8;
			uint8_t Reg3 = *0x100007e5
			val |= Reg3;
			val <<= 8;
			uint8_t Reg3 = *0x100007e4
			val |= Reg3;

			Reg0 = val;

			// 	0x00000a58 - 0x00000a5c
			//	0x000003a2 - 0x000003b2
			//TODO: this needs to be generalized into a function call (both what is being set to addresses and and what the addresses are)
			// Filling 4 bytes ...
			*0x100007e4 = 0x00
			*0x100007e5 = 0x00
			*0x100007e6 = 0x00
			*0x100007e7 = 0x00
			
			//	0x00000a60 - 0x00000a60
			//	0x000012e4 - 0x000012e0
			uint8_t Reg0 = *0x10000244	

			//	0x00000a64 - 0x00000a66
			if (Reg0 != 0){
				// TODO: UNKNOWN PATH Execute instruction 0x00000a6a
			}
		}

		// Entry Num: 357957 - 357959
		// Step Num: 319864 - 319864
		//	0x00000a6e - 0x00000a6e
		
		// wait for interrupt

		//simulate more for what happens after wfi
		// What happens if interrupt occurs that is not CT32B1 --> Nothing really. Keeps waiting (but also checking other RAM locations...)
		// What happens if 0x1000025c is set to 1 by CT32B1 interrupt handler --> count stored in 0x100007e4 - 0x100007e7 is incremented


		// From this point on Entry Num and Step Num are not applicable due to
		//  the fact that TODO
		// 	0x00000f52 - 0x00000f54

		//TODO: need to organize this loop. Below is my understanding of what is going on:
		//	wfi is called
		//	if CT32B1 interrupt occurs this causes a heap space variable (0x100007e4 - 0x100007e7) to be incremented
		//	However, this variable can be incremented (seemingly) forever with no affect
		//	My thought is that clues lies in simulating other exceptions (i.e. USB IRQ, PendSV, SysTick, SVCall)
		//	FOCUS: Where are the following heap addresses modified? 0x10000200, 0x10000244, 0x1000025d
		//	ALSO: Keep an eye out for where 0x100007e4 - 0x100007e7 is read and may cause system to shutdown if it gets greater than some value or something
	}

	//TODO: Remember to pay attention to branches/paths simulation does and does not take.
	//TODO: Keep in mind that system will continue after WFI. Need to walk through this simulation and see about options (how does controller shutdown...?)
	//		I think what happens is that WFI is called for interrupt to run that sets particular registers. 
	//		Maybe 32 bit timer interrupting before other things happening causes variables to get set in a way such that power off occurs
	//		Otherwise controller might stay in this "idle" loop, or go into other "idle" loop, waiting for shutdown signal?
}

/**                                                                           
  *  HID get report callback function.                                          
  *                                                                             
  *  This function is provided by the application software. This function gets called 
  *  when host sends a HID_REQUEST_GET_REPORT request. The setup packet data (\em pSetup)
  *  is passed to the callback so that application can extract the report ID, report
  *  type and other information need to generate the report. \note HID reports are sent
  *  via interrupt IN endpoint also. This function is called only when report request
  *  is received on control endpoint. Application should implement \em HID_EpIn_Hdlr to
  *  send reports to host via interrupt IN endpoint.                            
  *                                                                             
  *                                                                             
  *  \param[in] hHid Handle to HID function driver.                             
  *  \param[in] pSetup Pointer to setup packet received from host.              
  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing report data. 
  *                       Pointer-to-pointer is used to implement zero-copy buffers. 
  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
  *  \param[in] length  Amount of data copied to destination buffer.            
  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
  *          \retval LPC_OK On success.                                         
  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
  *          \retval ERR_USBD_xxx  For other error conditions.                  
  *                                                                             
  * ENTRY POINT 0x00000961, as defined in USBD_HID_INIT_PARAM_T passed into USBD_HID_API_T->init().
  */                                                                            
ErrorCode_t HID_GetReport( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t* length)
{
        // Entry Num: 
        // Step Num: 
	// Firmware Offset(s): 
	//	0x00000961 - 

	//TODO: Simulate this?

}

  /**                                                                           
  *  HID set report callback function.                                          
  *                                                                             
  *  This function is provided by the application software. This function gets called 
  *  when host sends a HID_REQUEST_SET_REPORT request. The setup packet data (\em pSetup)
  *  is passed to the callback so that application can extract the report ID, report
  *  type and other information need to modify the report. An application might choose 
  *  to ignore input Set_Report requests as meaningless. Alternatively these reports 
  *  could be used to reset the origin of a control (that is, current position should 
  *  report zero).                                                              
  *                                                                             
  *  \param[in] hHid Handle to HID function driver.                             
  *  \param[in] pSetup Pointer to setup packet received from host.              
  *  \param[in, out] pBuffer  Pointer to a pointer of data buffer containing report data. 
  *                       Pointer-to-pointer is used to implement zero-copy buffers. 
  *                       See \ref USBD_ZeroCopy for more details on zero-copy concept.
  *  \param[in] length  Amount of data copied to destination buffer.            
  *  \return The call back should returns \ref ErrorCode_t type to indicate success or error condition.
  *          \retval LPC_OK On success.                                         
  *          \retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line. 
  *          \retval ERR_USBD_xxx  For other error conditions.                  
  *                                                                             
  * ENTRY POINT 0x0000098d, as defined in USBD_HID_INIT_PARAM_T passed into USBD_HID_API_T->init().
  */                                                                            
ErrorCode_t HID_SetReport( USBD_HANDLE_T hHid, USB_SETUP_PACKET* pSetup, uint8_t** pBuffer, uint16_t length)
{
        // Entry Num: 
        // Step Num: 
	// Firmware Offset(s): 
	//	0x0000098d - 

	//TODO: Simulate this?

}

/**
 * A NonMaskable Interrupt (NMI) can be signalled by a peripheral or triggered 
 *  by software. This is the highest priority exception other than reset. It is
 *  permanently enabled and has a fixed priority of  2. NMIs cannot be:
 *   masked or prevented from activation by any other exception
 *   preempted by any exception other than Reset.
 */
void NMI()
{
	// Entry point as defined by Vector Table
	// Firmware Offset(s): 
	// 	0x000000ec - 0x000000f0
	//	0x000020e2 - 0x000020e2

	// Enter infinite loop unconditionally branching to 0x000020e2
}

/**
 * A HardFault is an exception that occurs because of an error during normal or 
 *  exception processing. HardFaults have a fixed priority of -1, meaning they 
 *  have higher priority than any exception with configurable priority.
 */
void HardFault()
{
	// Entry point as defined by Vector Table
	// Firmware Offset(s): 
	// 	0x000000f4 - 0x000000f8
	//	0x00005c64 - 0x00005c64
	//	0x00009b68 - 0x00009b6e

	// Call cps to change processor state (and disable interrupts?)

	// Enter infinite loop unconditionally branch back to nop at 0x00009b6c
}

/**
 * A supervisor call (SVC) is an exception that is triggered by the SVC instruction. 
 *  In an OS environment, applications can use SVC instructions to access OS kernel functions and device drivers.
 */
void SVCall()
{
	// Entry point as defined by Vector Table
	// Firmware Offset(s): 
	// 	0x000000fc - 0x00000100
	//	0x000020da - 0x000020da

	// Enter infinite loop unconditionally branching to 0x000020da
}

/**
 * PendSV is an interrupt-driven request for system-level service. In an OS 
 *  environment, use PendSV for context switching when no other exception is active.
 */
void PendSV()
{
	volatile uint32_t* reg32 = NULL;
	uint32_t val = 0;

	// Entry point as defined by Vector Table
	// Firmware Offset(s): 
	// 	0x00000104 - 0x0000010a

	// Check value of GPREG1 
	reg32 = (volatile uint32_t*)0x40038008; 
	val = *reg32;

	if (0 != val){
		//TODO: UNKNOWN PATHS branch to 0x00000110
	}

	// Firmware Offset(s): 
	// 	0x0000010c - 0x0000010e
	//	0x00001464 - 0x00001474
	// 	0x000012e8 - 0x000012ee

	// PENDSVCLR
	*0xe000ed04 = 0x08000000;

	reg32 = (volatile uint32_t*)0x100006e0;
	val = *reg32
	if (val == 0x50){
		//TODO: UNKNOWN PATHS branch to 0x00001312
	}

	// Firmware Offset(s): 
	//	0x000012f0 - 0x000012f4

	if (val == 0x52){
		//TODO: UNKNOWN PATHS branch to 0x00001308
	}

	// Firmware Offset(s): 
	//	0x000012f6 - 0x000012f8

	if (val == 0x53){
		//TODO: UNKNOWN PATHS branch to 0x0000130c
	}

	// Firmware Offset(s): 
	//	0x000012fa - 0x000012fc

	if (val != 0){
		//TODO: UNKNOWN PATHS execute instruction at 0x000012fe
	}

	// Firmware Offset(s): 
	//	0x00001478 - 0x0000147c

	*(uint8_t*)0x10000249 = 0x00;
}

/**
 * A SysTick exception is an exception the system timer generates when it reaches 
 *  zero. Software can also generate a SysTick exception. In an OS environment, 
 *  the processor can use this exception as system tick.
 */
void SysTick()
{
	volatile uint32_t* reg32 = NULL;
	uint32_t val = 0;

	// Entry point as defined by Vector Table
	// Firmware Offset(s): 
	// 	0x00000118 - 0x0000011c
	//	0x00009ad0 - 0x00009ade
	val = *((uint32_t*)0x1000032c);

	if (val != 0){
		// TODO UNKNOWN PATH execute instruction at 0x00009ae0
	}

	// Firmware Offset(s): 
	// 	0x00009af6 - 0x00009b04
	*0x10000330 = *0x10000330 + *0x10000328;

	*0x10000334 = *0x10000334 - *0x10000330;

	if (*0x10000334 > 1000) {
		// TODO UNKNOWN PATH execute instruction at 0x00009b06
	}

	// Firmware Offset(s): 
	// 	0x00009b0e - 0x00009b1a
	*(uint16_t)0x10000324 = 0x0000;

	if (*(uint16_t)0x10000326 != 0){
		// TODO UNKNOWN PATH branch to instruction at 0x00009b22
	}

	// Firmware Offset(s): 
	// 	0x00009b1c - 0x00009b1e
	Reg0 = *0x1000033c;
	// Set PC to Reg0

	// TODO: seg fault here (PC = 0) because we simualted this without proper setup?
}

/**
 * PIN_INT1 (Setup for state change on PIO0_2):
 * Vector Table entry is 0x00000129.
 *
 * Seems to be related to Brown Out Detection.
 */
void Interrupt_1_PIN_INT1() {
	// MemRead 128 kB on-chip flash (address encoded in instruction)
	reg0 = *(uint32_t*)0x00000274; // = 0x00002044

	// MemRead 128 kB on-chip flash (address was computed as reg0 + 0x00000000)
	reg0 = *(uint32_t*)0x00002044; // = 0x000053ef

	// At 0x0000012c branching to 0x000053ef (reg0)
	// void fnc()
	{
		// Save reg4 to Stack at 0x10001fb0 (Value saved is 0x10000010)
		// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x00004039)
		// Stack Pointer updated to 0x10001fb0

		// Branch from 0x000053f2 to 0x00005c00 (Set LR to 0x000053f7)

		// MemWrite GPIO interrupts: IST (address was computed as 0x4004c000 + 0x00000024)
		// Clear interrupt
		*(uint32_t*)0x4004c024 = 0x00000002 (modified bits = 0x00000000)

		// Compute 0x00007355 - 0x00000000 for compare
		if (*(uint32_t*)0x100010b8 - 0x00000000) is Equal, Z == 1
		{
			// UNKOWN PATH execute 0x00005c14
		}

		// At 0x00005c12 branching to 0x00007355 (*(uint32_t*)0x100010b8)

		// MemWrite 8 kB SRAM0 (address was computed as 0x100002ac + 0x00000006)
		*(uint8_t*)0x100002b2 = 0x01 (modified bits = 0x00)

		// Compute 0x000065a9 - 0x00000000 for compare
		if (*(uint32_t*)0x100002bc - 0x00000000) is Equal, Z == 1
		{
			// UNKOWN PATH execute 0x00007362
		}

		// At 0x00007360 branching to 0x000065a9 (*(uint32_t*)0x100002bc)
		// void fnc()	
		{
			// Save reg4 to Stack at 0x10001fa8 (Value saved is 0x10000010)
			// Save reg14 to Stack at 0x10001fac (Value saved is 0x000053f7)
			// Stack Pointer updated to 0x10001fa8

			// Branch from 0x000065ac to 0x00006f60 (Set LR to 0x000065b1)
			// void fnc(arg1 = 0)	
			{
				// Save reg4 to Stack at 0x10001f98 (Value saved is 0x10000010)
				// Save reg5 to Stack at 0x10001f9c (Value saved is 0x00000001)
				// Save reg6 to Stack at 0x10001fa0 (Value saved is 0x00010074)
				// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000065b1)
				// Stack Pointer updated to 0x10001f98

				// Branch from 0x00006f64 to 0x00009b4c (Set LR to 0x00006f69)

				// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				*(uint8_t*)0x10000340 = *(uint8_t*)0x10000340 + 0x00000001; // = 0x01 (modified bits = 0x01)

				// At 0x00009b56 branching to 0x00006f69 (reg14)

				// MemRead 8 kB SRAM0 (address was computed as 0x10000200 + 0x00000002)
				// Compute 0x00000000 - 0x00000000 for compare
				if (arg0 - *(uint8_t*)0x10000202) is NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x00006f70
				}

				// Branch from 0x00006f80 to 0x00009b70 (Set LR to 0x00006f85)

				// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				*(uint8_t*)0x10000340 = ((uint32_t)((uint32_t)(*(uint8_t*)0x10000340 - 0x00000001) << 24) >> 24); // = 0x00 (modified bits = 0x01)

				Not equal, Z == 0
				{
					// UNKOWN PATH execute 0x00009b80
				}

				// At 0x00009b80 branching to 0x00006f85 (reg14)

			}
			// Restore reg4 from Stack at 0x10001f98 (Value saved was 0x10000010)
			// Restore reg5 from Stack at 0x10001f9c (Value saved was 0x00000001)
			// Restore reg6 from Stack at 0x10001fa0 (Value saved was 0x00010074)
			// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000065b1)
			// Stack Pointer updated to 0x10001fa8

			// Branch from 0x000065b0 to 0x0000521c (Set LR to 0x000065b5)
			// void fnc()	
			{
				// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x10000010)
				// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000065b5)
				// Stack Pointer updated to 0x10001fa0

				// Branch from 0x00005220 to 0x0000452c (Set LR to 0x00005225)

				// Ensure ADC is powered
				// MemRead system control: PDRUNCFG (address was computed as 0x40048200 + 0x00000038)
				// 0x0000e840 = 0x00000040 | 0x0000e800;
				// MemWrite system control: PDRUNCFG (address was computed as 0x40048200 + 0x00000038)
				*(uint32_t*)0x40048238 = ((*(uint32_t*)0x40048238 & 0x000005ff) & ~0x00000008) | 0x0000e800;; // = 0x0000e840 (modified bits = 0x00000000)

				// At 0x00004540 branching to 0x00005225 (reg14)

				// Disable BOD reset 
				// MemWrite system control: BODCTRL (address was computed as 0x40048140 + 0x00000010)
				*(uint32_t*)0x40048150 = 0x00000006 (modified bits = 0x00000010)

				// Clear BOD reset detected 
				// MemWrite system control: SYSRSTSTAT (address was computed as 0x40048000 + 0x00000030)
				*(uint32_t*)0x40048030 = 0x00000008 (modified bits = 0x00000000)

				// Enable BOD reset
				// MemRead system control: BODCTRL (address was computed as 0x40048140 + 0x00000010)
				// 0x00000016 = 0x00000006 | 0x00000010;
				// MemWrite system control: BODCTRL (address was computed as 0x40048140 + 0x00000010)
				*(uint32_t*)0x40048150 = *(uint32_t*)0x40048150 | 0x00000010; // = 0x00000016 (modified bits = 0x00000010)

			}
			// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x10000010)
			// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000065b5)
			// Stack Pointer updated to 0x10001fa8

			// Branch from 0x000065b4 to 0x000076ac (Set LR to 0x000065b9)
			// void fnc()
			{
				// Save reg4 to Stack at 0x10001fa0 (Value saved is 0x10000010)
				// Save reg14 to Stack at 0x10001fa4 (Value saved is 0x000065b9)
				// Stack Pointer updated to 0x10001fa0

				// Branch from 0x000076ae to 0x00009b4c (Set LR to 0x000076b3)

				// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				// 0x00000001 = 0x00000000 + 0x00000001
				// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				*(uint8_t*)0x10000340 = *(uint8_t*)0x10000340 + 0x00000001; // = 0x01 (modified bits = 0x01)

				// At 0x00009b56 branching to 0x000076b3 (reg14)

				// MemWrite 8 kB SRAM0 (address was computed as 0x100010d4 + 0x00000004)
				*(uint32_t*)0x100010d8 = 0x00000000 (modified bits = 0x00000000)

				// Branch from 0x000076b8 to 0x00009b70 (Set LR to 0x000076bd)

				// MemRead 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				// MemWrite 8 kB SRAM0 (address was computed as 0x10000340 + 0x00000000)
				*(uint8_t*)0x10000340 = (uint32_t)((uint32_t)(*(uint8_t*)0x10000340 - 0x00000001) << 24) >> 24; // = 0x00 (modified bits = 0x01)

				Not equal, Z == 0
				{
					// UNKOWN PATH execute 0x00009b80
				}

				// At 0x00009b80 branching to 0x000076bd (reg14)

			}
			// Restore reg4 from Stack at 0x10001fa0 (Value saved was 0x10000010)
			// Restore PC from Stack at 0x10001fa4 (Value saved was 0x000065b9)
			// Stack Pointer updated to 0x10001fa8

			// Branch from 0x000065ba to 0x0000b874 (Set LR to 0x000065bf)

			// MemRead 8 kB SRAM0 (address was computed as 0x10000370 + 0x0000000c)
			// Compute 0x00000000 - 0x00000000 for compare
			if (*(uint32_t*)0x1000037c - 0x00000000) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x0000b87c
			}

			// MemWrite 8 kB SRAM0 (address was computed as 0x10000370 + 0x00000003)
			*(uint8_t*)0x10000373 = 0x01 (modified bits = 0x01)

			// At 0x0000b886 branching to 0x000065bf (reg14)

		}
		// Restore reg4 from Stack at 0x10001fa8 (Value saved was 0x10000010)
		// Restore PC from Stack at 0x10001fac (Value saved was 0x000053f7)
		// Stack Pointer updated to 0x10001fb0

	}
	// Restore reg4 from Stack at 0x10001fb0 (Value saved was 0x10000010)
	// Restore PC from Stack at 0x10001fb4 (Value saved was 0x00004039)
	// Stack Pointer updated to 0x10001fb8

	// PC is set to reg14 (LR) which was previously saved to stack. This is exit of IRQ.
}

/**
 * I2C Interrupt occurrs when I2C controller state changes.
 *
 * Vector Table entry is 0x00000199.
 */
void Interrupt_15_I2C_Interrupt() {
	// NOTE: Leaving this here for reference, but we really don't need it as
	//  we know I2C communications are occurring using lpc_chip_11uxx_lib and
	//  we can abstract away I2C transfers without diving into what exactly
	//  the ISR is doing.

	// MemRead 128 kB on-chip flash (address was computed as 0x0000207c + 0x00000000)
	// At 0x0000019c branching to 0x00005c81 (*(uint32_t*)0x0000207c)

	{
		// Save reg4 to Stack at 0x10001f88 (Value saved is 0x100000a8)
		// Save reg14 to Stack at 0x10001f8c (Value saved is 0x0000425c)
		// Stack Pointer updated to 0x10001f88

		reg0 = 0x00000000; // (fields.imm)

		// Branch from 0x00005c84 to 0x000042c8 (Set LR to 0x00005c89)
		void fnc(arg0 = 0)
		{
			// Save reg4 to Stack at 0x10001f78 (Value saved is 0x100000a8)
			// Save reg5 to Stack at 0x10001f7c (Value saved is 0x10000d80)
			// Save reg6 to Stack at 0x10001f80 (Value saved is 0x00000000)
			// Save reg14 to Stack at 0x10001f84 (Value saved is 0x00005c89)
			// Stack Pointer updated to 0x10001f78

			reg6 = arg0; // = 0x00000000

			// Branch from 0x000042da to 0x0000d5c8 (Set LR to 0x000042df)
			// int fnc(ctrlRegBaseAddr = *(uint32_t*)0x100000a8; // = 0x40000000, i2cConfig = *(uint32_t*)0x100000b8; // = 0x10000d80)
			{
				// Save reg4 to Stack at 0x10001f6c (Value saved is 0x00000000)
				// Save reg5 to Stack at 0x10001f70 (Value saved is 0x100000a8)
				// Save reg14 to Stack at 0x10001f74 (Value saved is 0x000042df)
				// Stack Pointer updated to 0x10001f6c

				reg2 = 0x0000003c; // (fields.imm)

				// MemRead I2C: STAT (address was computed as ctrlRegBaseAddr + 0x00000004)
				// 0x000000f8 = 0x000000f8 & 0x000000f8
				// 0x00000000 = 0x000000f8 << 29 (Carry Out = 0x00000008)
				// 0x00000000 = 0x00000000 >> 29 (Carry Out = 0x00000000)
				reg4 = (uint32_t)((uint32_t)(*(uint32_t*)0x40000004 & 0x000000f8) << 29) >> 29;

				Not equal, Z == 0
				{
					// UNKOWN PATH execute 0x0000d65a
				}


				// Branch from 0x0000d5dc to 0x0000c114 (Set LR to 0x0000d5e1)

				{
					// Save reg4 to Stack at 0x10001f64 (Value saved is 0x0000001f)
					// Save reg5 to Stack at 0x10001f68 (Value saved is 0x100000a8)
					// Stack Pointer updated to 0x10001f64

					reg4 = reg14; // = 0x0000d5e1

					// 0x0000d5e0 = 0x0000d5e1 - 0x00000001
					reg4 = reg4 - 0x00000001;

					// MemRead 128 kB on-chip flash (address was computed as reg4 + 0x00000000)
					reg5 = *(uint8_t*)0x0000d5e0; // = 0x0000000c

					// 0x0000d5e1 = 0x0000d5e0 + 0x00000001
					reg4 = reg4 + 0x00000001;

					// MemRead I2C: STAT (address was computed as ctrlRegBaseAddr + 0x00000004)
					// 0x0000001f = 0x000000f8 >> 3 (Carry Out = 0x00000000)
					// 0x0000001f = 0x0000001f << 0 (Carry Out = 0x00000000)
					// Compute 0x0000001f - 0x0000000c for compare
					if (((uint32_t)((uint32_t)(*(uint32_t*)0x40000004 & 0x000000f8) >> 3) << 0) - reg5) is NOT Carry set, C == 1
					{
						// UNKOWN PATH execute 0x0000c122
					}

					// MemRead 128 kB on-chip flash (address was computed as reg4 + reg5)
					reg3 = *(uint8_t*)0x0000d5ed; // = 0x0000003d

					// 0x0000007a = 0x0000003d << 1 (Carry Out = 0x00000000)
					reg3 = (uint32_t)reg3 << 1;

					// 0x0000d65b = 0x0000d5e1 + 0x0000007a
					reg3 = reg4 + reg3;

				}
				// Restore reg4 from Stack at 0x10001f64 (Value saved was 0x0000001f)
				// Restore reg5 from Stack at 0x10001f68 (Value saved was 0x100000a8)
				// Stack Pointer updated to 0x10001f6c

				// At 0x0000c12c branching to 0x0000d65b (reg3)

				// MemWrite I2C: CONSET (address was computed as ctrlRegBaseAddr + 0x00000000)
				*(uint32_t*)0x40000000 = 0x0000003c ^ 0x0000003c; // = 0x00000000 (modified bits = 0x00000060)

				// MemWrite I2C: CONCLR (address was computed as ctrlRegBaseAddr + 0x00000018)
				*(uint32_t*)0x40000018 = 0x0000003c; // = 0x0000003c (modified bits = 0x00000000)

				// MemRead 8 kB SRAM0 (address was computed as i2cConfig + 0x00000014)
				reg0 = *(uint8_t*)0x10000d94; // = 0x00000004

				Plus, positive or zero, N == 0
				{
					// UNKOWN PATH execute 0x0000d670
				}

				// MemRead 8 kB SRAM0 (address was computed as i2cConfig + 0x00000014)
				// Compute 0x00000004 - 0x00000002 for compare
				if (*(uint8_t*)0x10000d94 - 0x00000002) is Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000d678
				}

				reg0 = 0x00000001; // (fields.imm)

			}
			// Restore reg4 from Stack at 0x10001f6c (Value saved was 0x00000000)
			// Restore reg5 from Stack at 0x10001f70 (Value saved was 0x100000a8)
			// Restore PC from Stack at 0x10001f74 (Value saved was 0x000042df)
			// Stack Pointer updated to 0x10001f78

			// Compute 0x00000001 - 0x00000000 for compare
			if (reg0 - 0x00000000) is NOT Not equal, Z == 0
			{
				// UNKOWN PATH execute 0x000042e2
			}

		}
		// Restore reg4 from Stack at 0x10001f78 (Value saved was 0x100000a8)
		// Restore reg5 from Stack at 0x10001f7c (Value saved was 0x10000d80)
		// Restore reg6 from Stack at 0x10001f80 (Value saved was 0x00000000)
		// Restore PC from Stack at 0x10001f84 (Value saved was 0x00005c89)
		// Stack Pointer updated to 0x10001f88

	}
	// Restore reg4 from Stack at 0x10001f88 (Value saved was 0x100000a8)
	// Restore PC from Stack at 0x10001f8c (Value saved was 0x0000425c)
	// Stack Pointer updated to 0x10001f90
}

/**
 * CT16B0: An interrupt is generated when MR0 matches the value in the TC.
 * Vector Table entry is 0x000001a1.
 */
void Interrupt_16_CT16B0() {
	// MemRead 128 kB on-chip flash (address encoded in instruction)
	reg0 = *(uint32_t*)0x000002b0; // = 0x00002080

	// MemRead 128 kB on-chip flash (address was computed as reg0 + 0x00000000)
	reg0 = *(uint32_t*)0x00002080; // = 0x00009d0d

	// At 0x000001a4 branching to 0x00009d0d (reg0)

	{
		// Save reg4 to Stack at 0x10001f90 (Value saved is 0x10000000)
		// Save reg14 to Stack at 0x10001f94 (Value saved is 0x000051aa)
		// Stack Pointer updated to 0x10001f90

		// MemRead 128 kB on-chip flash (address encoded in instruction)
		reg0 = 0x4000c000

		// Branch from 0x00009d10 to 0x00006130 (Set LR to 0x00009d15)
		// void fnc(arg0 = ctrl reg base address)
		{
			// Save reg4 to Stack at 0x10001f80 (Value saved is 0x10000000)
			// Save reg5 to Stack at 0x10001f84 (Value saved is 0x4000c000)
			// Save reg6 to Stack at 0x10001f88 (Value saved is 0x00000001)
			// Save reg14 to Stack at 0x10001f8c (Value saved is 0x00009d15)
			// Stack Pointer updated to 0x10001f80

			// Branching from PC = 0x00006136 to PC = 0x0000618c

			// Check for interrupt generated by match for channels 0-3
			// MemRead CT16B0: IR (address was computed as reg4 + 0x00000000)
			// 0x10000000 = 0x00000001 << 28 (Carry Out = 0x00000000)
			// 0x00000001 = 0x10000000 >> 28 (Carry Out = 0x00000000)
			while (((uint32_t)((uint32_t)*(uint32_t*)0x4000c000 << 28) >> 28) != 0) {

				// MemRead CT16B0: IR (address was computed as reg4 + 0x00000000)
				// 0x10000000 = 0x00000001 << 28 (Carry Out = 0x00000000)
				// 0x00000001 = 0x10000000 >> 28 (Carry Out = 0x00000000)
				// 0x00000000 = 0x00000001 >> 16 (Carry Out = 0x00000000)
				reg0 = (uint32_t)((uint32_t)((uint32_t)*(uint32_t*)0x4000c000 << 28) >> 28) >> 16;

				NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000613e
				}

				// MemRead CT16B0: IR (address was computed as reg4 + 0x00000000)
				// 0x10000000 = 0x00000001 << 28 (Carry Out = 0x00000000)
				// 0x00000001 = 0x10000000 >> 28 (Carry Out = 0x00000000)
				// 0x00000000 = 0x00000001 >> 8 (Carry Out = 0x00000000)
				reg0 = (uint32_t)(uint32_t)((uint32_t)*(uint32_t*)0x4000c000 << 28) >> 28) >> 8;

				NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x00006146
				}

				// MemRead CT16B0: IR (address was computed as reg4 + 0x00000000)
				// 0x10000000 = 0x00000001 << 28 (Carry Out = 0x00000000)
				// 0x00000001 = 0x10000000 >> 28 (Carry Out = 0x00000000)
				// 0x00000000 = 0x00000001 >> 4 (Carry Out = 0x00000000)
				reg0 = (uint32_t)((uint32_t)((uint32_t)*(uint32_t*)0x4000c000 << 28) >> 28) >> 4;

				NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000614e
				}

				// MemRead CT16B0: IR (address was computed as reg4 + 0x00000000)
				// 0x10000000 = 0x00000001 << 28 (Carry Out = 0x00000000)
				// 0x00000001 = 0x10000000 >> 28 (Carry Out = 0x00000000)
				// 0x00000000 = 0x00000001 >> 2 (Carry Out = 0x00000000)
				reg0 = (uint32_t)((uint32_t)((uint32_t)*(uint32_t*)0x4000c000 << 28) >> 28) >> 2;

				NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x00006156
				}

				// MemRead CT16B0: IR (address was computed as reg4 + 0x00000000)
				// 0x10000000 = 0x00000001 << 28 (Carry Out = 0x00000000)
				// 0x00000001 = 0x10000000 >> 28 (Carry Out = 0x00000000)
				// 0x00000000 = 0x00000001 >> 1 (Carry Out = 0x00000001)
				reg0 = (uint32_t)((uint32_t)((uint32_t)*(uint32_t*)0x4000c000 << 28) >> 28) >> 1;

				NOT Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000615e
				}

				// MemRead CT16B0: IR (address was computed as reg4 + 0x00000000)
				// 0x10000000 = 0x00000001 << 28 (Carry Out = 0x00000000)
				// 0x00000001 = 0x10000000 >> 28 (Carry Out = 0x00000000)
				// 0x0000001f = 0x00000020 - 0x00000001
				// 0x00000000 = 0x0000001f - 0x0000001f
				reg0 = 0x0000001f - (0x00000020 - ((uint32_t)((uint32_t)*(uint32_t*)0x4000c000 << 28) >> 28));

				// Clear Interrupt flag for match channel 0
				// MemWrite CT16B0: IR (address was computed as arg0 + 0x00000000)
				*(uint32_t*)0x4000c000 = 0x00000001; // = 0x00000001 (modified bits = 0x00000000)

				// Branch from 0x00006172 to 0x000056fc (Set LR to 0x00006177)

				// Compute 0x4000c000 - 0x4000c000 for compare
				if (arg0 - 0x4000c000) is Not equal, Z == 0
				{
					// UNKOWN PATH execute 0x00005706
				}

				// At 0x00005704 branching to 0x00006177 (reg14)

				// MemRead 8 kB SRAM0 (address was computed as 0x10000818 + 0x00000000)
				// Compute 0x00009621 - 0x00000000 for compare
				if (*(uint32_t*)0x10000818 - 0x00000000) is Equal, Z == 1
				{
					// UNKOWN PATH execute 0x0000618c
				}

				// MemRead 8 kB SRAM0 (address was computed as 0x100007e8 + 0x00000000)
				reg0 = *(uint32_t*)0x100007e8; // = 0x00000000

				// MemRead 8 kB SRAM0 (address was computed as 0x10000818 + 0x00000000)
				// At 0x0000618a branching to 0x00009621 (*(uint32_t*)0x10000818). LR set to 0x0000618c

				// MemWrite 8 kB SRAM0 (address was computed as 0x10000000 + 0x00000001)
				*(uint8_t*)0x10000001 = 0x01 (modified bits = 0x01)

				// Disable Counters
				// MemRead CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
				// 0x00000000 = 0x00000001 >> 1 (Carry Out = 0x00000001)
				// 0x00000000 = 0x00000000 << 1 (Carry Out = 0x00000000)
				// MemWrite CT16B0: TCR (address was computed as 0x4000c000 + 0x00000004)
				*(uint32_t*)0x4000c004 = (uint32_t)((uint32_t)*(uint32_t*)0x4000c004 >> 1) << 1; // = 0x00000000 (modified bits = 0x00000001)

				// At 0x00009630 branching to 0x0000618d (reg14)
			}
		}
		// Restore reg4 from Stack at 0x10001f80 (Value saved was 0x10000000)
		// Restore reg5 from Stack at 0x10001f84 (Value saved was 0x4000c000)
		// Restore reg6 from Stack at 0x10001f88 (Value saved was 0x00000001)
		// Restore PC from Stack at 0x10001f8c (Value saved was 0x00009d15)
		// Stack Pointer updated to 0x10001f90

	}
	// Restore reg4 from Stack at 0x10001f90 (Value saved was 0x10000000)
	// Restore PC from Stack at 0x10001f94 (Value saved was 0x000051aa)
	// Stack Pointer updated to 0x10001f98

	// PC is set to reg14 (LR) which was previously saved to stack. This is exit of IRQ.
}

/**
 * This is interrupt handler called when IRQ 19 triggers for 32-bit counter 1. 
 *  This was simulated multiple times to plot out several different paths. 
 */
void Interrupt_19_CT32B1()
{
	volatile uint32_t* reg32 = NULL;
	uint32_t val = 0;

	// Entry point as defined by Vector Table
	// Firmware Offset(s): 
	// 	0x000001b8 - 0x000001c2

	// GPREG1
	reg32 = (volatile uint32_t*)0x40038008;
	val = *reg32;

	// Must be some state changes later and GPREG1 indicates this somehow...
	if (val != 0)
	{
		// Firmware Offset(s): 
		//	0x000001c4 - 0x000001c8
		//	0x00009d3c - 0x00009d40	
		//	0x00006130 - 0x00006136

		do {
			// Firmware Offset(s): 
			//	0x0000618c - 0x00006192

			// Interrupt Register (IR, address 0x4001 8000 (CT32B1)) bit description
			reg32 = (volatile uint32_t*)0x40018000;
			val = *reg32;

			// Isolate MR0INT, MR1INT, MR2INT and MR3INT
			val &= 0xF;

			// Check if MR0INT and MR1INT and MR2INT and MR3INT are not set
			if (0 == val)
			{
				//TODO: UNKNOWN PATHS execute 0x00006194 if 
				// Firmware Offset(s): 
				//	0x00006194 - 0x00006194
				//	0x00009d44 - 0x00009d44
				return;
			}

			// Firmware Offset(s): 
			//	0x00006138 - 0x0000613c
			if (0xFFFF0000 & val)
			{
				//TODO: UNKNOWN PATHS execute 0x0000613e if 
			}

			// Firmware Offset(s): 
			//	0x00006142 - 0x00006144
			if (0xFFFFFF00 & val)
			{
				//TODO: UNKNOWN PATHS execute 0x00006146 if 
			}

			// Firmware Offset(s): 
			//	0x0000614a - 0x0000614c
			if (0xFFFFFFF0 & val)
			{
				//TODO: UNKNOWN PATHS execute 0x0000614e if 
			}

			// Firmware Offset(s): 
			//	0x00006152 - 0x00006154
			if (0xFFFFFFFC & val)
			{
				//TODO: UNKNOWN PATHS execute 0x00006156 if 
			}

			// Firmware Offset(s): 
			//	0x0000615a - 0x0000615c
			if (0xFFFFFFFE & val)
			{
				//TODO: UNKNOWN PATHS execute 0x0000615e if 
			}

			// Firmware Offset(s): 
			//	0x00006162 - 0x00006172

			// Reset MR0INT - Interrupt flag for match channel 0.
			reg32 = (volatile uint32_t*)0x40018000;
			*reg32 = 0x00000001;

			// Firmware Offset(s): 
			//	0x000056fc - 0x00005700
			if (reg0 == 0x4000c000)
			{
				//TODO: UNKNOWN PATHS execute 0x00005702 if 
			}
			
			// Firmware Offset(s): 
			//	0x00005706 - 0x0000570a
			if (reg0 == 0x40010000)
			{
				//TODO: UNKNOWN PATHS execute 0x0000570c if 
			}

			// Firmware Offset(s): 
			//	0x00005710 - 0x00005714
			if (reg0 == 0x40014000)
			{
				//TODO: UNKNOWN PATHS execute 0x00005718 if 
			}

			// Firmware Offset(s): 
			//	0x0000571a - 0x0000571c
			//	0x00006176 - 0x00006180
		} while (*0x10000848 == 0);
	}


	// Firmware Offset(s): 
	//	0x0000148c - 0x00001496

	// Reset MR0INT - Interrupt flag for match channel 0.
	reg32 = (volatile uint32_t*)0x40018000;
	*reg32 = 0x00000001;

	// Set RAM address to indicate interrupt occurred.
	//	I think this is used by init as means of counting down before
	//	 giving up on connection occurring.
	*(uint8_t*)0x1000025c = 0x01;
}

/**
 * TODO: Simulate this?
 */
void Interrupt_21_USART()
{

	// Entry point as defined by Vector Table
	// Firmware Offset(s): 
	// 	0x000001d4 - 

}

/**
 * This interrupt is called in relation to USB interrupts.
 */
void Interrupt_22_USB_IRQ()
{

	volatile uint32_t* reg32 = NULL;
	uint32_t val = 0;

	// Entry point as defined by Vector Table
	// Firmware Offset(s): 
	// 	0x000001e8 - 0x000001f2

	// Read GPREG1
	reg32 = (volatile uint32_t*)0x40038008;
	val = *reg32;

	if (val != 0){
		// TODO: UNKNOWN PATH execute instruction at 0x000001f4
	}

	// Firmware Offset(s): 
	// 	0x000014fc - 0x00001504
	
	// Read USB EP Command/Status List start address
	reg32 = (volatile uint32_t*)0x40080008; // 0x20004000
	Reg0 = *reg32;
	
	// Read USB Device Command/Status register
	reg32 = (volatile uint32_t*)0x40080000;
	Reg1 = *reg32;

	// Check if SETUP token has been received 
	if (Reg1 & 0x00000100){

		// Firmware Offset(s): 
		// 	0x00001506 - 0x00001514

		Reg1 = 1;
		Reg2 = *0x20004000; // 0x00400109

		// Clear Bit 29 (Stall Bit) for EP0 OUT
		Reg2 &= ~0x20000000;

		*0x20004000 = Reg2

		Reg2 = *0x20004008; // 0x00400109	

		// Clear Bit 29 (Stall Bit) for EP0 IN
		Reg2 &= ~0x20000000;

		*0x20004008 = Reg2
	}

	// Firmware Offset(s): 
	// 	0x00001516 - 0x00001520

	// Setup for calling some USB related function from Boot ROM

	// Read USBD_HW_API_T* saved earlier
	Reg1 = *0x10000230; // = 0x1fff1f24

	// USB_HANDLE_T USB device stack handle	pointer
	Reg0 = *0x1000022c; // = 0x200040b8

	Reg1 = *Reg1; // = 0x1fff1f80
	Reg1 = *Reg1; // = 0x1fff3655

	// Execute function at 0x1fff3655
	
	// Firmware Offset(s): 
	//	0x1fff3654 - 0x1fff367a

	/** \fn void ISR(USBD_HANDLE_T hUsb)                                          
	 *  Function to USB device controller interrupt events.                       
	 *                                                                            
	 *  When the user application is active the interrupt handlers are mapped in the user flash
	 *  space. The user application must provide an interrupt handler for the USB interrupt and
	 *  call this function in the interrupt handler routine. The driver interrupt handler takes
	 *  appropriate action according to the data received on the USB bus.         
	 *                                                                            
	 *  \param[in]  hUsb Handle to the USB device stack.                          
	 *  \return Nothing.                                                          
	 */                                                                           
	USBD_HW_API->ISR(USBD_HANDLE_T hUsb = 0x200040b8);
	//TODO: dig more into ISR function call? Could this be calling some other handler function potentially?
}

/**
 * ADC interrupt to occur at end of A/D Converter end of conversion.
 * Vector Table entry is 0x00000205.
 */
void Interrupt_24_ADC_Interrupt() {
	// MemRead 128 kB on-chip flash (address encoded in instruction)
	reg0 = *(uint32_t*)0x000002dc; // = 0x000020a0

	// MemRead 128 kB on-chip flash (address was computed as reg0 + 0x00000000)
	reg0 = *(uint32_t*)0x000020a0; // = 0x00002b21

	// At 0x00000208 branching to 0x00002b21 (reg0)
	// void fnc()
	{
		// Save reg3 to Stack at 0x10001fa0 (Value saved is 0x07000000)
		// Save reg4 to Stack at 0x10001fa4 (Value saved is 0x10000010)
		// Save reg5 to Stack at 0x10001fa8 (Value saved is 0x00000001)
		// Save reg6 to Stack at 0x10001fac (Value saved is 0x00010074)
		// Save reg7 to Stack at 0x10001fb0 (Value saved is 0x00000000)
		// Save reg14 to Stack at 0x10001fb4 (Value saved is 0x00002cfe)
		// Stack Pointer updated to 0x10001fa0

		// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000004)
		// Compute 0x00000000 - 0x0000012c for compare
		if (*(uint32_t*)0x10000014 - 0x0000012c) is Carry set, C == 1
		{
			// execute 0x00002b3a

			// MemRead 8 kB SRAM0 (address was computed as reg5 + 0x00000008)
			// MemWrite 8 kB SRAM0 (address was computed as reg5 + 0x00000008)
			*(uint32_t*)0x10000018 = *(uint32_t*)0x10000018 + 0x00000001; // = 0x00000001 (modified bits = 0x00000001)

			// Compute 0x00000001 - 0x00000008 for compare
			if (*(uint32_t*)0x10000018 - 0x00000008) is NOT Not equal, Z == 0
			{
				// execute 0x00002b46

				// Branch from 0x00002b4a to 0x0000402c (Set LR to 0x00002b4f)
				// void fnc(arg0 = 0x4001c000 (ADC control reg base), arg1 = 0)
				{
					// Save reg4 to Stack at 0x10001f94 (Value saved is 0x4001c000)
					// Save reg5 to Stack at 0x10001f98 (Value saved is 0x10000010)
					// Save reg14 to Stack at 0x10001f9c (Value saved is 0x00002b4f)
					// Stack Pointer updated to 0x10001f94

					// Branch from 0x00004034 to 0x0000e6e8 (Set LR to 0x00004039)

					// MemRead ADC: CR (address was computed as arg0 + 0x00000000)

					// Set START to No Start (used when clearing PDN to 0)
					// MemRead ADC: CR (address was computed as arg0 + 0x00000000)
					// MemWrite ADC: CR (address was computed as arg0 + 0x00000000)
					*(uint32_t*)0x4001c000 = *(uint32_t*)0x4001c000 & ~0x07000000; // = 0x00210a40 (modified bits = 0x00000000)

					// At 0x0000e6f6 branching to 0x00004039 (reg14)

					// Compute 0x00000000 - 0x00000000 for compare
					if (arg1 - 0x00000000) is NOT Equal, Z == 1
					{
						// UNKOWN PATH execute 0x00004042
					}

					// Branching from PC = 0x0000404a to PC = 0x00004044

					// Set burst mode to software-controlled (Conversions are software-controlled and require 11 clocks)
					// MemRead ADC: CR (address was computed as arg0 + 0x00000000)
					// MemWrite ADC: CR (address was computed as arg0 + 0x00000000)
					*(uint32_t*)0x4001c000 = *(uint32_t*)0x4001c000 & ~0x00010000; // = 0x00200a40 (modified bits = 0x00010000)

				}
				// Restore reg4 from Stack at 0x10001f94 (Value saved was 0x4001c000)
				// Restore reg5 from Stack at 0x10001f98 (Value saved was 0x10000010)
				// Restore PC from Stack at 0x10001f9c (Value saved was 0x00002b4f)
				// Stack Pointer updated to 0x10001fa0
			}

			// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
			// Compute 0x00000001 & 0x00000040 for compare
			if (0x00000001 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00002b60
			}

			// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
			// Compute 0x00000002 & 0x00000040 for compare
			if (0x00000002 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00002b60
			}

			// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
			// Compute 0x00000004 & 0x00000040 for compare
			if (0x00000004 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00002b60
			}

			// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
			// Compute 0x00000008 & 0x00000040 for compare
			if (0x00000008 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00002b60
			}

			// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
			// Compute 0x00000010 & 0x00000040 for compare
			if (0x00000010 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00002b60
			}

			// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
			// Compute 0x00000020 & 0x00000040 for compare
			if (0x00000020 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00002b60
			}

			// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
			// Compute 0x00000040 & 0x00000040 for compare
			if (0x00000040 & *(uint8_t*)0x10000012) is Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00002b72
			}

			// MemRead 8 kB SRAM0 (address was computed as 0x10000f80 + 0x0000000c)
			// MemRead ADC: DR6 (address was computed as 0x4001c018 + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as 0x10000f80 + 0x0000000c)
			*(uint16_t*)0x10000f8c = *(uint16_t*)0x10000f8c + ((uint32_t)((uint32_t)(*(uint32_t*)0x4001c028) << 16) >> 22); // = 0x0000 (modified bits = 0x0000)

			// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000002)
			// Compute 0x00000080 & 0x00000040 for compare
			if (0x00000080 & *(uint8_t*)0x10000012) is NOT Equal, Z == 1
			{
				// UNKOWN PATH execute 0x00002b60
			}

			// Compute 0x00000001 - 0x00000008 for compare
			if (*(uint32_t*)0x10000018 - 0x00000008) is NOT Not equal, Z == 0
			{
				// execute 0x00002b80

				// MemWrite 8 kB SRAM0 (address was computed as reg0 + 0x00000000)
				*(uint8_t*)0x10000010 = 0x01 (modified bits = 0x01)

				// MemRead 8 kB SRAM0 (address was computed as reg0 + 0x00000001)
				// Compute 0x00000001 - 0x00000000 for compare
				if (*(uint8_t*)0x10000011 - 0x00000000) is NOT Not equal, Z == 0
				{
					// UNKOWN PATH execute 0x00002b88
				}

				// Branch from 0x00002b8e to 0x000040b8 (Set LR to 0x00002b93)

				// Disable ADC clocks
				// MemRead system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
				// MemWrite system control: SYSAHBCLKCTRL (address was computed as 0x40048080 + 0x00000000)
				*(uint32_t*)0x40048080 = *(uint32_t*)0x40048080 & ~0x00002000; // = 0x0c09417f (modified bits = 0x00002000)

				// At 0x000040c4 branching to 0x00002b93 (reg14)

				return;
			}

			return;
		}

		// Branch from 0x00002b2e to 0x00004cbc (Set LR to 0x00002b33)

		/**
		* Read all ADC Data Registers to clear DONE bits.
		*/
		// void clrAllAdcDataRegs()
		{
			// Save reg3 to Stack at 0x10001f98 (Value saved is 0x07000000)
			// Save reg14 to Stack at 0x10001f9c (Value saved is 0x00002b33)
			// Stack Pointer updated to 0x10001f98

			// MemRead ADC: DR0 (address was computed as 0x4001c000 + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
			*(uint16_t*)SP = *(uint32_t*)0x4001c010; // = 0x0000 (modified bits = 0x2000)

			// MemRead ADC: DR1 (address was computed as 0x4001c004 + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
			*(uint16_t*)SP = *(uint32_t*)0x4001c014; // = 0x0000 (modified bits = 0x0000)

			// MemRead ADC: DR2 (address was computed as 0x4001c008 + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
			*(uint16_t*)SP = *(uint32_t*)0x4001c018; // = 0x0000 (modified bits = 0x0000)

			// MemRead ADC: DR3 (address was computed as 0x4001c00c + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
			*(uint16_t*)SP = *(uint32_t*)0x4001c01c; // = 0x0000 (modified bits = 0x0000)

			// MemRead ADC: DR4 (address was computed as 0x4001c010 + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
			*(uint16_t*)SP = *(uint32_t*)0x4001c020; // = 0x0000 (modified bits = 0x0000)

			// MemRead ADC: DR5 (address was computed as 0x4001c014 + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
			*(uint16_t*)SP = *(uint32_t*)0x4001c024; // = 0x0000 (modified bits = 0x0000)

			// MemRead ADC: DR6 (address was computed as 0x4001c018 + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
			*(uint16_t*)SP = *(uint32_t*)0x4001c028; // = 0x0000 (modified bits = 0x0000)

			// MemRead ADC: DR7 (address was computed as 0x4001c01c + 0x00000010)
			// MemWrite 8 kB SRAM0 (address was computed as SP + 0x00000000)
			*(uint16_t*)SP = *(uint32_t*)0x4001c02c; // = 0x0000 (modified bits = 0x0000)
		}
		// Restore reg3 from Stack at 0x10001f98 (Value saved was 0x07000000)
		// Restore PC from Stack at 0x10001f9c (Value saved was 0x00002b33)
		// Stack Pointer updated to 0x10001fa0

		// MemRead 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000004)
		// MemWrite 8 kB SRAM0 (address was computed as 0x10000010 + 0x00000004)
		*(uint32_t*)0x10000014 = *(uint32_t*)0x10000014 + 0x00000001; // = 0x00000001 (modified bits = 0x00000001)

	}
	// Restore reg3 from Stack at 0x10001fa0 (Value saved was 0x07000000)
	// Restore reg4 from Stack at 0x10001fa4 (Value saved was 0x10000010)
	// Restore reg5 from Stack at 0x10001fa8 (Value saved was 0x00000001)
	// Restore reg6 from Stack at 0x10001fac (Value saved was 0x00010074)
	// Restore reg7 from Stack at 0x10001fb0 (Value saved was 0x00000000)
	// Restore PC from Stack at 0x10001fb4 (Value saved was 0x00002cfe)
	// Stack Pointer updated to 0x10001fb8

	// PC is set to reg14 (LR) which was previously saved to stack. This is exit of IRQ.
}

/*******************************************************************************
   Below are remaining entry points from vector table that do not have
    function yet. These will be simulated on an as needed basis.

   See Exceptions section in README.md for details on simulating exceptions

	000040:  0000 0121     Vector Table     IRQ0
	000044:  0000 0129     Vector Table     IRQ1
	000048:  0000 0131     Vector Table     IRQ2
	00004c:  0000 0139     Vector Table     IRQ3
	000050:  0000 0141     Vector Table     IRQ4
	000054:  0000 0149     Vector Table     IRQ5
	000058:  0000 0151     Vector Table     IRQ6
	00005c:  0000 0159     Vector Table     IRQ7
	000060:  0000 0161     Vector Table     IRQ8
	000064:  0000 0169     Vector Table     IRQ9
	000068:  0000 0171     Vector Table     IRQ10
	00006c:  0000 0179     Vector Table     IRQ11
	000070:  0000 0179     Vector Table     IRQ12
	000074:  0000 0189     Vector Table     IRQ13
	000078:  0000 0191     Vector Table     IRQ14
	00007c:  0000 0199     Vector Table     IRQ15
	000080:  0000 01a1     Vector Table     IRQ16
	000084:  0000 01a9     Vector Table     IRQ17
	000088:  0000 01b1     Vector Table     IRQ18
	000090:  0000 01cd     Vector Table     IRQ20
	00009c:  0000 01fd     Vector Table     IRQ23
	0000a0:  0000 0205     Vector Table     IRQ24
	0000a4:  0000 020d     Vector Table     IRQ25
	0000a8:  0000 0215     Vector Table     IRQ26
	0000ac:  0000 021d     Vector Table     IRQ27
	0000b0:  0000 0225     Vector Table     IRQ28
	0000b4:  0000 022d     Vector Table     IRQ29
	0000b8:  0000 0235     Vector Table     IRQ30
	0000bc:  0000 023d     Vector Table     IRQ31
*******************************************************************************/
